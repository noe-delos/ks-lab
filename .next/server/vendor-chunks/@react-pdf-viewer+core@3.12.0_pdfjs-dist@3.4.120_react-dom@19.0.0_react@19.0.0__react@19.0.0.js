"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0";
exports.ids = ["vendor-chunks/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/cjs/core.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/cjs/core.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.1.3_@babel+core@7.26.0_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nvar PdfJsApi = __webpack_require__(/*! pdfjs-dist */ \"(ssr)/./node_modules/.pnpm/pdfjs-dist@3.4.120/node_modules/pdfjs-dist/build/pdf.js\");\n\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\nvar PdfJsApi__namespace = /*#__PURE__*/_interopNamespaceDefault(PdfJsApi);\n\nexports.AnnotationType = void 0;\n(function (AnnotationType) {\n    AnnotationType[AnnotationType[\"Text\"] = 1] = \"Text\";\n    AnnotationType[AnnotationType[\"Link\"] = 2] = \"Link\";\n    AnnotationType[AnnotationType[\"FreeText\"] = 3] = \"FreeText\";\n    AnnotationType[AnnotationType[\"Line\"] = 4] = \"Line\";\n    AnnotationType[AnnotationType[\"Square\"] = 5] = \"Square\";\n    AnnotationType[AnnotationType[\"Circle\"] = 6] = \"Circle\";\n    AnnotationType[AnnotationType[\"Polygon\"] = 7] = \"Polygon\";\n    AnnotationType[AnnotationType[\"Polyline\"] = 8] = \"Polyline\";\n    AnnotationType[AnnotationType[\"Highlight\"] = 9] = \"Highlight\";\n    AnnotationType[AnnotationType[\"Underline\"] = 10] = \"Underline\";\n    AnnotationType[AnnotationType[\"Squiggly\"] = 11] = \"Squiggly\";\n    AnnotationType[AnnotationType[\"StrikeOut\"] = 12] = \"StrikeOut\";\n    AnnotationType[AnnotationType[\"Stamp\"] = 13] = \"Stamp\";\n    AnnotationType[AnnotationType[\"Caret\"] = 14] = \"Caret\";\n    AnnotationType[AnnotationType[\"Ink\"] = 15] = \"Ink\";\n    AnnotationType[AnnotationType[\"Popup\"] = 16] = \"Popup\";\n    AnnotationType[AnnotationType[\"FileAttachment\"] = 17] = \"FileAttachment\";\n})(exports.AnnotationType || (exports.AnnotationType = {}));\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nexports.TextDirection = void 0;\n(function (TextDirection) {\n    TextDirection[\"RightToLeft\"] = \"RTL\";\n    TextDirection[\"LeftToRight\"] = \"LTR\";\n})(exports.TextDirection || (exports.TextDirection = {}));\nvar ThemeContext = React__namespace.createContext({\n    currentTheme: 'light',\n    direction: exports.TextDirection.LeftToRight,\n    setCurrentTheme: function () { },\n});\n\nvar classNames = function (classes) {\n    var result = [];\n    Object.keys(classes).forEach(function (clazz) {\n        if (clazz && classes[clazz]) {\n            result.push(clazz);\n        }\n    });\n    return result.join(' ');\n};\n\nvar Button = function (_a) {\n    var children = _a.children, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ className: classNames({\n            'rpv-core__button': true,\n            'rpv-core__button--rtl': isRtl,\n        }), type: \"button\", onClick: onClick }, attrs), children));\n};\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;\n\nvar useIntersectionObserver = function (props) {\n    var containerRef = React__namespace.useRef(null);\n    var once = props.once, threshold = props.threshold, onVisibilityChanged = props.onVisibilityChanged;\n    useIsomorphicLayoutEffect(function () {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        var intersectionTracker = new IntersectionObserver(function (entries) {\n            entries.forEach(function (entry) {\n                var isVisible = entry.isIntersecting;\n                var ratio = entry.intersectionRatio;\n                onVisibilityChanged({ isVisible: isVisible, ratio: ratio });\n                if (isVisible && once) {\n                    intersectionTracker.unobserve(container);\n                    intersectionTracker.disconnect();\n                }\n            });\n        }, {\n            threshold: threshold || 0,\n        });\n        intersectionTracker.observe(container);\n        return function () {\n            intersectionTracker.unobserve(container);\n            intersectionTracker.disconnect();\n        };\n    }, []);\n    return containerRef;\n};\n\nvar LazyRender = function (_a) {\n    var attrs = _a.attrs, children = _a.children, testId = _a.testId;\n    var _b = React__namespace.useState(false), visible = _b[0], setVisible = _b[1];\n    var containerAttrs = testId ? __assign(__assign({}, attrs), { 'data-testid': testId }) : attrs;\n    var handleVisibilityChanged = function (params) {\n        if (params.isVisible) {\n            setVisible(true);\n        }\n    };\n    var containerRef = useIntersectionObserver({\n        once: true,\n        onVisibilityChanged: handleVisibilityChanged,\n    });\n    return (React__namespace.createElement(\"div\", __assign({ ref: containerRef }, containerAttrs), visible && children));\n};\n\nvar Menu = function (_a) {\n    var children = _a.children;\n    var containerRef = React__namespace.useRef();\n    var visibleMenuItemsRef = React__namespace.useRef([]);\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var handleKeyDown = function (e) {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        switch (e.key) {\n            case 'Tab':\n                e.preventDefault();\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n                moveToItem(function (_, currentIndex) { return currentIndex + 1; });\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n                moveToItem(function (_, currentIndex) { return currentIndex - 1; });\n                break;\n            case 'End':\n                e.preventDefault();\n                moveToItem(function (items, _) { return items.length - 1; });\n                break;\n            case 'Home':\n                e.preventDefault();\n                moveToItem(function (_, __) { return 0; });\n                break;\n        }\n    };\n    var moveToItem = function (getNextItem) {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        var items = visibleMenuItemsRef.current;\n        var currentIndex = items.findIndex(function (item) { return item.getAttribute('tabindex') === '0'; });\n        var targetIndex = Math.min(items.length - 1, Math.max(0, getNextItem(items, currentIndex)));\n        if (currentIndex >= 0 && currentIndex <= items.length - 1) {\n            items[currentIndex].setAttribute('tabindex', '-1');\n        }\n        items[targetIndex].setAttribute('tabindex', '0');\n        items[targetIndex].focus();\n    };\n    var findVisibleItems = function (container) {\n        var visibleItems = [];\n        container.querySelectorAll('.rpv-core__menu-item[role=\"menuitem\"]').forEach(function (item) {\n            if (item instanceof HTMLElement) {\n                var parent_1 = item.parentElement;\n                if (parent_1 === container) {\n                    visibleItems.push(item);\n                }\n                else {\n                    if (window.getComputedStyle(parent_1).display !== 'none') {\n                        visibleItems.push(item);\n                    }\n                }\n            }\n        });\n        return visibleItems;\n    };\n    useIsomorphicLayoutEffect(function () {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        var visibleItems = findVisibleItems(container);\n        visibleMenuItemsRef.current = visibleItems;\n    }, []);\n    useIsomorphicLayoutEffect(function () {\n        document.addEventListener('keydown', handleKeyDown);\n        return function () {\n            document.removeEventListener('keydown', handleKeyDown);\n        };\n    }, []);\n    return (React__namespace.createElement(\"div\", { ref: containerRef, \"aria-orientation\": \"vertical\", className: classNames({\n            'rpv-core__menu': true,\n            'rpv-core__menu--rtl': isRtl,\n        }), role: \"menu\", tabIndex: 0 }, children));\n};\n\nvar MenuDivider = function () { return (React__namespace.createElement(\"div\", { \"aria-orientation\": \"horizontal\", className: \"rpv-core__menu-divider\", role: \"separator\" })); };\n\nvar Icon = function (_a) {\n    var children = _a.children, _b = _a.ignoreDirection, ignoreDirection = _b === void 0 ? false : _b, _c = _a.size, size = _c === void 0 ? 24 : _c;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = !ignoreDirection && direction === exports.TextDirection.RightToLeft;\n    var width = \"\".concat(size || 24, \"px\");\n    return (React__namespace.createElement(\"svg\", { \"aria-hidden\": \"true\", className: classNames({\n            'rpv-core__icon': true,\n            'rpv-core__icon--rtl': isRtl,\n        }), focusable: \"false\", height: width, viewBox: \"0 0 24 24\", width: width }, children));\n};\n\nvar CheckIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M23.5,0.499l-16.5,23l-6.5-6.5\" }))); };\n\nvar MenuItem = function (_a) {\n    var _b = _a.checked, checked = _b === void 0 ? false : _b, children = _a.children, _c = _a.icon, icon = _c === void 0 ? null : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ className: classNames({\n            'rpv-core__menu-item': true,\n            'rpv-core__menu-item--disabled': isDisabled,\n            'rpv-core__menu-item--ltr': !isRtl,\n            'rpv-core__menu-item--rtl': isRtl,\n        }), role: \"menuitem\", tabIndex: -1, type: \"button\", onClick: onClick }, attrs),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__menu-item-icon': true,\n                'rpv-core__menu-item-icon--ltr': !isRtl,\n                'rpv-core__menu-item-icon--rtl': isRtl,\n            }) }, icon),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__menu-item-label': true,\n                'rpv-core__menu-item-label--ltr': !isRtl,\n                'rpv-core__menu-item-label--rtl': isRtl,\n            }) }, children),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__menu-item-check': true,\n                'rpv-core__menu-item-check--ltr': !isRtl,\n                'rpv-core__menu-item-check--rtl': isRtl,\n            }) }, checked && React__namespace.createElement(CheckIcon, null))));\n};\n\nvar MinimalButton = function (_a) {\n    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.ariaKeyShortcuts, ariaKeyShortcuts = _c === void 0 ? '' : _c, children = _a.children, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.isSelected, isSelected = _e === void 0 ? false : _e, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ \"aria-label\": ariaLabel }, (ariaKeyShortcuts && { 'aria-keyshortcuts': ariaKeyShortcuts }), (isDisabled && { 'aria-disabled': true }), { className: classNames({\n            'rpv-core__minimal-button': true,\n            'rpv-core__minimal-button--disabled': isDisabled,\n            'rpv-core__minimal-button--rtl': isRtl,\n            'rpv-core__minimal-button--selected': isSelected,\n        }), type: \"button\", onClick: onClick }, attrs), children));\n};\n\nvar PrimaryButton = function (_a) {\n    var children = _a.children, testId = _a.testId, onClick = _a.onClick;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = testId ? { 'data-testid': testId } : {};\n    return (React__namespace.createElement(\"button\", __assign({ className: classNames({\n            'rpv-core__primary-button': true,\n            'rpv-core__primary-button--rtl': isRtl,\n        }), type: \"button\", onClick: onClick }, attrs), children));\n};\n\nvar ProgressBar = function (_a) {\n    var progress = _a.progress;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    return (React__namespace.createElement(\"div\", { className: classNames({\n            'rpv-core__progress-bar': true,\n            'rpv-core__progress-bar--rtl': isRtl,\n        }) },\n        React__namespace.createElement(\"div\", { className: \"rpv-core__progress-bar-progress\", style: { width: \"\".concat(progress, \"%\") } },\n            progress,\n            \"%\")));\n};\n\nvar Separator = function () { return React__namespace.createElement(\"div\", { className: \"rpv-core__separator\" }); };\n\nvar Spinner = function (_a) {\n    var _b = _a.size, size = _b === void 0 ? '4rem' : _b, testId = _a.testId;\n    var _c = React__namespace.useState(false), visible = _c[0], setVisible = _c[1];\n    var attrs = testId ? { 'data-testid': testId } : {};\n    var handleVisibilityChanged = function (params) {\n        setVisible(params.isVisible);\n    };\n    var containerRef = useIntersectionObserver({\n        onVisibilityChanged: handleVisibilityChanged,\n    });\n    return (React__namespace.createElement(\"div\", __assign({}, attrs, { className: classNames({\n            'rpv-core__spinner': true,\n            'rpv-core__spinner--animating': visible,\n        }), ref: containerRef, style: { height: size, width: size } })));\n};\n\nvar Splitter = function (_a) {\n    var constrain = _a.constrain;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var resizerRef = React__namespace.useRef();\n    var leftSideRef = React__namespace.useRef();\n    var rightSideRef = React__namespace.useRef();\n    var xRef = React__namespace.useRef(0);\n    var yRef = React__namespace.useRef(0);\n    var leftWidthRef = React__namespace.useRef(0);\n    var resizerWidthRef = React__namespace.useRef(0);\n    var eventOptions = {\n        capture: true,\n    };\n    var handleMouseMove = function (e) {\n        var resizerEle = resizerRef.current;\n        var leftSide = leftSideRef.current;\n        var rightSide = rightSideRef.current;\n        if (!resizerEle || !leftSide || !rightSide) {\n            return;\n        }\n        var resizerWidth = resizerWidthRef.current;\n        var dx = e.clientX - xRef.current;\n        var firstHalfSize = leftWidthRef.current + (isRtl ? -dx : dx);\n        var containerWidth = resizerEle.parentElement.getBoundingClientRect().width;\n        var firstHalfPercentage = (firstHalfSize * 100) / containerWidth;\n        resizerEle.classList.add('rpv-core__splitter--resizing');\n        if (constrain) {\n            var secondHalfSize = containerWidth - firstHalfSize - resizerWidth;\n            var secondHalfPercentage = (secondHalfSize * 100) / containerWidth;\n            if (!constrain({ firstHalfPercentage: firstHalfPercentage, firstHalfSize: firstHalfSize, secondHalfPercentage: secondHalfPercentage, secondHalfSize: secondHalfSize })) {\n                return;\n            }\n        }\n        leftSide.style.width = \"\".concat(firstHalfPercentage, \"%\");\n        document.body.classList.add('rpv-core__splitter-body--resizing');\n        leftSide.classList.add('rpv-core__splitter-sibling--resizing');\n        rightSide.classList.add('rpv-core__splitter-sibling--resizing');\n    };\n    var handleMouseUp = function (e) {\n        var resizerEle = resizerRef.current;\n        var leftSide = leftSideRef.current;\n        var rightSide = rightSideRef.current;\n        if (!resizerEle || !leftSide || !rightSide) {\n            return;\n        }\n        document.body.classList.remove('rpv-core__splitter-body--resizing');\n        resizerEle.classList.remove('rpv-core__splitter--resizing');\n        leftSide.classList.remove('rpv-core__splitter-sibling--resizing');\n        rightSide.classList.remove('rpv-core__splitter-sibling--resizing');\n        document.removeEventListener('mousemove', handleMouseMove, eventOptions);\n        document.removeEventListener('mouseup', handleMouseUp, eventOptions);\n    };\n    var handleMouseDown = function (e) {\n        var leftSide = leftSideRef.current;\n        if (!leftSide) {\n            return;\n        }\n        xRef.current = e.clientX;\n        yRef.current = e.clientY;\n        leftWidthRef.current = leftSide.getBoundingClientRect().width;\n        document.addEventListener('mousemove', handleMouseMove, eventOptions);\n        document.addEventListener('mouseup', handleMouseUp, eventOptions);\n    };\n    React__namespace.useEffect(function () {\n        var resizerEle = resizerRef.current;\n        if (!resizerEle) {\n            return;\n        }\n        resizerWidthRef.current = resizerEle.getBoundingClientRect().width;\n        leftSideRef.current = resizerEle.previousElementSibling;\n        rightSideRef.current = resizerEle.nextElementSibling;\n    }, []);\n    return React__namespace.createElement(\"div\", { ref: resizerRef, className: \"rpv-core__splitter\", onMouseDown: handleMouseDown });\n};\n\nvar TextBox = function (_a) {\n    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.autoFocus, autoFocus = _c === void 0 ? false : _c, _d = _a.placeholder, placeholder = _d === void 0 ? '' : _d, testId = _a.testId, _e = _a.type, type = _e === void 0 ? 'text' : _e, _f = _a.value, value = _f === void 0 ? '' : _f, onChange = _a.onChange, _g = _a.onKeyDown, onKeyDown = _g === void 0 ? function () { } : _g;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var textboxRef = React__namespace.useRef();\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var attrs = {\n        ref: textboxRef,\n        'data-testid': '',\n        'aria-label': ariaLabel,\n        className: classNames({\n            'rpv-core__textbox': true,\n            'rpv-core__textbox--rtl': isRtl,\n        }),\n        placeholder: placeholder,\n        value: value,\n        onChange: function (e) { return onChange(e.target.value); },\n        onKeyDown: onKeyDown,\n    };\n    if (testId) {\n        attrs['data-testid'] = testId;\n    }\n    useIsomorphicLayoutEffect(function () {\n        if (autoFocus) {\n            var textboxEle = textboxRef.current;\n            if (textboxEle) {\n                var x = window.scrollX;\n                var y = window.scrollY;\n                textboxEle.focus();\n                window.scrollTo(x, y);\n            }\n        }\n    }, []);\n    return type === 'text' ? React__namespace.createElement(\"input\", __assign({ type: \"text\" }, attrs)) : React__namespace.createElement(\"input\", __assign({ type: \"password\" }, attrs));\n};\n\nvar Api;\n(function (Api) {\n    Api[Api[\"ExitFullScreen\"] = 0] = \"ExitFullScreen\";\n    Api[Api[\"FullScreenChange\"] = 1] = \"FullScreenChange\";\n    Api[Api[\"FullScreenElement\"] = 2] = \"FullScreenElement\";\n    Api[Api[\"FullScreenEnabled\"] = 3] = \"FullScreenEnabled\";\n    Api[Api[\"RequestFullScreen\"] = 4] = \"RequestFullScreen\";\n})(Api || (Api = {}));\nvar defaultVendor = {\n    ExitFullScreen: 'exitFullscreen',\n    FullScreenChange: 'fullscreenchange',\n    FullScreenElement: 'fullscreenElement',\n    FullScreenEnabled: 'fullscreenEnabled',\n    RequestFullScreen: 'requestFullscreen',\n};\nvar webkitVendor = {\n    ExitFullScreen: 'webkitExitFullscreen',\n    FullScreenChange: 'webkitfullscreenchange',\n    FullScreenElement: 'webkitFullscreenElement',\n    FullScreenEnabled: 'webkitFullscreenEnabled',\n    RequestFullScreen: 'webkitRequestFullscreen',\n};\nvar msVendor = {\n    ExitFullScreen: 'msExitFullscreen',\n    FullScreenChange: 'msFullscreenChange',\n    FullScreenElement: 'msFullscreenElement',\n    FullScreenEnabled: 'msFullscreenEnabled',\n    RequestFullScreen: 'msRequestFullscreen',\n};\nvar isBrowser = typeof window !== 'undefined';\nvar vendor = isBrowser\n    ? (Api.FullScreenEnabled in document && defaultVendor) ||\n        (webkitVendor.FullScreenEnabled in document && webkitVendor) ||\n        (msVendor.FullScreenEnabled in document && msVendor) ||\n        defaultVendor\n    : defaultVendor;\nvar isFullScreenEnabled = function () {\n    return isBrowser && vendor.FullScreenEnabled in document && document[vendor.FullScreenEnabled] === true;\n};\nvar addFullScreenChangeListener = function (handler) {\n    if (isBrowser) {\n        document.addEventListener(vendor.FullScreenChange, handler);\n    }\n};\nvar removeFullScreenChangeListener = function (handler) {\n    if (isBrowser) {\n        document.removeEventListener(vendor.FullScreenChange, handler);\n    }\n};\nvar exitFullScreen = function (element) {\n    return isBrowser\n        ?\n            element[vendor.ExitFullScreen]()\n        : Promise.resolve({});\n};\nvar getFullScreenElement = function () {\n    return isBrowser ? document[vendor.FullScreenElement] : null;\n};\nvar requestFullScreen = function (element) {\n    if (isBrowser) {\n        element[vendor.RequestFullScreen]();\n    }\n};\n\nvar useDebounceCallback = function (callback, wait) {\n    var timeout = React__namespace.useRef();\n    var cleanup = function () {\n        if (timeout.current) {\n            clearTimeout(timeout.current);\n        }\n    };\n    React__namespace.useEffect(function () {\n        return function () { return cleanup(); };\n    }, []);\n    return React__namespace.useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        cleanup();\n        timeout.current = setTimeout(function () {\n            callback.apply(void 0, args);\n        }, wait);\n    }, [callback, wait]);\n};\n\nvar useIsMounted = function () {\n    var isMountedRef = React__namespace.useRef(false);\n    React__namespace.useEffect(function () {\n        isMountedRef.current = true;\n        return function () {\n            isMountedRef.current = false;\n        };\n    }, []);\n    return isMountedRef;\n};\n\nvar usePrevious = function (value) {\n    var ref = React__namespace.useRef(value);\n    React__namespace.useEffect(function () {\n        ref.current = value;\n    }, [value]);\n    return ref.current;\n};\n\nvar PageRenderStatus;\n(function (PageRenderStatus) {\n    PageRenderStatus[\"NotRenderedYet\"] = \"NotRenderedYet\";\n    PageRenderStatus[\"Rendering\"] = \"Rendering\";\n    PageRenderStatus[\"Rendered\"] = \"Rendered\";\n})(PageRenderStatus || (PageRenderStatus = {}));\nvar OUT_OF_RANGE_VISIBILITY = -9999;\nvar useRenderQueue = function (_a) {\n    var doc = _a.doc;\n    var numPages = doc.numPages;\n    var docId = doc.loadingTask.docId;\n    var initialPageVisibilities = React__namespace.useMemo(function () {\n        return Array(numPages)\n            .fill(null)\n            .map(function (_, pageIndex) { return ({\n            pageIndex: pageIndex,\n            renderStatus: PageRenderStatus.NotRenderedYet,\n            visibility: OUT_OF_RANGE_VISIBILITY,\n        }); });\n    }, [docId]);\n    var latestRef = React__namespace.useRef({\n        currentRenderingPage: -1,\n        startRange: 0,\n        endRange: numPages - 1,\n        visibilities: initialPageVisibilities,\n    });\n    var markNotRendered = function () {\n        for (var i = 0; i < numPages; i++) {\n            latestRef.current.visibilities[i].renderStatus = PageRenderStatus.NotRenderedYet;\n        }\n    };\n    var markRendered = function (pageIndex) {\n        latestRef.current.visibilities[pageIndex].renderStatus = PageRenderStatus.Rendered;\n    };\n    var markRendering = function (pageIndex) {\n        if (latestRef.current.currentRenderingPage !== -1 &&\n            latestRef.current.currentRenderingPage !== pageIndex &&\n            latestRef.current.visibilities[latestRef.current.currentRenderingPage].renderStatus ===\n                PageRenderStatus.Rendering) {\n            latestRef.current.visibilities[latestRef.current.currentRenderingPage].renderStatus =\n                PageRenderStatus.NotRenderedYet;\n        }\n        latestRef.current.visibilities[pageIndex].renderStatus = PageRenderStatus.Rendering;\n        latestRef.current.currentRenderingPage = pageIndex;\n    };\n    var setRange = function (startIndex, endIndex) {\n        latestRef.current.startRange = startIndex;\n        latestRef.current.endRange = endIndex;\n        for (var i = 0; i < numPages; i++) {\n            if (i < startIndex || i > endIndex) {\n                latestRef.current.visibilities[i].visibility = OUT_OF_RANGE_VISIBILITY;\n                latestRef.current.visibilities[i].renderStatus = PageRenderStatus.NotRenderedYet;\n            }\n        }\n    };\n    var setOutOfRange = function (pageIndex) {\n        setVisibility(pageIndex, OUT_OF_RANGE_VISIBILITY);\n    };\n    var setVisibility = function (pageIndex, visibility) {\n        latestRef.current.visibilities[pageIndex].visibility = visibility;\n    };\n    var getHighestPriorityPage = function () {\n        var visiblePages = latestRef.current.visibilities\n            .slice(latestRef.current.startRange, latestRef.current.endRange + 1)\n            .filter(function (item) { return item.visibility > OUT_OF_RANGE_VISIBILITY; });\n        if (!visiblePages.length) {\n            return -1;\n        }\n        var firstVisiblePage = visiblePages[0].pageIndex;\n        var lastVisiblePage = visiblePages[visiblePages.length - 1].pageIndex;\n        var numVisiblePages = visiblePages.length;\n        for (var i = 0; i < numVisiblePages; i++) {\n            if (visiblePages[i].renderStatus === PageRenderStatus.Rendering) {\n                return -1;\n            }\n            if (visiblePages[i].renderStatus === PageRenderStatus.NotRenderedYet) {\n                return visiblePages[i].pageIndex;\n            }\n        }\n        if (lastVisiblePage + 1 < numPages &&\n            latestRef.current.visibilities[lastVisiblePage + 1].renderStatus !== PageRenderStatus.Rendered) {\n            return lastVisiblePage + 1;\n        }\n        else if (firstVisiblePage - 1 >= 0 &&\n            latestRef.current.visibilities[firstVisiblePage - 1].renderStatus !== PageRenderStatus.Rendered) {\n            return firstVisiblePage - 1;\n        }\n        return -1;\n    };\n    var isInRange = function (pageIndex) {\n        return pageIndex >= latestRef.current.startRange && pageIndex <= latestRef.current.endRange;\n    };\n    return {\n        getHighestPriorityPage: getHighestPriorityPage,\n        isInRange: isInRange,\n        markNotRendered: markNotRendered,\n        markRendered: markRendered,\n        markRendering: markRendering,\n        setOutOfRange: setOutOfRange,\n        setRange: setRange,\n        setVisibility: setVisibility,\n    };\n};\n\nvar core = {\n\taskingPassword: {\n\t\trequirePasswordToOpen: \"This document requires a password to open\",\n\t\tsubmit: \"Submit\"\n\t},\n\twrongPassword: {\n\t\ttryAgain: \"The password is wrong. Please try again\"\n\t},\n\tpageLabel: \"Page {{pageIndex}}\"\n};\nvar enUs = {\n\tcore: core\n};\n\nvar DefaultLocalization = enUs;\nvar LocalizationContext = React__namespace.createContext({\n    l10n: DefaultLocalization,\n    setL10n: function () { },\n});\n\nvar id = 0;\nvar uniqueId = function () { return id++; };\n\nvar useClickOutside = function (closeOnClickOutside, targetRef, onClickOutside) {\n    var clickHandler = function (e) {\n        var target = targetRef.current;\n        if (!target) {\n            return;\n        }\n        var clickedTarget = e.target;\n        if (clickedTarget instanceof Element && clickedTarget.shadowRoot) {\n            var paths = e.composedPath();\n            if (paths.length > 0 && !target.contains(paths[0])) {\n                onClickOutside();\n            }\n        }\n        else if (!target.contains(clickedTarget)) {\n            onClickOutside();\n        }\n    };\n    React__namespace.useEffect(function () {\n        if (!closeOnClickOutside) {\n            return;\n        }\n        var eventOptions = {\n            capture: true,\n        };\n        document.addEventListener('click', clickHandler, eventOptions);\n        return function () {\n            document.removeEventListener('click', clickHandler, eventOptions);\n        };\n    }, []);\n};\n\nvar useEscape = function (handler) {\n    var keyUpHandler = function (e) {\n        if (e.key === 'Escape') {\n            handler();\n        }\n    };\n    React__namespace.useEffect(function () {\n        document.addEventListener('keyup', keyUpHandler);\n        return function () {\n            document.removeEventListener('keyup', keyUpHandler);\n        };\n    }, []);\n};\n\nvar useLockScroll = function () {\n    React__namespace.useEffect(function () {\n        var originalStyle = window.getComputedStyle(document.body).overflow;\n        document.body.style.overflow = 'hidden';\n        return function () {\n            document.body.style.overflow = originalStyle;\n        };\n    }, []);\n};\n\nvar ModalBody = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, onToggle = _a.onToggle;\n    var contentRef = React__namespace.useRef();\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    useLockScroll();\n    useEscape(function () {\n        if (contentRef.current && closeOnEscape) {\n            onToggle();\n        }\n    });\n    useClickOutside(closeOnClickOutside, contentRef, onToggle);\n    useIsomorphicLayoutEffect(function () {\n        var contentEle = contentRef.current;\n        if (!contentEle) {\n            return;\n        }\n        var maxHeight = document.body.clientHeight * 0.75;\n        if (contentEle.getBoundingClientRect().height >= maxHeight) {\n            contentEle.style.overflow = 'auto';\n            contentEle.style.maxHeight = \"\".concat(maxHeight, \"px\");\n        }\n    }, []);\n    return (React__namespace.createElement(\"div\", { \"aria-modal\": \"true\", className: classNames({\n            'rpv-core__modal-body': true,\n            'rpv-core__modal-body--rtl': isRtl,\n        }), id: \"rpv-core__modal-body-\".concat(ariaControlsSuffix), ref: contentRef, role: \"dialog\", tabIndex: -1 }, children));\n};\n\nvar ModalOverlay = function (_a) {\n    var children = _a.children;\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__modal-overlay\" }, children);\n};\n\nexports.ToggleStatus = void 0;\n(function (ToggleStatus) {\n    ToggleStatus[\"Close\"] = \"Close\";\n    ToggleStatus[\"Open\"] = \"Open\";\n    ToggleStatus[\"Toggle\"] = \"Toggle\";\n})(exports.ToggleStatus || (exports.ToggleStatus = {}));\n\nvar useToggle = function (isOpened) {\n    var _a = React__namespace.useState(isOpened), opened = _a[0], setOpened = _a[1];\n    var toggle = function (status) {\n        switch (status) {\n            case exports.ToggleStatus.Close:\n                setOpened(false);\n                break;\n            case exports.ToggleStatus.Open:\n                setOpened(true);\n                break;\n            case exports.ToggleStatus.Toggle:\n            default:\n                setOpened(function (isOpened) { return !isOpened; });\n                break;\n        }\n    };\n    return { opened: opened, toggle: toggle };\n};\n\nvar Portal = function (_a) {\n    var content = _a.content, _b = _a.isOpened, isOpened = _b === void 0 ? false : _b, target = _a.target;\n    var _c = useToggle(isOpened), opened = _c.opened, toggle = _c.toggle;\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        target && target(toggle, opened),\n        opened && content(toggle)));\n};\n\nvar Modal = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, _b = _a.isOpened, isOpened = _b === void 0 ? false : _b, target = _a.target;\n    var controlsSuffix = ariaControlsSuffix || \"\".concat(uniqueId());\n    var renderTarget = function (toggle, opened) { return (React__namespace.createElement(\"div\", { \"aria-expanded\": opened ? 'true' : 'false', \"aria-haspopup\": \"dialog\", \"aria-controls\": \"rpv-core__modal-body-\".concat(controlsSuffix) }, target(toggle, opened))); };\n    var renderContent = function (toggle) { return (React__namespace.createElement(ModalOverlay, null,\n        React__namespace.createElement(ModalBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, closeOnEscape: closeOnEscape, onToggle: toggle }, content(toggle)))); };\n    return React__namespace.createElement(Portal, { target: target ? renderTarget : null, content: renderContent, isOpened: isOpened });\n};\n\nexports.Position = void 0;\n(function (Position) {\n    Position[\"TopLeft\"] = \"TOP_LEFT\";\n    Position[\"TopCenter\"] = \"TOP_CENTER\";\n    Position[\"TopRight\"] = \"TOP_RIGHT\";\n    Position[\"RightTop\"] = \"RIGHT_TOP\";\n    Position[\"RightCenter\"] = \"RIGHT_CENTER\";\n    Position[\"RightBottom\"] = \"RIGHT_BOTTOM\";\n    Position[\"BottomLeft\"] = \"BOTTOM_LEFT\";\n    Position[\"BottomCenter\"] = \"BOTTOM_CENTER\";\n    Position[\"BottomRight\"] = \"BOTTOM_RIGHT\";\n    Position[\"LeftTop\"] = \"LEFT_TOP\";\n    Position[\"LeftCenter\"] = \"LEFT_CENTER\";\n    Position[\"LeftBottom\"] = \"LEFT_BOTTOM\";\n})(exports.Position || (exports.Position = {}));\n\nvar calculatePosition = function (content, target, position, offset) {\n    var targetRect = target.getBoundingClientRect();\n    var contentRect = content.getBoundingClientRect();\n    var height = contentRect.height, width = contentRect.width;\n    var top = 0;\n    var left = 0;\n    switch (position) {\n        case exports.Position.TopLeft:\n            top = targetRect.top - height;\n            left = targetRect.left;\n            break;\n        case exports.Position.TopCenter:\n            top = targetRect.top - height;\n            left = targetRect.left + targetRect.width / 2 - width / 2;\n            break;\n        case exports.Position.TopRight:\n            top = targetRect.top - height;\n            left = targetRect.left + targetRect.width - width;\n            break;\n        case exports.Position.RightTop:\n            top = targetRect.top;\n            left = targetRect.left + targetRect.width;\n            break;\n        case exports.Position.RightCenter:\n            top = targetRect.top + targetRect.height / 2 - height / 2;\n            left = targetRect.left + targetRect.width;\n            break;\n        case exports.Position.RightBottom:\n            top = targetRect.top + targetRect.height - height;\n            left = targetRect.left + targetRect.width;\n            break;\n        case exports.Position.BottomLeft:\n            top = targetRect.top + targetRect.height;\n            left = targetRect.left;\n            break;\n        case exports.Position.BottomCenter:\n            top = targetRect.top + targetRect.height;\n            left = targetRect.left + targetRect.width / 2 - width / 2;\n            break;\n        case exports.Position.BottomRight:\n            top = targetRect.top + targetRect.height;\n            left = targetRect.left + targetRect.width - width;\n            break;\n        case exports.Position.LeftTop:\n            top = targetRect.top;\n            left = targetRect.left - width;\n            break;\n        case exports.Position.LeftCenter:\n            top = targetRect.top + targetRect.height / 2 - height / 2;\n            left = targetRect.left - width;\n            break;\n        case exports.Position.LeftBottom:\n            top = targetRect.top + targetRect.height - height;\n            left = targetRect.left - width;\n            break;\n    }\n    return {\n        left: left + (offset.left || 0),\n        top: top + (offset.top || 0),\n    };\n};\n\nvar usePosition = function (contentRef, targetRef, anchorRef, position, offset) {\n    useIsomorphicLayoutEffect(function () {\n        var targetEle = targetRef.current;\n        var contentEle = contentRef.current;\n        var anchorEle = anchorRef.current;\n        if (!contentEle || !targetEle || !anchorEle) {\n            return;\n        }\n        var anchorRect = anchorEle.getBoundingClientRect();\n        var _a = calculatePosition(contentEle, targetEle, position, offset), top = _a.top, left = _a.left;\n        contentEle.style.top = \"\".concat(top - anchorRect.top, \"px\");\n        contentEle.style.left = \"\".concat(left - anchorRect.left, \"px\");\n    }, []);\n};\n\nvar Arrow = function (_a) {\n    var _b;\n    var customClassName = _a.customClassName, position = _a.position;\n    return (React__namespace.createElement(\"div\", { className: classNames((_b = {\n                'rpv-core__arrow': true,\n                'rpv-core__arrow--tl': position === exports.Position.TopLeft,\n                'rpv-core__arrow--tc': position === exports.Position.TopCenter,\n                'rpv-core__arrow--tr': position === exports.Position.TopRight,\n                'rpv-core__arrow--rt': position === exports.Position.RightTop,\n                'rpv-core__arrow--rc': position === exports.Position.RightCenter,\n                'rpv-core__arrow--rb': position === exports.Position.RightBottom,\n                'rpv-core__arrow--bl': position === exports.Position.BottomLeft,\n                'rpv-core__arrow--bc': position === exports.Position.BottomCenter,\n                'rpv-core__arrow--br': position === exports.Position.BottomRight,\n                'rpv-core__arrow--lt': position === exports.Position.LeftTop,\n                'rpv-core__arrow--lc': position === exports.Position.LeftCenter,\n                'rpv-core__arrow--lb': position === exports.Position.LeftBottom\n            },\n            _b[\"\".concat(customClassName)] = customClassName !== '',\n            _b)) }));\n};\n\nvar PopoverBody = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, offset = _a.offset, position = _a.position, targetRef = _a.targetRef, onClose = _a.onClose;\n    var contentRef = React__namespace.useRef();\n    var innerRef = React__namespace.useRef();\n    var anchorRef = React__namespace.useRef();\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    useClickOutside(closeOnClickOutside, contentRef, onClose);\n    usePosition(contentRef, targetRef, anchorRef, position, offset);\n    useIsomorphicLayoutEffect(function () {\n        var innerContentEle = innerRef.current;\n        if (!innerContentEle) {\n            return;\n        }\n        var maxHeight = document.body.clientHeight * 0.75;\n        if (innerContentEle.getBoundingClientRect().height >= maxHeight) {\n            innerContentEle.style.overflow = 'auto';\n            innerContentEle.style.maxHeight = \"\".concat(maxHeight, \"px\");\n        }\n    }, []);\n    var innerId = \"rpv-core__popover-body-inner-\".concat(ariaControlsSuffix);\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),\n        React__namespace.createElement(\"div\", { \"aria-describedby\": innerId, className: classNames({\n                'rpv-core__popover-body': true,\n                'rpv-core__popover-body--rtl': isRtl,\n            }), id: \"rpv-core__popover-body-\".concat(ariaControlsSuffix), ref: contentRef, role: \"dialog\", tabIndex: -1 },\n            React__namespace.createElement(Arrow, { customClassName: \"rpv-core__popover-body-arrow\", position: position }),\n            React__namespace.createElement(\"div\", { id: innerId, ref: innerRef }, children))));\n};\n\nvar PopoverOverlay = function (_a) {\n    var closeOnEscape = _a.closeOnEscape, onClose = _a.onClose;\n    var containerRef = React__namespace.useRef();\n    useEscape(function () {\n        if (containerRef.current && closeOnEscape) {\n            onClose();\n        }\n    });\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__popover-overlay\", ref: containerRef });\n};\n\nvar Popover = function (_a) {\n    var _b = _a.ariaHasPopup, ariaHasPopup = _b === void 0 ? 'dialog' : _b, ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, _c = _a.lockScroll, lockScroll = _c === void 0 ? true : _c, offset = _a.offset, position = _a.position, target = _a.target;\n    var _d = useToggle(false), opened = _d.opened, toggle = _d.toggle;\n    var targetRef = React__namespace.useRef();\n    var controlsSuffix = React__namespace.useMemo(function () { return ariaControlsSuffix || \"\".concat(uniqueId()); }, []);\n    return (React__namespace.createElement(\"div\", { ref: targetRef, \"aria-expanded\": opened ? 'true' : 'false', \"aria-haspopup\": ariaHasPopup, \"aria-controls\": \"rpv-core__popver-body-\".concat(controlsSuffix) },\n        target(toggle, opened),\n        opened && (React__namespace.createElement(React__namespace.Fragment, null,\n            lockScroll && React__namespace.createElement(PopoverOverlay, { closeOnEscape: closeOnEscape, onClose: toggle }),\n            React__namespace.createElement(PopoverBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, offset: offset, position: position, targetRef: targetRef, onClose: toggle }, content(toggle))))));\n};\n\nvar TooltipBody = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, contentRef = _a.contentRef, offset = _a.offset, position = _a.position, targetRef = _a.targetRef;\n    var anchorRef = React__namespace.useRef();\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    usePosition(contentRef, targetRef, anchorRef, position, offset);\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__tooltip-body': true,\n                'rpv-core__tooltip-body--rtl': isRtl,\n            }), id: \"rpv-core__tooltip-body-\".concat(ariaControlsSuffix), ref: contentRef, role: \"tooltip\" },\n            React__namespace.createElement(Arrow, { customClassName: \"rpv-core__tooltip-body-arrow\", position: position }),\n            React__namespace.createElement(\"div\", { className: \"rpv-core__tooltip-body-content\" }, children))));\n};\n\nvar Tooltip = function (_a) {\n    var ariaControlsSuffix = _a.ariaControlsSuffix, content = _a.content, offset = _a.offset, position = _a.position, target = _a.target;\n    var _b = useToggle(false), opened = _b.opened, toggle = _b.toggle;\n    var targetRef = React__namespace.useRef();\n    var contentRef = React__namespace.useRef();\n    var controlsSuffix = React__namespace.useMemo(function () { return ariaControlsSuffix || \"\".concat(uniqueId()); }, []);\n    useEscape(function () {\n        if (targetRef.current && document.activeElement && targetRef.current.contains(document.activeElement)) {\n            close();\n        }\n    });\n    var open = function () {\n        toggle(exports.ToggleStatus.Open);\n    };\n    var close = function () {\n        toggle(exports.ToggleStatus.Close);\n    };\n    var onBlur = function (e) {\n        var shouldHideTooltip = e.relatedTarget instanceof HTMLElement &&\n            e.currentTarget.parentElement &&\n            e.currentTarget.parentElement.contains(e.relatedTarget);\n        if (shouldHideTooltip) {\n            if (contentRef.current) {\n                contentRef.current.style.display = 'none';\n            }\n        }\n        else {\n            close();\n        }\n    };\n    return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", { ref: targetRef, \"aria-describedby\": \"rpv-core__tooltip-body-\".concat(controlsSuffix), onBlur: onBlur, onFocus: open, onMouseEnter: open, onMouseLeave: close }, target),\n        opened && (React__namespace.createElement(TooltipBody, { ariaControlsSuffix: controlsSuffix, contentRef: contentRef, offset: offset, position: position, targetRef: targetRef }, content()))));\n};\n\nfunction createStore(initialState) {\n    var state = initialState || {};\n    var listeners = {};\n    var update = function (key, data) {\n        var _a;\n        state = __assign(__assign({}, state), (_a = {}, _a[key] = data, _a));\n        (listeners[key] || []).forEach(function (handler) { return handler(state[key]); });\n    };\n    var get = function (key) { return state[key]; };\n    return {\n        subscribe: function (key, handler) {\n            listeners[key] = (listeners[key] || []).concat(handler);\n        },\n        unsubscribe: function (key, handler) {\n            listeners[key] = (listeners[key] || []).filter(function (f) { return f !== handler; });\n        },\n        update: function (key, data) {\n            update(key, data);\n        },\n        updateCurrentValue: function (key, updater) {\n            var currentValue = get(key);\n            if (currentValue !== undefined) {\n                update(key, updater(currentValue));\n            }\n        },\n        get: function (key) {\n            return get(key);\n        },\n    };\n}\n\nexports.FullScreenMode = void 0;\n(function (FullScreenMode) {\n    FullScreenMode[\"Normal\"] = \"Normal\";\n    FullScreenMode[\"Entering\"] = \"Entering\";\n    FullScreenMode[\"Entered\"] = \"Entered\";\n    FullScreenMode[\"EnteredCompletely\"] = \"EnteredCompletely\";\n    FullScreenMode[\"Exitting\"] = \"Exitting\";\n    FullScreenMode[\"Exited\"] = \"Exited\";\n})(exports.FullScreenMode || (exports.FullScreenMode = {}));\n\nexports.LayerRenderStatus = void 0;\n(function (LayerRenderStatus) {\n    LayerRenderStatus[LayerRenderStatus[\"PreRender\"] = 0] = \"PreRender\";\n    LayerRenderStatus[LayerRenderStatus[\"DidRender\"] = 1] = \"DidRender\";\n})(exports.LayerRenderStatus || (exports.LayerRenderStatus = {}));\n\nexports.PageMode = void 0;\n(function (PageMode) {\n    PageMode[\"Attachments\"] = \"UseAttachments\";\n    PageMode[\"Bookmarks\"] = \"UseOutlines\";\n    PageMode[\"ContentGroup\"] = \"UseOC\";\n    PageMode[\"Default\"] = \"UserNone\";\n    PageMode[\"FullScreen\"] = \"FullScreen\";\n    PageMode[\"Thumbnails\"] = \"UseThumbs\";\n})(exports.PageMode || (exports.PageMode = {}));\n\nexports.PasswordStatus = void 0;\n(function (PasswordStatus) {\n    PasswordStatus[\"RequiredPassword\"] = \"RequiredPassword\";\n    PasswordStatus[\"WrongPassword\"] = \"WrongPassword\";\n})(exports.PasswordStatus || (exports.PasswordStatus = {}));\n\nexports.RotateDirection = void 0;\n(function (RotateDirection) {\n    RotateDirection[\"Backward\"] = \"Backward\";\n    RotateDirection[\"Forward\"] = \"Forward\";\n})(exports.RotateDirection || (exports.RotateDirection = {}));\n\nexports.ScrollMode = void 0;\n(function (ScrollMode) {\n    ScrollMode[\"Page\"] = \"Page\";\n    ScrollMode[\"Horizontal\"] = \"Horizontal\";\n    ScrollMode[\"Vertical\"] = \"Vertical\";\n    ScrollMode[\"Wrapped\"] = \"Wrapped\";\n})(exports.ScrollMode || (exports.ScrollMode = {}));\n\nexports.SpecialZoomLevel = void 0;\n(function (SpecialZoomLevel) {\n    SpecialZoomLevel[\"ActualSize\"] = \"ActualSize\";\n    SpecialZoomLevel[\"PageFit\"] = \"PageFit\";\n    SpecialZoomLevel[\"PageWidth\"] = \"PageWidth\";\n})(exports.SpecialZoomLevel || (exports.SpecialZoomLevel = {}));\n\nexports.ViewMode = void 0;\n(function (ViewMode) {\n    ViewMode[\"DualPage\"] = \"DualPage\";\n    ViewMode[\"DualPageWithCover\"] = \"DualPageWithCover\";\n    ViewMode[\"SinglePage\"] = \"SinglePage\";\n})(exports.ViewMode || (exports.ViewMode = {}));\n\nvar chunk = function (arr, size) {\n    return arr.reduce(function (acc, e, i) { return (i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc); }, []);\n};\n\nvar isMac = function () { return (typeof window !== 'undefined' ? /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) : false); };\n\nvar normalizeDestination = function (pageIndex, destArray) {\n    switch (destArray[1].name) {\n        case 'XYZ':\n            return {\n                bottomOffset: function (_, viewportHeight) {\n                    return destArray[3] === null ? viewportHeight : destArray[3];\n                },\n                leftOffset: function (_, __) { return (destArray[2] === null ? 0 : destArray[2]); },\n                pageIndex: pageIndex,\n                scaleTo: destArray[4],\n            };\n        case 'Fit':\n        case 'FitB':\n            return {\n                bottomOffset: 0,\n                leftOffset: 0,\n                pageIndex: pageIndex,\n                scaleTo: exports.SpecialZoomLevel.PageFit,\n            };\n        case 'FitH':\n        case 'FitBH':\n            return {\n                bottomOffset: destArray[2],\n                leftOffset: 0,\n                pageIndex: pageIndex,\n                scaleTo: exports.SpecialZoomLevel.PageWidth,\n            };\n        default:\n            return {\n                bottomOffset: 0,\n                leftOffset: 0,\n                pageIndex: pageIndex,\n                scaleTo: 1,\n            };\n    }\n};\nvar pageOutlinesMap = new Map();\nvar pagesMap = new Map();\nvar generateRefKey = function (doc, outline) {\n    return \"\".concat(doc.loadingTask.docId, \"___\").concat(outline.num, \"R\").concat(outline.gen === 0 ? '' : outline.gen);\n};\nvar getPageIndex = function (doc, outline) {\n    var key = generateRefKey(doc, outline);\n    return pageOutlinesMap.has(key) ? pageOutlinesMap.get(key) : null;\n};\nvar cacheOutlineRef = function (doc, outline, pageIndex) {\n    pageOutlinesMap.set(generateRefKey(doc, outline), pageIndex);\n};\nvar clearPagesCache = function () {\n    pageOutlinesMap.clear();\n    pagesMap.clear();\n};\nvar getPage = function (doc, pageIndex) {\n    if (!doc) {\n        return Promise.reject('The document is not loaded yet');\n    }\n    var pageKey = \"\".concat(doc.loadingTask.docId, \"___\").concat(pageIndex);\n    var page = pagesMap.get(pageKey);\n    if (page) {\n        return Promise.resolve(page);\n    }\n    return new Promise(function (resolve, _) {\n        doc.getPage(pageIndex + 1).then(function (page) {\n            pagesMap.set(pageKey, page);\n            if (page.ref) {\n                cacheOutlineRef(doc, page.ref, pageIndex);\n            }\n            resolve(page);\n        });\n    });\n};\nvar getDestination = function (doc, dest) {\n    return new Promise(function (res) {\n        new Promise(function (resolve) {\n            if (typeof dest === 'string') {\n                doc.getDestination(dest).then(function (destArray) {\n                    resolve(destArray);\n                });\n            }\n            else {\n                resolve(dest);\n            }\n        }).then(function (destArray) {\n            if ('object' === typeof destArray[0] && destArray[0] !== null) {\n                var outlineRef_1 = destArray[0];\n                var pageIndex = getPageIndex(doc, outlineRef_1);\n                if (pageIndex === null) {\n                    doc.getPageIndex(outlineRef_1).then(function (pageIndex) {\n                        cacheOutlineRef(doc, outlineRef_1, pageIndex);\n                        getDestination(doc, dest).then(function (result) { return res(result); });\n                    });\n                }\n                else {\n                    res(normalizeDestination(pageIndex, destArray));\n                }\n            }\n            else {\n                var target = normalizeDestination(destArray[0], destArray);\n                res(target);\n            }\n        });\n    });\n};\n\nvar useRunOnce = function (cb, condition) {\n    var isCalledRef = React__namespace.useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        if (condition && !isCalledRef.current) {\n            isCalledRef.current = true;\n            cb();\n        }\n    }, [cb, condition]);\n};\n\nvar useTrackResize = function (_a) {\n    var targetRef = _a.targetRef, onResize = _a.onResize;\n    useIsomorphicLayoutEffect(function () {\n        var io = new ResizeObserver(function (entries) {\n            entries.forEach(function (entry) {\n                onResize(entry.target);\n            });\n        });\n        var container = targetRef.current;\n        if (!container) {\n            return;\n        }\n        io.observe(container);\n        return function () {\n            io.unobserve(container);\n        };\n    }, []);\n};\n\nvar AnnotationBorderStyleType;\n(function (AnnotationBorderStyleType) {\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Solid\"] = 1] = \"Solid\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Dashed\"] = 2] = \"Dashed\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Beveled\"] = 3] = \"Beveled\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Inset\"] = 4] = \"Inset\";\n    AnnotationBorderStyleType[AnnotationBorderStyleType[\"Underline\"] = 5] = \"Underline\";\n})(AnnotationBorderStyleType || (AnnotationBorderStyleType = {}));\n\nvar dateRegex = new RegExp('^D:' +\n    '(\\\\d{4})' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '(\\\\d{2})?' +\n    '([Z|+|-])?' +\n    '(\\\\d{2})?' +\n    \"'?\" +\n    '(\\\\d{2})?' +\n    \"'?\");\nvar parse = function (value, min, max, defaultValue) {\n    var parsed = parseInt(value, 10);\n    return parsed >= min && parsed <= max ? parsed : defaultValue;\n};\nvar convertDate = function (input) {\n    var matches = dateRegex.exec(input);\n    if (!matches) {\n        return null;\n    }\n    var year = parseInt(matches[1], 10);\n    var month = parse(matches[2], 1, 12, 1) - 1;\n    var day = parse(matches[3], 1, 31, 1);\n    var hour = parse(matches[4], 0, 23, 0);\n    var minute = parse(matches[5], 0, 59, 0);\n    var second = parse(matches[6], 0, 59, 0);\n    var universalTimeRelation = matches[7] || 'Z';\n    var offsetHour = parse(matches[8], 0, 23, 0);\n    var offsetMinute = parse(matches[9], 0, 59, 0);\n    switch (universalTimeRelation) {\n        case '-':\n            hour += offsetHour;\n            minute += offsetMinute;\n            break;\n        case '+':\n            hour -= offsetHour;\n            minute -= offsetMinute;\n            break;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n};\n\nvar getContents = function (annotation) {\n    return annotation.contentsObj ? annotation.contentsObj.str : annotation.contents || '';\n};\n\nvar getTitle = function (annotation) {\n    return annotation.titleObj ? annotation.titleObj.str : annotation.title || '';\n};\n\nvar PopupWrapper = function (_a) {\n    var annotation = _a.annotation;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var containerRef = React__namespace.useRef();\n    var dateStr = '';\n    if (annotation.modificationDate) {\n        var date = convertDate(annotation.modificationDate);\n        dateStr = date ? \"\".concat(date.toLocaleDateString(), \", \").concat(date.toLocaleTimeString()) : '';\n    }\n    React__namespace.useLayoutEffect(function () {\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        var annotationEle = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.id, \"\\\"]\"));\n        if (!annotationEle) {\n            return;\n        }\n        var ele = annotationEle;\n        ele.style.zIndex += 1;\n        return function () {\n            ele.style.zIndex = \"\".concat(parseInt(ele.style.zIndex, 10) - 1);\n        };\n    }, []);\n    return (React__namespace.createElement(\"div\", { ref: containerRef, className: classNames({\n            'rpv-core__annotation-popup-wrapper': true,\n            'rpv-core__annotation-popup-wrapper--rtl': isRtl,\n        }), style: {\n            top: annotation.annotationType === exports.AnnotationType.Popup ? '' : '100%',\n        } },\n        title && (React__namespace.createElement(React__namespace.Fragment, null,\n            React__namespace.createElement(\"div\", { className: classNames({\n                    'rpv-core__annotation-popup-title': true,\n                    'rpv-core__annotation-popup-title--ltr': !isRtl,\n                    'rpv-core__annotation-popup-title--rtl': isRtl,\n                }) }, title),\n            React__namespace.createElement(\"div\", { className: \"rpv-core__annotation-popup-date\" }, dateStr))),\n        contents && (React__namespace.createElement(\"div\", { className: \"rpv-core__annotation-popup-content\" }, contents.split('\\n').map(function (item, index) { return (React__namespace.createElement(React__namespace.Fragment, { key: index },\n            item,\n            React__namespace.createElement(\"br\", null))); })))));\n};\n\nvar TogglePopupBy;\n(function (TogglePopupBy) {\n    TogglePopupBy[\"Click\"] = \"Click\";\n    TogglePopupBy[\"Hover\"] = \"Hover\";\n})(TogglePopupBy || (TogglePopupBy = {}));\nvar useTogglePopup = function () {\n    var _a = useToggle(false), opened = _a.opened, toggle = _a.toggle;\n    var _b = React__namespace.useState(TogglePopupBy.Hover), togglePopupBy = _b[0], setTooglePopupBy = _b[1];\n    var toggleOnClick = function () {\n        switch (togglePopupBy) {\n            case TogglePopupBy.Click:\n                opened && setTooglePopupBy(TogglePopupBy.Hover);\n                toggle(exports.ToggleStatus.Toggle);\n                break;\n            case TogglePopupBy.Hover:\n                setTooglePopupBy(TogglePopupBy.Click);\n                toggle(exports.ToggleStatus.Open);\n                break;\n        }\n    };\n    var openOnHover = function () {\n        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Open);\n    };\n    var closeOnHover = function () {\n        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Close);\n    };\n    return {\n        opened: opened,\n        closeOnHover: closeOnHover,\n        openOnHover: openOnHover,\n        toggleOnClick: toggleOnClick,\n    };\n};\n\nvar Annotation = function (_a) {\n    var annotation = _a.annotation, children = _a.children, ignoreBorder = _a.ignoreBorder, hasPopup = _a.hasPopup, isRenderable = _a.isRenderable, page = _a.page, viewport = _a.viewport;\n    var rect = annotation.rect;\n    var _b = useTogglePopup(), closeOnHover = _b.closeOnHover, opened = _b.opened, openOnHover = _b.openOnHover, toggleOnClick = _b.toggleOnClick;\n    var normalizeRect = function (r) { return [\n        Math.min(r[0], r[2]),\n        Math.min(r[1], r[3]),\n        Math.max(r[0], r[2]),\n        Math.max(r[1], r[3]),\n    ]; };\n    var bound = normalizeRect([\n        rect[0],\n        page.view[3] + page.view[1] - rect[1],\n        rect[2],\n        page.view[3] + page.view[1] - rect[3],\n    ]);\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var styles = {\n        borderColor: '',\n        borderRadius: '',\n        borderStyle: '',\n        borderWidth: '',\n    };\n    if (!ignoreBorder && annotation.borderStyle.width > 0) {\n        switch (annotation.borderStyle.style) {\n            case AnnotationBorderStyleType.Dashed:\n                styles.borderStyle = 'dashed';\n                break;\n            case AnnotationBorderStyleType.Solid:\n                styles.borderStyle = 'solid';\n                break;\n            case AnnotationBorderStyleType.Underline:\n                styles = Object.assign({\n                    borderBottomStyle: 'solid',\n                }, styles);\n                break;\n            case AnnotationBorderStyleType.Beveled:\n            case AnnotationBorderStyleType.Inset:\n        }\n        var borderWidth = annotation.borderStyle.width;\n        styles.borderWidth = \"\".concat(borderWidth, \"px\");\n        if (annotation.borderStyle.style !== AnnotationBorderStyleType.Underline) {\n            width = width - 2 * borderWidth;\n            height = height - 2 * borderWidth;\n        }\n        var _c = annotation.borderStyle, horizontalCornerRadius = _c.horizontalCornerRadius, verticalCornerRadius = _c.verticalCornerRadius;\n        if (horizontalCornerRadius > 0 || verticalCornerRadius > 0) {\n            styles.borderRadius = \"\".concat(horizontalCornerRadius, \"px / \").concat(verticalCornerRadius, \"px\");\n        }\n        annotation.color\n            ? (styles.borderColor = \"rgb(\".concat(annotation.color[0] | 0, \", \").concat(annotation.color[1] | 0, \", \").concat(annotation.color[2] | 0, \")\"))\n            :\n                (styles.borderWidth = '0');\n    }\n    return (React__namespace.createElement(React__namespace.Fragment, null, isRenderable &&\n        children({\n            popup: {\n                opened: opened,\n                closeOnHover: closeOnHover,\n                openOnHover: openOnHover,\n                toggleOnClick: toggleOnClick,\n            },\n            slot: {\n                attrs: {\n                    style: Object.assign({\n                        height: \"\".concat(height, \"px\"),\n                        left: \"\".concat(bound[0], \"px\"),\n                        top: \"\".concat(bound[1], \"px\"),\n                        transform: \"matrix(\".concat(viewport.transform.join(','), \")\"),\n                        transformOrigin: \"-\".concat(bound[0], \"px -\").concat(bound[1], \"px\"),\n                        width: \"\".concat(width, \"px\"),\n                    }, styles),\n                },\n                children: React__namespace.createElement(React__namespace.Fragment, null, hasPopup && opened && React__namespace.createElement(PopupWrapper, { annotation: annotation })),\n            },\n        })));\n};\n\nvar Caret = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--caret\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar Circle = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--circle\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"circle\", { cy: height / 2, fill: \"none\", rx: width / 2 - borderWidth / 2, ry: height / 2 - borderWidth / 2, stroke: \"transparent\", strokeWidth: borderWidth || 1 })),\n        props.slot.children)); }));\n};\n\nvar getFileName = function (url) {\n    var str = url.split('/').pop();\n    return str ? str.split('#')[0].split('?')[0] : url;\n};\n\nvar downloadFile = function (url, data) {\n    var blobUrl = typeof data === 'string' ? '' : URL.createObjectURL(new Blob([data], { type: '' }));\n    var link = document.createElement('a');\n    link.style.display = 'none';\n    link.href = blobUrl || url;\n    link.setAttribute('download', getFileName(url));\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    if (blobUrl) {\n        URL.revokeObjectURL(blobUrl);\n    }\n};\n\nvar FileAttachment = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var hasPopup = annotation.hasPopup === false && (!!title || !!contents);\n    var doubleClick = function () {\n        var file = annotation.file;\n        file && downloadFile(file.filename, file.content);\n    };\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: true, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--file-attachment\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onDoubleClick: doubleClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar FreeText = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--free-text\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar Popup = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(title || contents);\n    var ignoredParents = ['Circle', 'Ink', 'Line', 'Polygon', 'PolyLine', 'Square'];\n    var hasPopup = !annotation.parentType || ignoredParents.indexOf(annotation.parentType) !== -1;\n    useIsomorphicLayoutEffect(function () {\n        if (!annotation.parentId) {\n            return;\n        }\n        var parent = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.parentId, \"\\\"]\"));\n        var container = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.id, \"\\\"]\"));\n        if (!parent || !container) {\n            return;\n        }\n        var left = parseFloat(parent.style.left);\n        var top = parseFloat(parent.style.top) + parseFloat(parent.style.height);\n        container.style.left = \"\".concat(left, \"px\");\n        container.style.top = \"\".concat(top, \"px\");\n        container.style.transformOrigin = \"-\".concat(left, \"px -\").concat(top, \"px\");\n    }, []);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--popup\", \"data-annotation-id\": annotation.id }),\n        React__namespace.createElement(PopupWrapper, { annotation: annotation }))); }));\n};\n\nvar Highlight = function (_a) {\n    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var hasQuadPoints = annotation.quadPoints && annotation.quadPoints.length > 0;\n    if (hasQuadPoints) {\n        var annotations = annotation.quadPoints.map(function (quadPoint) {\n            return Object.assign({}, annotation, {\n                rect: [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y],\n                quadPoints: [],\n            });\n        });\n        return (React__namespace.createElement(React__namespace.Fragment, null, annotations.map(function (ann, index) { return (React__namespace.createElement(Highlight, { key: index, annotation: ann, childAnnotation: childAnnotation, page: page, viewport: viewport })); })));\n    }\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--highlight\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children),\n        childAnnotation &&\n            childAnnotation.annotationType === exports.AnnotationType.Popup &&\n            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));\n};\n\nvar Ink = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--ink\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        annotation.inkLists && annotation.inkLists.length && (React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") }, annotation.inkLists.map(function (inkList, index) { return (React__namespace.createElement(\"polyline\", { key: index, fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, points: inkList.map(function (item) { return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y); }).join(' ') })); }))),\n        props.slot.children)); }));\n};\n\nvar Line = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--line\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"line\", { stroke: \"transparent\", strokeWidth: borderWidth || 1, x1: rect[2] - annotation.lineCoordinates[0], x2: rect[2] - annotation.lineCoordinates[2], y1: rect[3] - annotation.lineCoordinates[1], y2: rect[3] - annotation.lineCoordinates[3] })),\n        props.slot.children)); }));\n};\n\nvar INVALID_PROTOCOL = /^([^\\w]*)(javascript|data|vbscript)/im;\nvar HTML_ENTITIES = /&#(\\w+)(^\\w|;)?/g;\nvar CTRL_CHARS = /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nvar URL_SCHEME = /^([^:]+):/gm;\nvar decodeHtmlEntities = function (str) { return str.replace(HTML_ENTITIES, function (_, dec) { return String.fromCharCode(dec); }); };\nvar sanitizeUrl = function (url, defaultUrl) {\n    if (defaultUrl === void 0) { defaultUrl = 'about:blank'; }\n    var result = decodeHtmlEntities(url || '')\n        .replace(CTRL_CHARS, '')\n        .trim();\n    if (!result) {\n        return defaultUrl;\n    }\n    var firstChar = result[0];\n    if (firstChar === '.' || firstChar === '/') {\n        return result;\n    }\n    var parsedUrlScheme = result.match(URL_SCHEME);\n    if (!parsedUrlScheme) {\n        return result;\n    }\n    var scheme = parsedUrlScheme[0];\n    return INVALID_PROTOCOL.test(scheme) ? defaultUrl : result;\n};\n\nvar Link = function (_a) {\n    var _b;\n    var annotation = _a.annotation, annotationContainerRef = _a.annotationContainerRef, doc = _a.doc, outlines = _a.outlines, page = _a.page, pageIndex = _a.pageIndex, scale = _a.scale, viewport = _a.viewport, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest;\n    var elementRef = React__namespace.useRef();\n    var title = outlines && outlines.length && annotation.dest && typeof annotation.dest === 'string'\n        ? (_b = outlines.find(function (item) { return item.dest === annotation.dest; })) === null || _b === void 0 ? void 0 : _b.title\n        : '';\n    var link = function (e) {\n        e.preventDefault();\n        annotation.action\n            ? onExecuteNamedAction(annotation.action)\n            : getDestination(doc, annotation.dest).then(function (target) {\n                var element = elementRef.current;\n                var annotationContainer = annotationContainerRef.current;\n                if (element && annotationContainer) {\n                    var linkRect = element.getBoundingClientRect();\n                    annotationContainer.style.setProperty('height', '100%');\n                    annotationContainer.style.setProperty('width', '100%');\n                    var annotationLayerRect = annotationContainer.getBoundingClientRect();\n                    annotationContainer.style.removeProperty('height');\n                    annotationContainer.style.removeProperty('width');\n                    var leftOffset = (linkRect.left - annotationLayerRect.left) / scale;\n                    var bottomOffset = (annotationLayerRect.bottom - linkRect.bottom + linkRect.height) / scale;\n                    onJumpFromLinkAnnotation({\n                        bottomOffset: bottomOffset,\n                        label: title,\n                        leftOffset: leftOffset,\n                        pageIndex: pageIndex,\n                    });\n                }\n                onJumpToDest(target);\n            });\n    };\n    var isRenderable = !!(annotation.url || annotation.dest || annotation.action || annotation.unsafeUrl);\n    var attrs = {};\n    if (annotation.url || annotation.unsafeUrl) {\n        var targetUrl = sanitizeUrl(annotation.url || annotation.unsafeUrl, '');\n        if (targetUrl) {\n            attrs = {\n                'data-target': 'external',\n                href: targetUrl,\n                rel: 'noopener noreferrer nofollow',\n                target: annotation.newWindow ? '_blank' : '',\n                title: targetUrl,\n            };\n        }\n        else {\n            isRenderable = false;\n        }\n    }\n    else {\n        attrs = {\n            href: '',\n            'data-annotation-link': annotation.id,\n            onClick: link,\n        };\n    }\n    if (title) {\n        attrs = Object.assign({}, attrs, {\n            title: title,\n            'aria-label': title,\n        });\n    }\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: false, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--link\", \"data-annotation-id\": annotation.id, \"data-testid\": \"core__annotation--link-\".concat(annotation.id) }),\n        React__namespace.createElement(\"a\", __assign({ ref: elementRef }, attrs)))); }));\n};\n\nvar Polygon = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--polygon\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        annotation.vertices && annotation.vertices.length && (React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"polygon\", { fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, points: annotation.vertices\n                    .map(function (item) { return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y); })\n                    .join(' ') }))),\n        props.slot.children)); }));\n};\n\nvar Polyline = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--polyline\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        annotation.vertices && annotation.vertices.length && (React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"polyline\", { fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, points: annotation.vertices\n                    .map(function (item) { return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y); })\n                    .join(' ') }))),\n        props.slot.children)); }));\n};\n\nvar Square = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var rect = annotation.rect;\n    var width = rect[2] - rect[0];\n    var height = rect[3] - rect[1];\n    var borderWidth = annotation.borderStyle.width;\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--square\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n        React__namespace.createElement(\"svg\", { height: \"\".concat(height, \"px\"), preserveAspectRatio: \"none\", version: \"1.1\", viewBox: \"0 0 \".concat(width, \" \").concat(height), width: \"\".concat(width, \"px\") },\n            React__namespace.createElement(\"rect\", { height: height - borderWidth, fill: \"none\", stroke: \"transparent\", strokeWidth: borderWidth || 1, x: borderWidth / 2, y: borderWidth / 2, width: width - borderWidth })),\n        props.slot.children)); }));\n};\n\nvar Squiggly = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--squiggly\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar Stamp = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--stamp\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar StrikeOut = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--strike-out\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar CommentIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25\" }),\n    React__namespace.createElement(\"path\", { d: \"M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75\" }),\n    React__namespace.createElement(\"path\", { d: \"M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25\" }))); };\n\nvar HelpIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M21.423 5.406L17.415 9.414\" }),\n    React__namespace.createElement(\"path\", { d: \"M14.587 6.585L18.607 2.565\" }),\n    React__namespace.createElement(\"path\", { d: \"M5.405 21.424L9.413 17.416\" }),\n    React__namespace.createElement(\"path\", { d: \"M6.585 14.588L2.577 18.596\" }),\n    React__namespace.createElement(\"path\", { d: \"M18.602 21.419L14.595 17.412\" }),\n    React__namespace.createElement(\"path\", { d: \"M17.419 14.58L21.428 18.589\" }),\n    React__namespace.createElement(\"path\", { d: \"M2.582 5.399L6.588 9.406\" }),\n    React__namespace.createElement(\"path\", { d: \"M9.421 6.581L5.412 2.572\" }))); };\n\nvar KeyIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z\" }))); };\n\nvar NoteIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z\" }),\n    React__namespace.createElement(\"path\", { d: \"M6 4.5L6 0.5\" }),\n    React__namespace.createElement(\"path\", { d: \"M18 4.5L18 0.5\" }),\n    React__namespace.createElement(\"path\", { d: \"M10 4.5L10 0.5\" }),\n    React__namespace.createElement(\"path\", { d: \"M14 4.5L14 0.5\" }))); };\n\nvar ParagraphIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M17.5 0.498L17.5 23.498\" }),\n    React__namespace.createElement(\"path\", { d: \"M10.5 0.498L10.5 23.498\" }),\n    React__namespace.createElement(\"path\", { d: \"M23.5.5H6.5a6,6,0,0,0,0,12h4\" }))); };\n\nvar TriangleIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },\n    React__namespace.createElement(\"path\", { d: \"M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z\" }))); };\n\nvar Text = function (_a) {\n    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    var name = annotation.name ? annotation.name.toLowerCase() : '';\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,\n        React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--text\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),\n            name && (React__namespace.createElement(\"div\", { className: \"rpv-core__annotation-text-icon\" },\n                name === 'check' && React__namespace.createElement(CheckIcon, null),\n                name === 'comment' && React__namespace.createElement(CommentIcon, null),\n                name === 'help' && React__namespace.createElement(HelpIcon, null),\n                name === 'insert' && React__namespace.createElement(TriangleIcon, null),\n                name === 'key' && React__namespace.createElement(KeyIcon, null),\n                name === 'note' && React__namespace.createElement(NoteIcon, null),\n                (name === 'newparagraph' || name === 'paragraph') && React__namespace.createElement(ParagraphIcon, null))),\n            props.slot.children),\n        childAnnotation &&\n            childAnnotation.annotationType === exports.AnnotationType.Popup &&\n            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));\n};\n\nvar Underline = function (_a) {\n    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;\n    var hasPopup = annotation.hasPopup === false;\n    var title = getTitle(annotation);\n    var contents = getContents(annotation);\n    var isRenderable = !!(annotation.hasPopup || title || contents);\n    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, { className: \"rpv-core__annotation rpv-core__annotation--underline\", \"data-annotation-id\": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));\n};\n\nvar AnnotationLayerBody = function (_a) {\n    var annotations = _a.annotations, doc = _a.doc, outlines = _a.outlines, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest;\n    var containerRef = React__namespace.useRef();\n    var viewport = page.getViewport({ rotation: rotation, scale: scale });\n    var clonedViewPort = viewport.clone({ dontFlip: true });\n    var filterAnnotations = annotations.filter(function (annotation) { return !annotation.parentId; });\n    useIsomorphicLayoutEffect(function () {\n        var container = containerRef.current;\n        if (!container) {\n            return;\n        }\n        plugins.forEach(function (plugin) {\n            if (plugin.onAnnotationLayerRender) {\n                plugin.onAnnotationLayerRender({\n                    annotations: filterAnnotations,\n                    container: container,\n                    pageIndex: pageIndex,\n                    rotation: rotation,\n                    scale: scale,\n                });\n            }\n        });\n    }, []);\n    return (React__namespace.createElement(\"div\", { ref: containerRef, className: \"rpv-core__annotation-layer\", \"data-testid\": \"core__annotation-layer-\".concat(pageIndex) }, filterAnnotations.map(function (annotation) {\n        var childAnnotation = annotations.find(function (item) { return item.parentId === annotation.id; });\n        switch (annotation.annotationType) {\n            case exports.AnnotationType.Caret:\n                return (React__namespace.createElement(Caret, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Circle:\n                return (React__namespace.createElement(Circle, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.FileAttachment:\n                return (React__namespace.createElement(FileAttachment, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.FreeText:\n                return (React__namespace.createElement(FreeText, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Highlight:\n                return (React__namespace.createElement(Highlight, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Ink:\n                return (React__namespace.createElement(Ink, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Line:\n                return (React__namespace.createElement(Line, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Link:\n                return (React__namespace.createElement(Link, { key: annotation.id, annotation: annotation, annotationContainerRef: containerRef, doc: doc, outlines: outlines, page: page, pageIndex: pageIndex, scale: scale, viewport: clonedViewPort, onExecuteNamedAction: onExecuteNamedAction, onJumpFromLinkAnnotation: onJumpFromLinkAnnotation, onJumpToDest: onJumpToDest }));\n            case exports.AnnotationType.Polygon:\n                return (React__namespace.createElement(Polygon, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Polyline:\n                return (React__namespace.createElement(Polyline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Popup:\n                return (React__namespace.createElement(Popup, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Square:\n                return (React__namespace.createElement(Square, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Squiggly:\n                return (React__namespace.createElement(Squiggly, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Stamp:\n                return (React__namespace.createElement(Stamp, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.StrikeOut:\n                return (React__namespace.createElement(StrikeOut, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Text:\n                return (React__namespace.createElement(Text, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));\n            case exports.AnnotationType.Underline:\n                return (React__namespace.createElement(Underline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));\n            default:\n                return React__namespace.createElement(React__namespace.Fragment, { key: annotation.id });\n        }\n    })));\n};\n\nvar AnnotationLoader = function (_a) {\n    var page = _a.page, renderAnnotations = _a.renderAnnotations;\n    var isMounted = useIsMounted();\n    var _b = React__namespace.useState({\n        loading: true,\n        annotations: [],\n    }), status = _b[0], setStatus = _b[1];\n    React__namespace.useEffect(function () {\n        page.getAnnotations({ intent: 'display' }).then(function (result) {\n            if (isMounted.current) {\n                setStatus({\n                    loading: false,\n                    annotations: result,\n                });\n            }\n        });\n    }, []);\n    return status.loading ? React__namespace.createElement(React__namespace.Fragment, null) : renderAnnotations(status.annotations);\n};\n\nvar AnnotationLayer = function (_a) {\n    var doc = _a.doc, outlines = _a.outlines, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest;\n    var renderAnnotations = function (annotations) { return (React__namespace.createElement(AnnotationLayerBody, { annotations: annotations, doc: doc, outlines: outlines, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotation, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpFromLinkAnnotation: onJumpFromLinkAnnotation, onJumpToDest: onJumpToDest })); };\n    return React__namespace.createElement(AnnotationLoader, { page: page, renderAnnotations: renderAnnotations });\n};\n\nvar floatToRatio = function (x, limit) {\n    var _a, _b;\n    if (Math.floor(x) === x) {\n        return [x, 1];\n    }\n    var y = 1 / x;\n    if (y > limit) {\n        return [1, limit];\n    }\n    if (Math.floor(y) === y) {\n        return [1, y];\n    }\n    var value = x > 1 ? y : x;\n    var a = 0;\n    var b = 1;\n    var c = 1;\n    var d = 1;\n    while (true) {\n        var numerator = a + c;\n        var denominator = b + d;\n        if (denominator > limit) {\n            break;\n        }\n        value <= numerator / denominator ? (_a = [numerator, denominator], c = _a[0], d = _a[1], _a) : (_b = [numerator, denominator], a = _b[0], b = _b[1], _b);\n    }\n    var middle = (a / b + c / d) / 2;\n    return value < middle ? (value === x ? [a, b] : [b, a]) : value === x ? [c, d] : [d, c];\n};\n\nvar roundToDivide = function (a, b) {\n    var remainder = a % b;\n    return remainder === 0 ? a : Math.floor(a - remainder);\n};\n\nvar MAX_CANVAS_SIZE = 4096 * 4096;\nvar CanvasLayer = function (_a) {\n    var canvasLayerRef = _a.canvasLayerRef, height = _a.height, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, width = _a.width, onRenderCanvasCompleted = _a.onRenderCanvasCompleted;\n    var renderTask = React__namespace.useRef();\n    useIsomorphicLayoutEffect(function () {\n        var task = renderTask.current;\n        if (task) {\n            task.cancel();\n        }\n        var canvasEle = canvasLayerRef.current;\n        canvasEle.removeAttribute('data-testid');\n        plugins.forEach(function (plugin) {\n            if (plugin.onCanvasLayerRender) {\n                plugin.onCanvasLayerRender({\n                    ele: canvasEle,\n                    pageIndex: pageIndex,\n                    rotation: rotation,\n                    scale: scale,\n                    status: exports.LayerRenderStatus.PreRender,\n                });\n            }\n        });\n        var viewport = page.getViewport({\n            rotation: rotation,\n            scale: scale,\n        });\n        var outputScale = window.devicePixelRatio || 1;\n        var maxScale = Math.sqrt(MAX_CANVAS_SIZE / (viewport.width * viewport.height));\n        var shouldScaleByCSS = outputScale > maxScale;\n        shouldScaleByCSS ? (canvasEle.style.transform = \"scale(1, 1)\") : canvasEle.style.removeProperty('transform');\n        var possibleScale = Math.min(maxScale, outputScale);\n        var _a = floatToRatio(possibleScale, 8), x = _a[0], y = _a[1];\n        canvasEle.width = roundToDivide(viewport.width * possibleScale, x);\n        canvasEle.height = roundToDivide(viewport.height * possibleScale, x);\n        canvasEle.style.width = \"\".concat(roundToDivide(viewport.width, y), \"px\");\n        canvasEle.style.height = \"\".concat(roundToDivide(viewport.height, y), \"px\");\n        canvasEle.hidden = true;\n        var canvasContext = canvasEle.getContext('2d', { alpha: false });\n        var transform = shouldScaleByCSS || outputScale !== 1 ? [possibleScale, 0, 0, possibleScale, 0, 0] : null;\n        renderTask.current = page.render({ canvasContext: canvasContext, transform: transform, viewport: viewport });\n        renderTask.current.promise.then(function () {\n            canvasEle.hidden = false;\n            canvasEle.setAttribute('data-testid', \"core__canvas-layer-\".concat(pageIndex));\n            plugins.forEach(function (plugin) {\n                if (plugin.onCanvasLayerRender) {\n                    plugin.onCanvasLayerRender({\n                        ele: canvasEle,\n                        pageIndex: pageIndex,\n                        rotation: rotation,\n                        scale: scale,\n                        status: exports.LayerRenderStatus.DidRender,\n                    });\n                }\n            });\n            onRenderCanvasCompleted();\n        }, function () {\n            onRenderCanvasCompleted();\n        });\n        return function () {\n            if (canvasEle) {\n                canvasEle.width = 0;\n                canvasEle.height = 0;\n            }\n        };\n    }, []);\n    return (React__namespace.createElement(\"div\", { className: \"rpv-core__canvas-layer\", style: {\n            height: \"\".concat(height, \"px\"),\n            width: \"\".concat(width, \"px\"),\n        } },\n        React__namespace.createElement(\"canvas\", { ref: canvasLayerRef })));\n};\n\nvar SvgLayer = function (_a) {\n    var height = _a.height, page = _a.page, rotation = _a.rotation, scale = _a.scale, width = _a.width;\n    var containerRef = React__namespace.useRef();\n    var empty = function () {\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        containerEle.innerHTML = '';\n    };\n    useIsomorphicLayoutEffect(function () {\n        var containerEle = containerRef.current;\n        var viewport = page.getViewport({ rotation: rotation, scale: scale });\n        page.getOperatorList().then(function (operatorList) {\n            empty();\n            var graphic = new PdfJsApi__namespace.SVGGraphics(page.commonObjs, page.objs);\n            graphic.getSVG(operatorList, viewport).then(function (svg) {\n                svg.style.height = \"\".concat(height, \"px\");\n                svg.style.width = \"\".concat(width, \"px\");\n                containerEle.appendChild(svg);\n            });\n        });\n    }, []);\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__svg-layer\", ref: containerRef });\n};\n\nvar TextLayer = function (_a) {\n    var containerRef = _a.containerRef, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onRenderTextCompleted = _a.onRenderTextCompleted;\n    var renderTask = React__namespace.useRef();\n    var empty = function () {\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        var spans = [].slice.call(containerEle.querySelectorAll('.rpv-core__text-layer-text'));\n        spans.forEach(function (span) { return containerEle.removeChild(span); });\n        var breaks = [].slice.call(containerEle.querySelectorAll('br[role=\"presentation\"]'));\n        breaks.forEach(function (br) { return containerEle.removeChild(br); });\n    };\n    useIsomorphicLayoutEffect(function () {\n        var task = renderTask.current;\n        if (task) {\n            task.cancel();\n        }\n        var containerEle = containerRef.current;\n        if (!containerEle) {\n            return;\n        }\n        containerEle.removeAttribute('data-testid');\n        var viewport = page.getViewport({ rotation: rotation, scale: scale });\n        plugins.forEach(function (plugin) {\n            if (plugin.onTextLayerRender) {\n                plugin.onTextLayerRender({\n                    ele: containerEle,\n                    pageIndex: pageIndex,\n                    scale: scale,\n                    status: exports.LayerRenderStatus.PreRender,\n                });\n            }\n        });\n        page.getTextContent().then(function (textContent) {\n            empty();\n            renderTask.current = PdfJsApi__namespace.renderTextLayer({\n                container: containerEle,\n                textContent: textContent,\n                textContentSource: textContent,\n                viewport: viewport,\n            });\n            renderTask.current.promise.then(function () {\n                containerEle.setAttribute('data-testid', \"core__text-layer-\".concat(pageIndex));\n                var spans = [].slice.call(containerEle.children);\n                spans.forEach(function (span) {\n                    if (!span.classList.contains('rpv-core__text-layer-text--not')) {\n                        span.classList.add('rpv-core__text-layer-text');\n                    }\n                });\n                plugins.forEach(function (plugin) {\n                    if (plugin.onTextLayerRender) {\n                        plugin.onTextLayerRender({\n                            ele: containerEle,\n                            pageIndex: pageIndex,\n                            scale: scale,\n                            status: exports.LayerRenderStatus.DidRender,\n                        });\n                    }\n                });\n                onRenderTextCompleted();\n            }, function () {\n                containerEle.removeAttribute('data-testid');\n                onRenderTextCompleted();\n            });\n        });\n        return function () {\n            var _a;\n            empty();\n            (_a = renderTask.current) === null || _a === void 0 ? void 0 : _a.cancel();\n        };\n    }, []);\n    return React__namespace.createElement(\"div\", { className: \"rpv-core__text-layer\", ref: containerRef });\n};\n\nvar PageLayer = function (_a) {\n    var doc = _a.doc, measureRef = _a.measureRef, outlines = _a.outlines, pageIndex = _a.pageIndex, pageRotation = _a.pageRotation, pageSize = _a.pageSize, plugins = _a.plugins, renderPage = _a.renderPage, renderQueueKey = _a.renderQueueKey, rotation = _a.rotation, scale = _a.scale, shouldRender = _a.shouldRender, viewMode = _a.viewMode, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation, onJumpToDest = _a.onJumpToDest, onRenderCompleted = _a.onRenderCompleted, onRotatePage = _a.onRotatePage;\n    var isMounted = useIsMounted();\n    var _b = React__namespace.useState(null), page = _b[0], setPage = _b[1];\n    var _c = React__namespace.useState(false), canvasLayerRendered = _c[0], setCanvasLayerRendered = _c[1];\n    var _d = React__namespace.useState(false), textLayerRendered = _d[0], setTextLayerRendered = _d[1];\n    var canvasLayerRef = React__namespace.useRef();\n    var textLayerRef = React__namespace.useRef();\n    var isVertical = Math.abs(rotation + pageRotation) % 180 === 0;\n    var scaledWidth = pageSize.pageWidth * scale;\n    var scaledHeight = pageSize.pageHeight * scale;\n    var w = isVertical ? scaledWidth : scaledHeight;\n    var h = isVertical ? scaledHeight : scaledWidth;\n    var rotationValue = (pageSize.rotation + rotation + pageRotation) % 360;\n    var renderQueueKeyRef = React__namespace.useRef(0);\n    var determinePageInstance = function () {\n        getPage(doc, pageIndex).then(function (pdfPage) {\n            if (isMounted.current) {\n                renderQueueKeyRef.current = renderQueueKey;\n                setPage(pdfPage);\n            }\n        });\n    };\n    var defaultPageRenderer = function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,\n        props.canvasLayer.children,\n        props.textLayer.children,\n        props.annotationLayer.children)); };\n    var renderPageLayer = renderPage || defaultPageRenderer;\n    var handleRenderCanvasCompleted = function () {\n        if (isMounted.current) {\n            setCanvasLayerRendered(true);\n        }\n    };\n    var handleRenderTextCompleted = function () {\n        if (isMounted.current) {\n            setTextLayerRendered(true);\n        }\n    };\n    React__namespace.useEffect(function () {\n        setPage(null);\n        setCanvasLayerRendered(false);\n        setTextLayerRendered(false);\n    }, [pageRotation, rotation, scale]);\n    React__namespace.useEffect(function () {\n        if (shouldRender && isMounted.current && !page) {\n            determinePageInstance();\n        }\n    }, [shouldRender, page]);\n    React__namespace.useEffect(function () {\n        if (canvasLayerRendered && textLayerRendered) {\n            if (renderQueueKey !== renderQueueKeyRef.current) {\n                setPage(null);\n                setCanvasLayerRendered(false);\n                setTextLayerRendered(false);\n            }\n            else {\n                onRenderCompleted(pageIndex);\n            }\n        }\n    }, [canvasLayerRendered, textLayerRendered]);\n    return (React__namespace.createElement(\"div\", { className: classNames({\n            'rpv-core__page-layer': true,\n            'rpv-core__page-layer--dual': viewMode === exports.ViewMode.DualPage,\n            'rpv-core__page-layer--dual-cover': viewMode === exports.ViewMode.DualPageWithCover,\n            'rpv-core__page-layer--single': viewMode === exports.ViewMode.SinglePage,\n        }), \"data-testid\": \"core__page-layer-\".concat(pageIndex), ref: measureRef, style: {\n            height: \"\".concat(h, \"px\"),\n            width: \"\".concat(w, \"px\"),\n        } }, !page ? (React__namespace.createElement(Spinner, { testId: \"core__page-layer-loading-\".concat(pageIndex) })) : (React__namespace.createElement(React__namespace.Fragment, null,\n        renderPageLayer({\n            annotationLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(AnnotationLayer, { doc: doc, outlines: outlines, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationValue, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpFromLinkAnnotation: onJumpFromLinkAnnotation, onJumpToDest: onJumpToDest })),\n            },\n            canvasLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(CanvasLayer, { canvasLayerRef: canvasLayerRef, height: h, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationValue, scale: scale, width: w, onRenderCanvasCompleted: handleRenderCanvasCompleted })),\n            },\n            canvasLayerRendered: canvasLayerRendered,\n            doc: doc,\n            height: h,\n            pageIndex: pageIndex,\n            rotation: rotationValue,\n            scale: scale,\n            svgLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(SvgLayer, { height: h, page: page, rotation: rotationValue, scale: scale, width: w })),\n            },\n            textLayer: {\n                attrs: {},\n                children: (React__namespace.createElement(TextLayer, { containerRef: textLayerRef, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationValue, scale: scale, onRenderTextCompleted: handleRenderTextCompleted })),\n            },\n            textLayerRendered: textLayerRendered,\n            width: w,\n            markRendered: onRenderCompleted,\n            onRotatePage: function (direction) { return onRotatePage(pageIndex, direction); },\n        }),\n        plugins.map(function (plugin, idx) {\n            return plugin.renderPageLayer ? (React__namespace.createElement(React__namespace.Fragment, { key: idx }, plugin.renderPageLayer({\n                canvasLayerRef: canvasLayerRef,\n                canvasLayerRendered: canvasLayerRendered,\n                doc: doc,\n                height: h,\n                pageIndex: pageIndex,\n                rotation: rotationValue,\n                scale: scale,\n                textLayerRef: textLayerRef,\n                textLayerRendered: textLayerRendered,\n                width: w,\n            }))) : (React__namespace.createElement(React__namespace.Fragment, { key: idx }));\n        })))));\n};\n\nvar getFileExt = function (url) {\n    var str = url.split(/\\./).pop();\n    return str ? str.toLowerCase() : '';\n};\n\nvar rectReducer = function (state, action) {\n    var rect = action.rect;\n    return state.height !== rect.height || state.width !== rect.width ? rect : state;\n};\nvar useMeasureRect = function (_a) {\n    var elementRef = _a.elementRef;\n    var _b = React__namespace.useState(elementRef.current), element = _b[0], setElement = _b[1];\n    var initializedRectRef = React__namespace.useRef(false);\n    var _c = React__namespace.useReducer(rectReducer, { height: 0, width: 0 }), rect = _c[0], dispatch = _c[1];\n    useIsomorphicLayoutEffect(function () {\n        if (elementRef.current !== element) {\n            setElement(elementRef.current);\n        }\n    });\n    useIsomorphicLayoutEffect(function () {\n        if (element && !initializedRectRef.current) {\n            initializedRectRef.current = true;\n            var _a = element.getBoundingClientRect(), height = _a.height, width = _a.width;\n            dispatch({\n                rect: { height: height, width: width },\n            });\n        }\n    }, [element]);\n    React__namespace.useEffect(function () {\n        if (!element) {\n            return;\n        }\n        var tracker = new ResizeObserver(function (entries, __) {\n            entries.forEach(function (entry) {\n                if (entry.target === element) {\n                    var _a = entry.contentRect, height = _a.height, width = _a.width;\n                    dispatch({\n                        rect: { height: height, width: width },\n                    });\n                }\n            });\n        });\n        tracker.observe(element);\n        return function () {\n            tracker.unobserve(element);\n        };\n    }, [element]);\n    return rect;\n};\n\nvar ScrollDirection;\n(function (ScrollDirection) {\n    ScrollDirection[\"Horizontal\"] = \"Horizontal\";\n    ScrollDirection[\"Vertical\"] = \"Vertical\";\n    ScrollDirection[\"Both\"] = \"Both\";\n})(ScrollDirection || (ScrollDirection = {}));\n\nvar easeOutQuart = function (t) { return 1 - Math.pow(1 - t, 4); };\n\nvar EPS = 0.0001;\nvar smoothScroll = function (ele, scrollDirection, targetPosition, duration, easing, onReachTarget) {\n    if (easing === void 0) { easing = function (t) { return t; }; }\n    if (onReachTarget === void 0) { onReachTarget = function () { }; }\n    var top = 0;\n    var left = 0;\n    var reachTarget = false;\n    switch (scrollDirection) {\n        case ScrollDirection.Horizontal:\n            left = ele.scrollLeft;\n            top = 0;\n        case ScrollDirection.Both:\n            left = ele.scrollLeft;\n            top = ele.scrollTop;\n            break;\n        case ScrollDirection.Vertical:\n        default:\n            left = 0;\n            top = ele.scrollTop;\n            break;\n    }\n    var markTargetReached = function () {\n        if (!reachTarget) {\n            reachTarget = true;\n            ele.scrollLeft = targetPosition.left;\n            ele.scrollTop = targetPosition.top;\n            onReachTarget();\n        }\n    };\n    if (Math.abs(top - targetPosition.top) <= EPS && scrollDirection === ScrollDirection.Vertical) {\n        markTargetReached();\n        return;\n    }\n    if (Math.abs(left - targetPosition.left) <= EPS && scrollDirection === ScrollDirection.Horizontal) {\n        markTargetReached();\n        return;\n    }\n    var startTime = -1;\n    var requestId;\n    var offset = {\n        left: left - targetPosition.left,\n        top: top - targetPosition.top,\n    };\n    var loop = function (currentTime) {\n        if (startTime === -1) {\n            startTime = currentTime;\n        }\n        var time = currentTime - startTime;\n        var percent = Math.min(time / duration, 1);\n        var easedPercent = easing(percent);\n        var updatePosition = {\n            left: left - offset.left * easedPercent,\n            top: top - offset.top * easedPercent,\n        };\n        switch (scrollDirection) {\n            case ScrollDirection.Horizontal:\n                ele.scrollLeft = updatePosition.left;\n                break;\n            case ScrollDirection.Both:\n                ele.scrollLeft = updatePosition.left;\n                ele.scrollTop = updatePosition.top;\n                break;\n            case ScrollDirection.Vertical:\n            default:\n                ele.scrollTop = updatePosition.top;\n                break;\n        }\n        if (Math.abs(updatePosition.top - targetPosition.top) <= EPS &&\n            Math.abs(updatePosition.left - targetPosition.left) <= EPS &&\n            !reachTarget) {\n            window.cancelAnimationFrame(requestId);\n            markTargetReached();\n        }\n        if (time < duration) {\n            requestId = window.requestAnimationFrame(loop);\n        }\n        else {\n            window.cancelAnimationFrame(requestId);\n        }\n    };\n    requestId = window.requestAnimationFrame(loop);\n};\n\nvar ZERO_OFFSET$6 = {\n    left: 0,\n    top: 0,\n};\nvar SCROLL_EVENT_OPTIONS = {\n    capture: false,\n    passive: true,\n};\nvar SCROLL_DURATION = 400;\nvar useScroll = function (_a) {\n    var elementRef = _a.elementRef, enableSmoothScroll = _a.enableSmoothScroll, isRtl = _a.isRtl, scrollDirection = _a.scrollDirection, onSmoothScroll = _a.onSmoothScroll;\n    var _b = React__namespace.useState(ZERO_OFFSET$6), scrollOffset = _b[0], setScrollOffset = _b[1];\n    var _c = React__namespace.useState(elementRef.current), element = _c[0], setElement = _c[1];\n    var factor = isRtl ? -1 : 1;\n    var latestRef = React__namespace.useRef(scrollDirection);\n    latestRef.current = scrollDirection;\n    var latestOffsetRef = React__namespace.useRef(ZERO_OFFSET$6);\n    var isSmoothScrollingDoneRef = React__namespace.useRef(true);\n    var handleSmoothScrollingComplete = React__namespace.useCallback(function () {\n        isSmoothScrollingDoneRef.current = true;\n        if (enableSmoothScroll) {\n            setScrollOffset(latestOffsetRef.current);\n        }\n        onSmoothScroll(false);\n    }, []);\n    var handleScroll = React__namespace.useCallback(function () {\n        if (!element) {\n            return;\n        }\n        switch (latestRef.current) {\n            case ScrollDirection.Horizontal:\n                latestOffsetRef.current = {\n                    left: factor * element.scrollLeft,\n                    top: 0,\n                };\n                break;\n            case ScrollDirection.Both:\n                latestOffsetRef.current = {\n                    left: factor * element.scrollLeft,\n                    top: element.scrollTop,\n                };\n                break;\n            case ScrollDirection.Vertical:\n            default:\n                latestOffsetRef.current = {\n                    left: 0,\n                    top: element.scrollTop,\n                };\n                break;\n        }\n        if (!enableSmoothScroll || isSmoothScrollingDoneRef.current) {\n            setScrollOffset(latestOffsetRef.current);\n        }\n    }, [element]);\n    useIsomorphicLayoutEffect(function () {\n        setElement(elementRef.current);\n    });\n    useIsomorphicLayoutEffect(function () {\n        if (!element) {\n            return;\n        }\n        element.addEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);\n        return function () {\n            element.removeEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);\n        };\n    }, [element]);\n    var scrollTo = React__namespace.useCallback(function (targetPosition, withSmoothScroll) {\n        var ele = elementRef.current;\n        if (!ele) {\n            return Promise.resolve();\n        }\n        var updatePosition = {\n            left: 0,\n            top: 0,\n        };\n        switch (latestRef.current) {\n            case ScrollDirection.Horizontal:\n                updatePosition.left = factor * targetPosition.left;\n                break;\n            case ScrollDirection.Both:\n                updatePosition.left = factor * targetPosition.left;\n                updatePosition.top = targetPosition.top;\n                break;\n            case ScrollDirection.Vertical:\n            default:\n                updatePosition.top = targetPosition.top;\n                break;\n        }\n        if (withSmoothScroll) {\n            isSmoothScrollingDoneRef.current = false;\n            onSmoothScroll(true);\n            return new Promise(function (resolve, _) {\n                smoothScroll(ele, latestRef.current, updatePosition, SCROLL_DURATION, easeOutQuart, function () {\n                    handleSmoothScrollingComplete();\n                    resolve();\n                });\n            });\n        }\n        return new Promise(function (resolve, _) {\n            switch (latestRef.current) {\n                case ScrollDirection.Horizontal:\n                    ele.scrollLeft = updatePosition.left;\n                    break;\n                case ScrollDirection.Both:\n                    ele.scrollLeft = updatePosition.left;\n                    ele.scrollTop = updatePosition.top;\n                    break;\n                case ScrollDirection.Vertical:\n                default:\n                    ele.scrollTop = updatePosition.top;\n                    break;\n            }\n            resolve();\n        });\n    }, [elementRef]);\n    return {\n        scrollOffset: scrollOffset,\n        scrollTo: scrollTo,\n    };\n};\n\nvar clamp = function (min, max, value) { return Math.max(min, Math.min(value, max)); };\n\nvar indexOfMax = function (arr) { return arr.reduce(function (prev, curr, i, a) { return (curr > a[prev] ? i : prev); }, 0); };\n\nvar buildContainerStyles = function (totalSize, scrollMode) {\n    switch (scrollMode) {\n        case exports.ScrollMode.Horizontal:\n            return {\n                position: 'relative',\n                height: '100%',\n                width: \"\".concat(totalSize.width, \"px\"),\n            };\n        case exports.ScrollMode.Vertical:\n        default:\n            return {\n                position: 'relative',\n                height: \"\".concat(totalSize.height, \"px\"),\n                width: '100%',\n            };\n    }\n};\n\nvar buildItemContainerStyles = function (item, parentRect, scrollMode) {\n    return scrollMode !== exports.ScrollMode.Page\n        ? {}\n        : {\n            height: \"\".concat(parentRect.height, \"px\"),\n            width: '100%',\n            position: 'absolute',\n            top: 0,\n            transform: \"translateY(\".concat(item.start.top, \"px)\"),\n        };\n};\n\nvar hasDifferentSizes = function (sizes) {\n    var numberOfItems = sizes.length;\n    if (numberOfItems === 1) {\n        return false;\n    }\n    for (var i = 1; i < numberOfItems; i++) {\n        if (sizes[i].height !== sizes[0].height || sizes[i].width !== sizes[0].width) {\n            return true;\n        }\n    }\n    return false;\n};\nvar getMinWidthOfCover = function (sizes, viewMode) {\n    if (viewMode !== exports.ViewMode.DualPageWithCover) {\n        return 0;\n    }\n    if (!hasDifferentSizes(sizes)) {\n        return 2 * sizes[0].width;\n    }\n    var chunkWidths = chunk(sizes.slice(1), 2).map(function (eachChunk) {\n        return eachChunk.length === 2 ? eachChunk[0].width + eachChunk[1].width : eachChunk[0].width;\n    });\n    var widths = [sizes[0].width].concat(chunkWidths);\n    return Math.max.apply(Math, widths);\n};\nvar buildItemStyles = function (item, isRtl, sizes, viewMode, scrollMode) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    var sideProperty = isRtl ? 'right' : 'left';\n    var factor = isRtl ? -1 : 1;\n    var numberOfItems = sizes.length;\n    var left = item.start.left * factor;\n    var _h = item.size, height = _h.height, width = _h.width;\n    if (viewMode === exports.ViewMode.DualPageWithCover) {\n        var transformTop = scrollMode === exports.ScrollMode.Page ? 0 : item.start.top;\n        if (item.index === 0 || (numberOfItems % 2 === 0 && item.index === numberOfItems - 1)) {\n            return _a = {\n                    height: \"\".concat(height, \"px\"),\n                    minWidth: \"\".concat(getMinWidthOfCover(sizes, viewMode), \"px\"),\n                    width: '100%'\n                },\n                _a[sideProperty] = 0,\n                _a.position = 'absolute',\n                _a.top = 0,\n                _a.transform = \"translate(\".concat(left, \"px, \").concat(transformTop, \"px)\"),\n                _a;\n        }\n        return _b = {\n                height: \"\".concat(height, \"px\"),\n                width: \"\".concat(width, \"px\")\n            },\n            _b[sideProperty] = 0,\n            _b.position = 'absolute',\n            _b.top = 0,\n            _b.transform = \"translate(\".concat(left, \"px, \").concat(transformTop, \"px)\"),\n            _b;\n    }\n    if (viewMode === exports.ViewMode.DualPage) {\n        return _c = {\n                height: \"\".concat(height, \"px\"),\n                width: \"\".concat(width, \"px\")\n            },\n            _c[sideProperty] = 0,\n            _c.position = 'absolute',\n            _c.top = 0,\n            _c.transform = \"translate(\".concat(left, \"px, \").concat(scrollMode === exports.ScrollMode.Page ? 0 : item.start.top, \"px)\"),\n            _c;\n    }\n    switch (scrollMode) {\n        case exports.ScrollMode.Horizontal:\n            return _d = {\n                    height: '100%',\n                    width: \"\".concat(width, \"px\")\n                },\n                _d[sideProperty] = 0,\n                _d.position = 'absolute',\n                _d.top = 0,\n                _d.transform = \"translateX(\".concat(left, \"px)\"),\n                _d;\n        case exports.ScrollMode.Page:\n            return _e = {\n                    height: \"\".concat(height, \"px\"),\n                    width: \"\".concat(width, \"px\")\n                },\n                _e[sideProperty] = 0,\n                _e.position = 'absolute',\n                _e.top = 0,\n                _e;\n        case exports.ScrollMode.Wrapped:\n            return _f = {\n                    height: \"\".concat(height, \"px\"),\n                    width: \"\".concat(width, \"px\")\n                },\n                _f[sideProperty] = 0,\n                _f.position = 'absolute',\n                _f.top = 0,\n                _f.transform = \"translate(\".concat(left, \"px, \").concat(item.start.top, \"px)\"),\n                _f;\n        case exports.ScrollMode.Vertical:\n        default:\n            return _g = {\n                    height: \"\".concat(height, \"px\"),\n                    width: '100%'\n                },\n                _g[sideProperty] = 0,\n                _g.position = 'absolute',\n                _g.top = 0,\n                _g.transform = \"translateY(\".concat(item.start.top, \"px)\"),\n                _g;\n    }\n};\n\nvar findNearest = function (low, high, value, getItemValue) {\n    while (low <= high) {\n        var middle = ((low + high) / 2) | 0;\n        var currentValue = getItemValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        }\n        else if (currentValue > value) {\n            high = middle - 1;\n        }\n        else {\n            return middle;\n        }\n    }\n    return low > 0 ? low - 1 : 0;\n};\n\nvar calculateRange = function (scrollDirection, measurements, outerSize, scrollOffset) {\n    var currentOffset = 0;\n    switch (scrollDirection) {\n        case ScrollDirection.Horizontal:\n            currentOffset = scrollOffset.left;\n            break;\n        case ScrollDirection.Vertical:\n        default:\n            currentOffset = scrollOffset.top;\n            break;\n    }\n    var size = measurements.length - 1;\n    var getOffset = function (index) {\n        switch (scrollDirection) {\n            case ScrollDirection.Horizontal:\n                return measurements[index].start.left;\n            case ScrollDirection.Both:\n            case ScrollDirection.Vertical:\n            default:\n                return measurements[index].start.top;\n        }\n    };\n    var start = findNearest(0, size, currentOffset, getOffset);\n    if (scrollDirection === ScrollDirection.Both) {\n        var startTop = measurements[start].start.top;\n        while (start - 1 >= 0 &&\n            measurements[start - 1].start.top === startTop &&\n            measurements[start - 1].start.left >= scrollOffset.left) {\n            start--;\n        }\n    }\n    var end = start;\n    while (end <= size) {\n        var topLeftCorner = {\n            top: measurements[end].start.top - scrollOffset.top,\n            left: measurements[end].start.left - scrollOffset.left,\n        };\n        var visibleSize = {\n            height: outerSize.height - topLeftCorner.top,\n            width: outerSize.width - topLeftCorner.left,\n        };\n        if (scrollDirection === ScrollDirection.Horizontal && visibleSize.width < 0) {\n            break;\n        }\n        if (scrollDirection === ScrollDirection.Vertical && visibleSize.height < 0) {\n            break;\n        }\n        if (scrollDirection === ScrollDirection.Both && (visibleSize.width < 0 || visibleSize.height < 0)) {\n            break;\n        }\n        end++;\n    }\n    return {\n        start: start,\n        end: end,\n    };\n};\n\nvar ZERO_OFFSET$5 = {\n    left: 0,\n    top: 0,\n};\nvar measure = function (numberOfItems, parentRect, sizes, scrollMode) {\n    var measurements = [];\n    var totalWidth = 0;\n    var firstOfRow = {\n        left: 0,\n        top: 0,\n    };\n    var maxHeight = 0;\n    var start = ZERO_OFFSET$5;\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = sizes[i];\n        if (i === 0) {\n            totalWidth = size.width;\n            firstOfRow = {\n                left: 0,\n                top: 0,\n            };\n            maxHeight = size.height;\n        }\n        else {\n            switch (scrollMode) {\n                case exports.ScrollMode.Wrapped:\n                    totalWidth += size.width;\n                    if (totalWidth < parentRect.width) {\n                        start = {\n                            left: measurements[i - 1].end.left,\n                            top: firstOfRow.top,\n                        };\n                        maxHeight = Math.max(maxHeight, size.height);\n                    }\n                    else {\n                        totalWidth = size.width;\n                        start = {\n                            left: firstOfRow.left,\n                            top: firstOfRow.top + maxHeight,\n                        };\n                        firstOfRow = {\n                            left: start.left,\n                            top: start.top,\n                        };\n                        maxHeight = size.height;\n                    }\n                    break;\n                case exports.ScrollMode.Horizontal:\n                case exports.ScrollMode.Vertical:\n                default:\n                    start = measurements[i - 1].end;\n                    break;\n            }\n        }\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_OFFSET$4 = {\n    left: 0,\n    top: 0,\n};\nvar measureDualPage = function (numberOfItems, parentRect, sizes, scrollMode) {\n    var measurements = [];\n    var top = 0;\n    var maxHeight = 0;\n    var start = ZERO_OFFSET$4;\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = {\n            height: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.height, sizes[i].height) : sizes[i].height,\n            width: Math.max(parentRect.width / 2, sizes[i].width),\n        };\n        if (scrollMode === exports.ScrollMode.Page) {\n            start = {\n                left: i % 2 === 0 ? 0 : size.width,\n                top: Math.floor(i / 2) * size.height,\n            };\n        }\n        else {\n            if (i % 2 === 0) {\n                top = top + maxHeight;\n                start = {\n                    left: 0,\n                    top: top,\n                };\n                maxHeight = i === numberOfItems - 1 ? sizes[i].height : Math.max(sizes[i].height, sizes[i + 1].height);\n            }\n            else {\n                start = {\n                    left: measurements[i - 1].end.left,\n                    top: top,\n                };\n            }\n        }\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_OFFSET$3 = {\n    left: 0,\n    top: 0,\n};\nvar measureDualPageWithCover = function (numberOfItems, parentRect, sizes, scrollMode) {\n    var measurements = [];\n    var top = 0;\n    var maxHeight = 0;\n    var start = ZERO_OFFSET$3;\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = i === 0\n            ? {\n                height: scrollMode === exports.ScrollMode.Page\n                    ? Math.max(parentRect.height, sizes[i].height)\n                    : sizes[i].height,\n                width: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.width, sizes[i].width) : sizes[i].width,\n            }\n            : {\n                height: scrollMode === exports.ScrollMode.Page\n                    ? Math.max(parentRect.height, sizes[i].height)\n                    : sizes[i].height,\n                width: Math.max(parentRect.width / 2, sizes[i].width),\n            };\n        if (scrollMode === exports.ScrollMode.Page) {\n            start =\n                i === 0\n                    ? ZERO_OFFSET$3\n                    : {\n                        left: i % 2 === 0 ? size.width : 0,\n                        top: Math.floor((i - 1) / 2) * size.height + measurements[0].end.top,\n                    };\n        }\n        else {\n            if (i === 0) {\n                start = ZERO_OFFSET$3;\n                top = sizes[0].height;\n                maxHeight = 0;\n            }\n            else if (i % 2 === 1) {\n                top = top + maxHeight;\n                start = {\n                    left: 0,\n                    top: top,\n                };\n                maxHeight = i === numberOfItems - 1 ? sizes[i].height : Math.max(sizes[i].height, sizes[i + 1].height);\n            }\n            else {\n                start = {\n                    left: measurements[i - 1].end.left,\n                    top: top,\n                };\n            }\n        }\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_OFFSET$2 = {\n    left: 0,\n    top: 0,\n};\nvar measureSinglePage = function (numberOfItems, parentRect, sizes) {\n    var measurements = [];\n    for (var i = 0; i < numberOfItems; i++) {\n        var size = {\n            height: Math.max(parentRect.height, sizes[i].height),\n            width: Math.max(parentRect.width, sizes[i].width),\n        };\n        var start = i === 0 ? ZERO_OFFSET$2 : measurements[i - 1].end;\n        var end = {\n            left: start.left + size.width,\n            top: start.top + size.height,\n        };\n        measurements[i] = {\n            index: i,\n            start: start,\n            size: size,\n            end: end,\n            visibility: -1,\n        };\n    }\n    return measurements;\n};\n\nvar ZERO_RECT$2 = {\n    height: 0,\n    width: 0,\n};\nvar ZERO_OFFSET$1 = {\n    left: 0,\n    top: 0,\n};\nvar COMPARE_EPSILON = 0.000000000001;\nvar VIRTUAL_INDEX_ATTR = 'data-virtual-index';\nvar IO_THRESHOLD = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\nvar useVirtual = function (_a) {\n    var enableSmoothScroll = _a.enableSmoothScroll, isRtl = _a.isRtl, numberOfItems = _a.numberOfItems, parentRef = _a.parentRef, setRenderRange = _a.setRenderRange, sizes = _a.sizes, scrollMode = _a.scrollMode, viewMode = _a.viewMode;\n    var _b = React__namespace.useState(false), isSmoothScrolling = _b[0], setSmoothScrolling = _b[1];\n    var onSmoothScroll = React__namespace.useCallback(function (isSmoothScrolling) { return setSmoothScrolling(isSmoothScrolling); }, []);\n    var scrollModeRef = React__namespace.useRef(scrollMode);\n    scrollModeRef.current = scrollMode;\n    var viewModeRef = React__namespace.useRef(viewMode);\n    viewModeRef.current = viewMode;\n    var scrollDirection = scrollMode === exports.ScrollMode.Wrapped || viewMode === exports.ViewMode.DualPageWithCover || viewMode === exports.ViewMode.DualPage\n        ? ScrollDirection.Both\n        : scrollMode === exports.ScrollMode.Horizontal\n            ? ScrollDirection.Horizontal\n            : ScrollDirection.Vertical;\n    var _c = useScroll({\n        elementRef: parentRef,\n        enableSmoothScroll: enableSmoothScroll,\n        isRtl: isRtl,\n        scrollDirection: scrollDirection,\n        onSmoothScroll: onSmoothScroll,\n    }), scrollOffset = _c.scrollOffset, scrollTo = _c.scrollTo;\n    var parentRect = useMeasureRect({\n        elementRef: parentRef,\n    });\n    var latestRef = React__namespace.useRef({\n        scrollOffset: ZERO_OFFSET$1,\n        measurements: [],\n    });\n    latestRef.current.scrollOffset = scrollOffset;\n    var defaultVisibilities = React__namespace.useMemo(function () { return Array(numberOfItems).fill(-1); }, []);\n    var _d = React__namespace.useState(defaultVisibilities), visibilities = _d[0], setVisibilities = _d[1];\n    var intersectionTracker = React__namespace.useMemo(function () {\n        var io = new IntersectionObserver(function (entries) {\n            entries.forEach(function (entry) {\n                var ratio = entry.isIntersecting ? entry.intersectionRatio : -1;\n                var target = entry.target;\n                var indexAttribute = target.getAttribute(VIRTUAL_INDEX_ATTR);\n                if (!indexAttribute) {\n                    return;\n                }\n                var index = parseInt(indexAttribute, 10);\n                if (0 <= index && index < numberOfItems) {\n                    setVisibilities(function (old) {\n                        old[index] = ratio;\n                        return __spreadArray([], old, true);\n                    });\n                }\n            });\n        }, {\n            threshold: IO_THRESHOLD,\n        });\n        return io;\n    }, []);\n    var measurements = React__namespace.useMemo(function () {\n        if (scrollMode === exports.ScrollMode.Page && viewMode === exports.ViewMode.SinglePage) {\n            return measureSinglePage(numberOfItems, parentRect, sizes);\n        }\n        if (viewMode === exports.ViewMode.DualPageWithCover) {\n            return measureDualPageWithCover(numberOfItems, parentRect, sizes, scrollMode);\n        }\n        if (viewMode === exports.ViewMode.DualPage) {\n            return measureDualPage(numberOfItems, parentRect, sizes, scrollMode);\n        }\n        return measure(numberOfItems, parentRect, sizes, scrollMode);\n    }, [scrollMode, sizes, viewMode, parentRect]);\n    var totalSize = measurements[numberOfItems - 1]\n        ? {\n            height: measurements[numberOfItems - 1].end.top,\n            width: measurements[numberOfItems - 1].end.left,\n        }\n        : ZERO_RECT$2;\n    latestRef.current.measurements = measurements;\n    var _e = React__namespace.useMemo(function () {\n        var _a = calculateRange(scrollDirection, measurements, parentRect, scrollOffset), start = _a.start, end = _a.end;\n        var visiblePageVisibilities = visibilities.slice(clamp(0, numberOfItems, start), clamp(0, numberOfItems, end));\n        var maxVisbilityItem = start + indexOfMax(visiblePageVisibilities);\n        maxVisbilityItem = clamp(0, numberOfItems - 1, maxVisbilityItem);\n        var maxVisbilityIndex = maxVisbilityItem;\n        var _b = setRenderRange({\n            endPage: end,\n            numPages: numberOfItems,\n            startPage: start,\n        }), startPage = _b.startPage, endPage = _b.endPage;\n        startPage = Math.max(startPage, 0);\n        endPage = Math.min(endPage, numberOfItems - 1);\n        switch (viewMode) {\n            case exports.ViewMode.DualPageWithCover:\n                if (maxVisbilityItem > 0) {\n                    maxVisbilityIndex = maxVisbilityItem % 2 === 1 ? maxVisbilityItem : maxVisbilityItem - 1;\n                }\n                startPage = startPage === 0 ? 0 : startPage % 2 === 1 ? startPage : startPage - 1;\n                endPage = endPage % 2 === 1 ? endPage - 1 : endPage;\n                if (numberOfItems - endPage <= 2) {\n                    endPage = numberOfItems - 1;\n                }\n                break;\n            case exports.ViewMode.DualPage:\n                maxVisbilityIndex = maxVisbilityItem % 2 === 0 ? maxVisbilityItem : maxVisbilityItem - 1;\n                startPage = startPage % 2 === 0 ? startPage : startPage - 1;\n                endPage = endPage % 2 === 1 ? endPage : endPage - 1;\n                break;\n            case exports.ViewMode.SinglePage:\n            default:\n                maxVisbilityIndex = maxVisbilityItem;\n                break;\n        }\n        return {\n            startPage: startPage,\n            endPage: endPage,\n            maxVisbilityIndex: maxVisbilityIndex,\n        };\n    }, [measurements, parentRect, scrollOffset, viewMode, visibilities]), startPage = _e.startPage, endPage = _e.endPage, maxVisbilityIndex = _e.maxVisbilityIndex;\n    var virtualItems = React__namespace.useMemo(function () {\n        var virtualItems = [];\n        var _loop_1 = function (i) {\n            var item = measurements[i];\n            var virtualItem = __assign(__assign({}, item), { visibility: visibilities[i] !== undefined ? visibilities[i] : -1, measureRef: function (ele) {\n                    if (!ele) {\n                        return;\n                    }\n                    ele.setAttribute(VIRTUAL_INDEX_ATTR, \"\".concat(i));\n                    intersectionTracker.observe(ele);\n                } });\n            virtualItems.push(virtualItem);\n        };\n        for (var i = startPage; i <= endPage; i++) {\n            _loop_1(i);\n        }\n        return virtualItems;\n    }, [startPage, endPage, visibilities, measurements]);\n    var scrollToItem = React__namespace.useCallback(function (index, offset) {\n        var measurements = latestRef.current.measurements;\n        var normalizedIndex = clamp(0, numberOfItems - 1, index);\n        var measurement = measurements[normalizedIndex];\n        var withOffset = scrollModeRef.current === exports.ScrollMode.Page ? ZERO_OFFSET$1 : offset;\n        return measurement\n            ? scrollTo({\n                left: withOffset.left + measurement.start.left,\n                top: withOffset.top + measurement.start.top,\n            }, enableSmoothScroll)\n            : Promise.resolve();\n    }, [scrollTo, enableSmoothScroll]);\n    var scrollToSmallestItemAbove = React__namespace.useCallback(function (index, offset) {\n        var measurements = latestRef.current.measurements;\n        var start = measurements[index].start;\n        var nextItem = measurements.find(function (item) { return item.start.top - start.top > COMPARE_EPSILON; });\n        if (!nextItem) {\n            return Promise.resolve();\n        }\n        var nextIndex = nextItem.index;\n        switch (viewModeRef.current) {\n            case exports.ViewMode.DualPage:\n                nextIndex = nextIndex % 2 === 0 ? nextIndex : nextIndex + 1;\n                break;\n            case exports.ViewMode.DualPageWithCover:\n                nextIndex = nextIndex % 2 === 1 ? nextIndex : nextIndex + 1;\n                break;\n        }\n        return scrollToItem(nextIndex, offset);\n    }, []);\n    var scrollToBiggestItemBelow = React__namespace.useCallback(function (index, offset) {\n        var measurements = latestRef.current.measurements;\n        var start = measurements[index].start;\n        var prevIndex = index;\n        var found = false;\n        for (var i = numberOfItems - 1; i >= 0; i--) {\n            if (start.top - measurements[i].start.top > COMPARE_EPSILON) {\n                found = true;\n                prevIndex = measurements[i].index;\n                break;\n            }\n        }\n        if (!found) {\n            return Promise.resolve();\n        }\n        switch (viewModeRef.current) {\n            case exports.ViewMode.DualPage:\n                prevIndex = prevIndex % 2 === 0 ? prevIndex : prevIndex - 1;\n                break;\n            case exports.ViewMode.DualPageWithCover:\n                prevIndex = prevIndex % 2 === 0 ? prevIndex - 1 : prevIndex;\n                break;\n        }\n        if (prevIndex === index) {\n            prevIndex = index - 1;\n        }\n        return scrollToItem(prevIndex, offset);\n    }, []);\n    var scrollToNextItem = React__namespace.useCallback(function (index, offset) {\n        if (viewModeRef.current === exports.ViewMode.DualPageWithCover || viewModeRef.current === exports.ViewMode.DualPage) {\n            return scrollToSmallestItemAbove(index, offset);\n        }\n        switch (scrollModeRef.current) {\n            case exports.ScrollMode.Wrapped:\n                return scrollToSmallestItemAbove(index, offset);\n            case exports.ScrollMode.Horizontal:\n            case exports.ScrollMode.Vertical:\n            default:\n                return scrollToItem(index + 1, offset);\n        }\n    }, []);\n    var scrollToPreviousItem = React__namespace.useCallback(function (index, offset) {\n        if (viewModeRef.current === exports.ViewMode.DualPageWithCover || viewModeRef.current === exports.ViewMode.DualPage) {\n            return scrollToBiggestItemBelow(index, offset);\n        }\n        switch (scrollModeRef.current) {\n            case exports.ScrollMode.Wrapped:\n                return scrollToBiggestItemBelow(index, offset);\n            case exports.ScrollMode.Horizontal:\n            case exports.ScrollMode.Vertical:\n            default:\n                return scrollToItem(index - 1, offset);\n        }\n    }, []);\n    var getContainerStyles = React__namespace.useCallback(function () { return buildContainerStyles(totalSize, scrollModeRef.current); }, [totalSize]);\n    var getItemContainerStyles = React__namespace.useCallback(function (item) { return buildItemContainerStyles(item, parentRect, scrollModeRef.current); }, [parentRect]);\n    var getItemStyles = React__namespace.useCallback(function (item) { return buildItemStyles(item, isRtl, sizes, viewModeRef.current, scrollModeRef.current); }, [isRtl, sizes]);\n    var zoom = React__namespace.useCallback(function (scale, index) {\n        var _a = latestRef.current, measurements = _a.measurements, scrollOffset = _a.scrollOffset;\n        var normalizedIndex = clamp(0, numberOfItems - 1, index);\n        var measurement = measurements[normalizedIndex];\n        if (measurement) {\n            var updateOffset = scrollModeRef.current === exports.ScrollMode.Page\n                ? {\n                    left: measurement.start.left,\n                    top: measurement.start.top,\n                }\n                : {\n                    left: scrollOffset.left * scale,\n                    top: scrollOffset.top * scale,\n                };\n            return scrollTo(updateOffset, false);\n        }\n        return Promise.resolve();\n    }, []);\n    React__namespace.useEffect(function () {\n        return function () {\n            intersectionTracker.disconnect();\n        };\n    }, []);\n    return {\n        boundingClientRect: parentRect,\n        isSmoothScrolling: isSmoothScrolling,\n        startPage: startPage,\n        endPage: endPage,\n        maxVisbilityIndex: maxVisbilityIndex,\n        virtualItems: virtualItems,\n        getContainerStyles: getContainerStyles,\n        getItemContainerStyles: getItemContainerStyles,\n        getItemStyles: getItemStyles,\n        scrollToItem: scrollToItem,\n        scrollToNextItem: scrollToNextItem,\n        scrollToPreviousItem: scrollToPreviousItem,\n        zoom: zoom,\n    };\n};\n\nvar SCROLL_BAR_WIDTH = 17;\nvar PAGE_PADDING = 8;\nvar calculateScale = function (container, pageHeight, pageWidth, scale, viewMode, numPages) {\n    var w = pageWidth;\n    switch (true) {\n        case viewMode === exports.ViewMode.DualPageWithCover && numPages >= 3:\n        case viewMode === exports.ViewMode.DualPage && numPages >= 3:\n            w = 2 * pageWidth;\n            break;\n        default:\n            w = pageWidth;\n            break;\n    }\n    switch (scale) {\n        case exports.SpecialZoomLevel.ActualSize:\n            return 1;\n        case exports.SpecialZoomLevel.PageFit:\n            return Math.min((container.clientWidth - SCROLL_BAR_WIDTH) / w, (container.clientHeight - 2 * PAGE_PADDING) / pageHeight);\n        case exports.SpecialZoomLevel.PageWidth:\n            return (container.clientWidth - SCROLL_BAR_WIDTH) / w;\n    }\n};\n\nvar useStack = function (maxLength) {\n    var stackRef = React__namespace.useRef([]);\n    var map = function (transformer) {\n        return stackRef.current.map(function (item) { return transformer(item); });\n    };\n    var pop = function () {\n        var stack = stackRef.current;\n        var size = stack.length;\n        if (size === 0) {\n            return null;\n        }\n        var lastItem = stack.pop();\n        stackRef.current = stack;\n        return lastItem;\n    };\n    var push = function (item) {\n        var stack = stackRef.current;\n        if (stack.length + 1 > maxLength) {\n            stack.shift();\n        }\n        stack.push(item);\n        stackRef.current = stack;\n    };\n    React__namespace.useEffect(function () {\n        return function () {\n            stackRef.current = [];\n        };\n    }, []);\n    return {\n        push: push,\n        map: map,\n        pop: pop,\n    };\n};\n\nvar useQueue = function (maxLength) {\n    var queueRef = React__namespace.useRef([]);\n    var dequeue = function () {\n        var queue = queueRef.current;\n        var size = queue.length;\n        if (size === 0) {\n            return null;\n        }\n        var firstItem = queue.shift();\n        queueRef.current = queue;\n        return firstItem || null;\n    };\n    var enqueue = function (item) {\n        var queue = queueRef.current;\n        if (queue.length + 1 > maxLength) {\n            queue.pop();\n        }\n        queueRef.current = [item].concat(queue);\n    };\n    var map = function (transformer) {\n        return queueRef.current.map(function (item) { return transformer(item); });\n    };\n    React__namespace.useEffect(function () {\n        return function () {\n            queueRef.current = [];\n        };\n    }, []);\n    return {\n        dequeue: dequeue,\n        enqueue: enqueue,\n        map: map,\n    };\n};\n\nvar MAX_QUEUE_LENGTH = 50;\nvar useDestination = function (_a) {\n    var getCurrentPage = _a.getCurrentPage;\n    var previousDestinations = useStack(MAX_QUEUE_LENGTH);\n    var nextDestinations = useQueue(MAX_QUEUE_LENGTH);\n    var getNextDestination = function () {\n        var nextDest = nextDestinations.dequeue();\n        if (nextDest) {\n            previousDestinations.push(nextDest);\n        }\n        if (nextDest && nextDest.pageIndex === getCurrentPage()) {\n            return getNextDestination();\n        }\n        return nextDest;\n    };\n    var getPreviousDestination = function () {\n        var prevDest = previousDestinations.pop();\n        if (prevDest) {\n            nextDestinations.enqueue(prevDest);\n        }\n        if (prevDest && prevDest.pageIndex === getCurrentPage()) {\n            return getPreviousDestination();\n        }\n        return prevDest;\n    };\n    var markVisitedDestination = React__namespace.useCallback(function (destination) {\n        previousDestinations.push(destination);\n    }, []);\n    return {\n        getNextDestination: getNextDestination,\n        getPreviousDestination: getPreviousDestination,\n        markVisitedDestination: markVisitedDestination,\n    };\n};\n\nvar flaternSingleOutline = function (outline) {\n    var result = [];\n    if (outline.items && outline.items.length > 0) {\n        result = result.concat(flaternOutlines(outline.items));\n    }\n    return result;\n};\nvar flaternOutlines = function (outlines) {\n    var result = [];\n    outlines.map(function (outline) {\n        result = result.concat(outline).concat(flaternSingleOutline(outline));\n    });\n    return result;\n};\nvar useOutlines = function (doc) {\n    var isMounted = useIsMounted();\n    var _a = React__namespace.useState([]), outlines = _a[0], setOutlines = _a[1];\n    React__namespace.useEffect(function () {\n        doc.getOutline().then(function (result) {\n            if (isMounted.current && result !== null) {\n                var items = flaternOutlines(result);\n                setOutlines(items);\n            }\n        });\n    }, []);\n    return outlines;\n};\n\nvar RESIZE_EVENT_OPTIONS = {\n    capture: false,\n    passive: true,\n};\nvar ZERO_RECT$1 = {\n    height: 0,\n    width: 0,\n};\nvar useWindowResize = function () {\n    var _a = React__namespace.useState(ZERO_RECT$1), windowRect = _a[0], setWindowRect = _a[1];\n    var handleResize = useDebounceCallback(function () {\n        setWindowRect({\n            height: window.innerHeight,\n            width: window.innerWidth,\n        });\n    }, 100);\n    useIsomorphicLayoutEffect(function () {\n        window.addEventListener('resize', handleResize, RESIZE_EVENT_OPTIONS);\n        return function () {\n            window.removeEventListener('resize', handleResize, RESIZE_EVENT_OPTIONS);\n        };\n    }, []);\n    return windowRect;\n};\n\nvar ZERO_RECT = {\n    height: 0,\n    width: 0,\n};\nvar useFullScreen = function (_a) {\n    var getCurrentPage = _a.getCurrentPage, getCurrentScrollMode = _a.getCurrentScrollMode, jumpToPage = _a.jumpToPage, targetRef = _a.targetRef;\n    var _b = React__namespace.useState(exports.FullScreenMode.Normal), fullScreenMode = _b[0], setFullScreenMode = _b[1];\n    var windowRect = useWindowResize();\n    var _c = React__namespace.useState(ZERO_RECT), targetRect = _c[0], setTargetRect = _c[1];\n    var windowSizeBeforeFullScreenRef = React__namespace.useRef(ZERO_RECT);\n    var targetPageRef = React__namespace.useRef(getCurrentPage());\n    var fullScreenSizeRef = React__namespace.useRef(ZERO_RECT);\n    var _d = React__namespace.useState(targetRef.current), element = _d[0], setElement = _d[1];\n    var fullScreenElementRef = React__namespace.useRef();\n    useIsomorphicLayoutEffect(function () {\n        if (targetRef.current !== element) {\n            setElement(targetRef.current);\n        }\n    }, []);\n    useIsomorphicLayoutEffect(function () {\n        if (!element) {\n            return;\n        }\n        var io = new ResizeObserver(function (entries) {\n            entries.forEach(function (entry) {\n                var _a = entry.target.getBoundingClientRect(), height = _a.height, width = _a.width;\n                setTargetRect({ height: height, width: width });\n            });\n        });\n        io.observe(element);\n        return function () {\n            io.unobserve(element);\n            io.disconnect();\n        };\n    }, [element]);\n    var closeOtherFullScreen = React__namespace.useCallback(function (target) {\n        var currentFullScreenEle = getFullScreenElement();\n        if (currentFullScreenEle && currentFullScreenEle !== target) {\n            setFullScreenMode(exports.FullScreenMode.Normal);\n            return exitFullScreen(currentFullScreenEle);\n        }\n        return Promise.resolve();\n    }, []);\n    var enterFullScreenMode = React__namespace.useCallback(function (target) {\n        if (!target || !isFullScreenEnabled()) {\n            return;\n        }\n        setElement(target);\n        closeOtherFullScreen(target).then(function () {\n            fullScreenElementRef.current = target;\n            setFullScreenMode(exports.FullScreenMode.Entering);\n            requestFullScreen(target);\n        });\n    }, []);\n    var exitFullScreenMode = React__namespace.useCallback(function () {\n        var currentFullScreenEle = getFullScreenElement();\n        if (currentFullScreenEle) {\n            setFullScreenMode(exports.FullScreenMode.Exitting);\n            exitFullScreen(document);\n        }\n    }, []);\n    var handleFullScreenChange = React__namespace.useCallback(function () {\n        if (!element) {\n            return;\n        }\n        var currentFullScreenEle = getFullScreenElement();\n        if (currentFullScreenEle !== element) {\n            setFullScreenMode(exports.FullScreenMode.Exitting);\n        }\n    }, [element]);\n    React__namespace.useEffect(function () {\n        switch (fullScreenMode) {\n            case exports.FullScreenMode.Entering:\n                if (fullScreenElementRef.current) {\n                    fullScreenElementRef.current.style.backgroundColor =\n                        'var(--rpv-core__full-screen-target-background-color)';\n                }\n                targetPageRef.current = getCurrentPage();\n                windowSizeBeforeFullScreenRef.current = {\n                    height: window.innerHeight,\n                    width: window.innerWidth,\n                };\n                break;\n            case exports.FullScreenMode.Entered:\n                if (getCurrentScrollMode() === exports.ScrollMode.Page) {\n                    jumpToPage(targetPageRef.current).then(function () {\n                        setFullScreenMode(exports.FullScreenMode.EnteredCompletely);\n                    });\n                }\n                else {\n                    setFullScreenMode(exports.FullScreenMode.EnteredCompletely);\n                }\n                break;\n            case exports.FullScreenMode.Exitting:\n                if (fullScreenElementRef.current) {\n                    fullScreenElementRef.current.style.backgroundColor = '';\n                    fullScreenElementRef.current = null;\n                }\n                targetPageRef.current = getCurrentPage();\n                break;\n            case exports.FullScreenMode.Exited:\n                setFullScreenMode(exports.FullScreenMode.Normal);\n                if (getCurrentScrollMode() === exports.ScrollMode.Page) {\n                    jumpToPage(targetPageRef.current);\n                }\n                break;\n        }\n    }, [fullScreenMode]);\n    React__namespace.useEffect(function () {\n        if (fullScreenMode === exports.FullScreenMode.Normal) {\n            return;\n        }\n        if (fullScreenMode === exports.FullScreenMode.Entering &&\n            windowRect.height === targetRect.height &&\n            windowRect.width === targetRect.width &&\n            windowRect.height > 0 &&\n            windowRect.width > 0 &&\n            (fullScreenSizeRef.current.height === 0 || windowRect.height == fullScreenSizeRef.current.height)) {\n            fullScreenSizeRef.current = {\n                height: window.innerHeight,\n                width: window.innerWidth,\n            };\n            setFullScreenMode(exports.FullScreenMode.Entered);\n            return;\n        }\n        if (fullScreenMode === exports.FullScreenMode.Exitting &&\n            windowSizeBeforeFullScreenRef.current.height === windowRect.height &&\n            windowSizeBeforeFullScreenRef.current.width === windowRect.width &&\n            windowRect.height > 0 &&\n            windowRect.width > 0) {\n            setFullScreenMode(exports.FullScreenMode.Exited);\n        }\n    }, [fullScreenMode, windowRect, targetRect]);\n    React__namespace.useEffect(function () {\n        addFullScreenChangeListener(handleFullScreenChange);\n        return function () {\n            removeFullScreenChangeListener(handleFullScreenChange);\n        };\n    }, [element]);\n    return {\n        enterFullScreenMode: enterFullScreenMode,\n        exitFullScreenMode: exitFullScreenMode,\n        fullScreenMode: fullScreenMode,\n    };\n};\n\nvar DEFAULT_PAGE_LAYOUT = {\n    buildPageStyles: function () { return ({}); },\n    transformSize: function (_a) {\n        var size = _a.size;\n        return size;\n    },\n};\nvar ZERO_OFFSET = {\n    left: 0,\n    top: 0,\n};\nvar Inner = function (_a) {\n    var currentFile = _a.currentFile, defaultScale = _a.defaultScale, doc = _a.doc, enableSmoothScroll = _a.enableSmoothScroll, initialPage = _a.initialPage, initialRotation = _a.initialRotation, initialScale = _a.initialScale, pageLayout = _a.pageLayout, pageSizes = _a.pageSizes, plugins = _a.plugins, renderPage = _a.renderPage, scrollMode = _a.scrollMode, setRenderRange = _a.setRenderRange, viewMode = _a.viewMode, viewerState = _a.viewerState, onDocumentLoad = _a.onDocumentLoad, onOpenFile = _a.onOpenFile, onPageChange = _a.onPageChange, onRotate = _a.onRotate, onRotatePage = _a.onRotatePage, onZoom = _a.onZoom;\n    var numPages = doc.numPages;\n    var docId = doc.loadingTask.docId;\n    var l10n = React__namespace.useContext(LocalizationContext).l10n;\n    var themeContext = React__namespace.useContext(ThemeContext);\n    var isRtl = themeContext.direction === exports.TextDirection.RightToLeft;\n    var containerRef = React__namespace.useRef();\n    var pagesRef = React__namespace.useRef();\n    var _b = React__namespace.useState(initialPage), currentPage = _b[0], setCurrentPage = _b[1];\n    var mostRecentVisitedRef = React__namespace.useRef(null);\n    var destinationManager = useDestination({\n        getCurrentPage: function () { return stateRef.current.pageIndex; },\n    });\n    var _c = React__namespace.useState(initialRotation), rotation = _c[0], setRotation = _c[1];\n    var previousRotation = usePrevious(rotation);\n    var _d = React__namespace.useState(false), pagesRotationChanged = _d[0], setPagesRotationChanged = _d[1];\n    var _e = React__namespace.useState(new Map()), pagesRotation = _e[0], setPagesRotation = _e[1];\n    var _f = React__namespace.useState(scrollMode), currentScrollMode = _f[0], setCurrentScrollMode = _f[1];\n    var previousScrollMode = usePrevious(currentScrollMode);\n    var _g = React__namespace.useState(viewMode), currentViewMode = _g[0], setCurrentViewMode = _g[1];\n    var previousViewMode = usePrevious(currentViewMode);\n    var outlines = useOutlines(doc);\n    var _h = React__namespace.useState(initialScale), scale = _h[0], setScale = _h[1];\n    var previousScale = usePrevious(scale);\n    var stateRef = React__namespace.useRef(viewerState);\n    var keepSpecialZoomLevelRef = React__namespace.useRef(typeof defaultScale === 'string' ? defaultScale : null);\n    var forceTargetFullScreenRef = React__namespace.useRef(-1);\n    var forceTargetZoomRef = React__namespace.useRef(-1);\n    var forceTargetInitialPageRef = React__namespace.useRef(initialPage);\n    var fullScreen = useFullScreen({\n        getCurrentPage: function () { return stateRef.current.pageIndex; },\n        getCurrentScrollMode: function () { return stateRef.current.scrollMode; },\n        jumpToPage: function (pageIndex) { return jumpToPage(pageIndex); },\n        targetRef: pagesRef,\n    });\n    var _j = React__namespace.useState(-1), renderPageIndex = _j[0], setRenderPageIndex = _j[1];\n    var _k = React__namespace.useState(0), renderQueueKey = _k[0], setRenderQueueKey = _k[1];\n    var renderQueue = useRenderQueue({ doc: doc });\n    React__namespace.useEffect(function () {\n        return function () {\n            clearPagesCache();\n        };\n    }, [docId]);\n    var layoutBuilder = React__namespace.useMemo(function () { return Object.assign({}, DEFAULT_PAGE_LAYOUT, pageLayout); }, []);\n    var sizes = React__namespace.useMemo(function () {\n        return Array(numPages)\n            .fill(0)\n            .map(function (_, pageIndex) {\n            var pageSize = [pageSizes[pageIndex].pageHeight, pageSizes[pageIndex].pageWidth];\n            var rect = Math.abs(rotation) % 180 === 0\n                ? {\n                    height: pageSize[0],\n                    width: pageSize[1],\n                }\n                : {\n                    height: pageSize[1],\n                    width: pageSize[0],\n                };\n            var pageRect = {\n                height: rect.height * scale,\n                width: rect.width * scale,\n            };\n            return layoutBuilder.transformSize({ numPages: numPages, pageIndex: pageIndex, size: pageRect });\n        });\n    }, [rotation, scale]);\n    var virtualizer = useVirtual({\n        enableSmoothScroll: enableSmoothScroll,\n        isRtl: isRtl,\n        numberOfItems: numPages,\n        parentRef: pagesRef,\n        scrollMode: currentScrollMode,\n        setRenderRange: setRenderRange,\n        sizes: sizes,\n        viewMode: currentViewMode,\n    });\n    var handlePagesResize = useDebounceCallback(function () {\n        if (!keepSpecialZoomLevelRef.current ||\n            stateRef.current.fullScreenMode !== exports.FullScreenMode.Normal ||\n            (initialPage > 0 && forceTargetInitialPageRef.current === initialPage)) {\n            return;\n        }\n        zoom(keepSpecialZoomLevelRef.current);\n    }, 200);\n    useTrackResize({\n        targetRef: pagesRef,\n        onResize: handlePagesResize,\n    });\n    var setViewerState = function (viewerState) {\n        var newState = viewerState;\n        plugins.forEach(function (plugin) {\n            if (plugin.onViewerStateChange) {\n                newState = plugin.onViewerStateChange(newState);\n            }\n        });\n        stateRef.current = newState;\n    };\n    var getPagesContainer = function () { return pagesRef.current; };\n    var getViewerState = function () { return stateRef.current; };\n    var handleJumpFromLinkAnnotation = React__namespace.useCallback(function (destination) {\n        destinationManager.markVisitedDestination(destination);\n    }, []);\n    var handleJumpToDestination = React__namespace.useCallback(function (destination) {\n        var pageIndex = destination.pageIndex, bottomOffset = destination.bottomOffset, leftOffset = destination.leftOffset, scaleTo = destination.scaleTo;\n        var pagesContainer = pagesRef.current;\n        var currentState = stateRef.current;\n        if (!pagesContainer || !currentState) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, _) {\n            getPage(doc, pageIndex).then(function (page) {\n                var viewport = page.getViewport({ scale: 1 });\n                var top = 0;\n                var bottom = (typeof bottomOffset === 'function'\n                    ? bottomOffset(viewport.width, viewport.height)\n                    : bottomOffset) || 0;\n                var left = (typeof leftOffset === 'function' ? leftOffset(viewport.width, viewport.height) : leftOffset) || 0;\n                var updateScale = currentState.scale;\n                switch (scaleTo) {\n                    case exports.SpecialZoomLevel.PageFit:\n                        top = 0;\n                        left = 0;\n                        zoom(exports.SpecialZoomLevel.PageFit);\n                        break;\n                    case exports.SpecialZoomLevel.PageWidth:\n                        updateScale = calculateScale(pagesContainer, pageSizes[pageIndex].pageHeight, pageSizes[pageIndex].pageWidth, exports.SpecialZoomLevel.PageWidth, viewMode, numPages);\n                        top = (viewport.height - bottom) * updateScale;\n                        left = left * updateScale;\n                        zoom(updateScale);\n                        break;\n                    default:\n                        top = (viewport.height - bottom) * updateScale;\n                        left = left * updateScale;\n                        break;\n                }\n                switch (currentState.scrollMode) {\n                    case exports.ScrollMode.Horizontal:\n                        virtualizer.scrollToItem(pageIndex, { left: left, top: 0 }).then(function () {\n                            resolve();\n                        });\n                        break;\n                    case exports.ScrollMode.Vertical:\n                    default:\n                        virtualizer.scrollToItem(pageIndex, { left: 0, top: top }).then(function () {\n                            resolve();\n                        });\n                        break;\n                }\n            });\n        });\n    }, []);\n    var jumpToDestination = React__namespace.useCallback(function (destination) {\n        destinationManager.markVisitedDestination(destination);\n        return handleJumpToDestination(destination);\n    }, []);\n    var jumpToNextDestination = React__namespace.useCallback(function () {\n        var nextDestination = destinationManager.getNextDestination();\n        return nextDestination ? handleJumpToDestination(nextDestination) : Promise.resolve();\n    }, []);\n    var jumpToPreviousDestination = React__namespace.useCallback(function () {\n        var lastDestination = destinationManager.getPreviousDestination();\n        return lastDestination ? handleJumpToDestination(lastDestination) : Promise.resolve();\n    }, []);\n    var jumpToNextPage = React__namespace.useCallback(function () { return virtualizer.scrollToNextItem(stateRef.current.pageIndex, ZERO_OFFSET); }, []);\n    var jumpToPage = React__namespace.useCallback(function (pageIndex) {\n        return 0 <= pageIndex && pageIndex < numPages\n            ? virtualizer.scrollToItem(pageIndex, ZERO_OFFSET)\n            : Promise.resolve();\n    }, []);\n    var jumpToPreviousPage = React__namespace.useCallback(function () { return virtualizer.scrollToPreviousItem(stateRef.current.pageIndex, ZERO_OFFSET); }, []);\n    var openFile = React__namespace.useCallback(function (file) {\n        if (getFileExt(file.name).toLowerCase() !== 'pdf') {\n            return;\n        }\n        new Promise(function (resolve) {\n            var reader = new FileReader();\n            reader.readAsArrayBuffer(file);\n            reader.onload = function () {\n                var bytes = new Uint8Array(reader.result);\n                resolve(bytes);\n            };\n        }).then(function (data) {\n            onOpenFile(file.name, data);\n        });\n    }, [onOpenFile]);\n    var rotate = React__namespace.useCallback(function (direction) {\n        var degrees = direction === exports.RotateDirection.Backward ? -90 : 90;\n        var currentRotation = stateRef.current.rotation;\n        var updateRotation = currentRotation === 360 || currentRotation === -360 ? degrees : currentRotation + degrees;\n        renderQueue.markNotRendered();\n        setRotation(updateRotation);\n        setViewerState(__assign(__assign({}, stateRef.current), { rotation: updateRotation }));\n        onRotate({ direction: direction, doc: doc, rotation: updateRotation });\n    }, []);\n    var rotatePage = React__namespace.useCallback(function (pageIndex, direction) {\n        var degrees = direction === exports.RotateDirection.Backward ? -90 : 90;\n        var rotations = stateRef.current.pagesRotation;\n        var currentPageRotation = rotations.has(pageIndex) ? rotations.get(pageIndex) : initialRotation;\n        var finalRotation = currentPageRotation + degrees;\n        var updateRotations = rotations.set(pageIndex, finalRotation);\n        setPagesRotation(updateRotations);\n        setPagesRotationChanged(function (value) { return !value; });\n        setViewerState(__assign(__assign({}, stateRef.current), { pagesRotation: updateRotations, rotatedPage: pageIndex }));\n        onRotatePage({ direction: direction, doc: doc, pageIndex: pageIndex, rotation: finalRotation });\n        renderQueue.markRendering(pageIndex);\n        setRenderPageIndex(pageIndex);\n    }, []);\n    var switchScrollMode = React__namespace.useCallback(function (scrollMode) {\n        setViewerState(__assign(__assign({}, stateRef.current), { scrollMode: scrollMode }));\n        setCurrentScrollMode(scrollMode);\n    }, []);\n    var switchViewMode = React__namespace.useCallback(function (viewMode) {\n        setViewerState(__assign(__assign({}, stateRef.current), { viewMode: viewMode }));\n        setCurrentViewMode(viewMode);\n    }, []);\n    var zoom = React__namespace.useCallback(function (newScale) {\n        var pagesEle = pagesRef.current;\n        var currentPage = stateRef.current.pageIndex;\n        if (currentPage < 0 || currentPage >= numPages) {\n            return;\n        }\n        var currentPageHeight = pageSizes[currentPage].pageHeight;\n        var currentPageWidth = pageSizes[currentPage].pageWidth;\n        var updateScale = pagesEle\n            ? typeof newScale === 'string'\n                ? calculateScale(pagesEle, currentPageHeight, currentPageWidth, newScale, stateRef.current.viewMode, numPages)\n                : newScale\n            : 1;\n        keepSpecialZoomLevelRef.current = typeof newScale === 'string' ? newScale : null;\n        if (updateScale === stateRef.current.scale) {\n            return;\n        }\n        setRenderQueueKey(function (key) { return key + 1; });\n        renderQueue.markNotRendered();\n        setScale(updateScale);\n        onZoom({ doc: doc, scale: updateScale });\n        setViewerState(__assign(__assign({}, stateRef.current), { scale: updateScale }));\n    }, []);\n    var enterFullScreenMode = React__namespace.useCallback(function (target) {\n        fullScreen.enterFullScreenMode(target);\n    }, []);\n    var exitFullScreenMode = React__namespace.useCallback(function () {\n        fullScreen.exitFullScreenMode();\n    }, []);\n    React__namespace.useEffect(function () {\n        setViewerState(__assign(__assign({}, stateRef.current), { fullScreenMode: fullScreen.fullScreenMode }));\n    }, [fullScreen.fullScreenMode]);\n    React__namespace.useEffect(function () {\n        var pluginMethods = {\n            enterFullScreenMode: enterFullScreenMode,\n            exitFullScreenMode: exitFullScreenMode,\n            getPagesContainer: getPagesContainer,\n            getViewerState: getViewerState,\n            jumpToDestination: jumpToDestination,\n            jumpToNextDestination: jumpToNextDestination,\n            jumpToPreviousDestination: jumpToPreviousDestination,\n            jumpToNextPage: jumpToNextPage,\n            jumpToPreviousPage: jumpToPreviousPage,\n            jumpToPage: jumpToPage,\n            openFile: openFile,\n            rotate: rotate,\n            rotatePage: rotatePage,\n            setViewerState: setViewerState,\n            switchScrollMode: switchScrollMode,\n            switchViewMode: switchViewMode,\n            zoom: zoom,\n        };\n        plugins.forEach(function (plugin) {\n            if (plugin.install) {\n                plugin.install(pluginMethods);\n            }\n        });\n        return function () {\n            plugins.forEach(function (plugin) {\n                if (plugin.uninstall) {\n                    plugin.uninstall(pluginMethods);\n                }\n            });\n        };\n    }, [docId]);\n    React__namespace.useEffect(function () {\n        onDocumentLoad({ doc: doc, file: currentFile });\n        plugins.forEach(function (plugin) {\n            plugin.onDocumentLoad && plugin.onDocumentLoad({ doc: doc, file: currentFile });\n        });\n    }, [docId]);\n    var boundingClientRect = virtualizer.boundingClientRect;\n    useRunOnce(function () {\n        if (initialPage) {\n            jumpToPage(initialPage);\n        }\n    }, boundingClientRect.height > 0 && boundingClientRect.width > 0);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > -1 && previousScrollMode !== currentScrollMode) {\n            virtualizer.scrollToItem(latestPage, ZERO_OFFSET).then(function () {\n                if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely) {\n                    if (!enableSmoothScroll) {\n                        renderQueue.markNotRendered();\n                    }\n                    forceTargetFullScreenRef.current = -1;\n                }\n            });\n        }\n    }, [currentScrollMode]);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > -1 && previousRotation !== rotation) {\n            virtualizer.scrollToItem(latestPage, ZERO_OFFSET);\n        }\n    }, [rotation]);\n    useIsomorphicLayoutEffect(function () {\n        if (previousScale != 0 && previousScale != stateRef.current.scale) {\n            virtualizer.zoom(stateRef.current.scale / previousScale, stateRef.current.pageIndex).then(function () {\n                if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely) {\n                    forceTargetZoomRef.current = -1;\n                }\n            });\n        }\n    }, [scale]);\n    useIsomorphicLayoutEffect(function () {\n        if (previousViewMode === stateRef.current.viewMode) {\n            return;\n        }\n        var startPage = virtualizer.startPage, endPage = virtualizer.endPage, virtualItems = virtualizer.virtualItems;\n        renderQueue.markNotRendered();\n        renderQueue.setRange(startPage, endPage);\n        var _loop_1 = function (i) {\n            var item = virtualItems.find(function (item) { return item.index === i; });\n            if (item) {\n                renderQueue.setVisibility(i, item.visibility);\n            }\n        };\n        for (var i = startPage; i <= endPage; i++) {\n            _loop_1(i);\n        }\n        renderNextPage();\n    }, [currentViewMode]);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > -1 && previousViewMode !== currentViewMode) {\n            virtualizer.scrollToItem(latestPage, ZERO_OFFSET);\n        }\n    }, [currentViewMode]);\n    useIsomorphicLayoutEffect(function () {\n        var latestPage = stateRef.current.pageIndex;\n        if (latestPage > 0 &&\n            latestPage === initialPage &&\n            forceTargetInitialPageRef.current === initialPage &&\n            keepSpecialZoomLevelRef.current) {\n            forceTargetInitialPageRef.current = -1;\n            zoom(keepSpecialZoomLevelRef.current);\n        }\n    }, [currentPage]);\n    React__namespace.useEffect(function () {\n        var isSmoothScrolling = virtualizer.isSmoothScrolling;\n        if (isSmoothScrolling) {\n            return;\n        }\n        if (mostRecentVisitedRef.current === null || mostRecentVisitedRef.current !== currentPage) {\n            mostRecentVisitedRef.current = currentPage;\n            onPageChange({ currentPage: currentPage, doc: doc });\n        }\n    }, [currentPage, virtualizer.isSmoothScrolling]);\n    React__namespace.useEffect(function () {\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.Entering && stateRef.current.scrollMode === exports.ScrollMode.Page) {\n            forceTargetFullScreenRef.current = stateRef.current.pageIndex;\n        }\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely &&\n            stateRef.current.scrollMode === exports.ScrollMode.Page &&\n            enableSmoothScroll) {\n            forceTargetFullScreenRef.current = -1;\n        }\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely && keepSpecialZoomLevelRef.current) {\n            forceTargetZoomRef.current = stateRef.current.pageIndex;\n            zoom(keepSpecialZoomLevelRef.current);\n        }\n    }, [fullScreen.fullScreenMode]);\n    React__namespace.useEffect(function () {\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.Entering ||\n            fullScreen.fullScreenMode === exports.FullScreenMode.Exitting ||\n            virtualizer.isSmoothScrolling) {\n            return;\n        }\n        var startPage = virtualizer.startPage, endPage = virtualizer.endPage, maxVisbilityIndex = virtualizer.maxVisbilityIndex, virtualItems = virtualizer.virtualItems;\n        var currentPage = maxVisbilityIndex;\n        var isFullScreen = fullScreen.fullScreenMode === exports.FullScreenMode.Entered ||\n            fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely;\n        if (isFullScreen && currentPage !== forceTargetFullScreenRef.current && forceTargetFullScreenRef.current > -1) {\n            return;\n        }\n        if (isFullScreen && currentPage !== forceTargetZoomRef.current && forceTargetZoomRef.current > -1) {\n            return;\n        }\n        setCurrentPage(currentPage);\n        setViewerState(__assign(__assign({}, stateRef.current), { pageIndex: currentPage }));\n        renderQueue.setRange(startPage, endPage);\n        var _loop_2 = function (i) {\n            var item = virtualItems.find(function (item) { return item.index === i; });\n            if (item) {\n                renderQueue.setVisibility(i, item.visibility);\n            }\n        };\n        for (var i = startPage; i <= endPage; i++) {\n            _loop_2(i);\n        }\n        renderNextPage();\n    }, [\n        virtualizer.startPage,\n        virtualizer.endPage,\n        virtualizer.isSmoothScrolling,\n        virtualizer.maxVisbilityIndex,\n        fullScreen.fullScreenMode,\n        pagesRotationChanged,\n        rotation,\n        scale,\n    ]);\n    var handlePageRenderCompleted = React__namespace.useCallback(function (pageIndex) {\n        renderQueue.markRendered(pageIndex);\n        renderNextPage();\n    }, [renderQueueKey]);\n    var renderNextPage = function () {\n        var nextPage = renderQueue.getHighestPriorityPage();\n        if (nextPage > -1 && renderQueue.isInRange(nextPage)) {\n            renderQueue.markRendering(nextPage);\n            setRenderPageIndex(nextPage);\n        }\n    };\n    var executeNamedAction = function (action) {\n        var previousPage = currentPage - 1;\n        var nextPage = currentPage + 1;\n        switch (action) {\n            case 'FirstPage':\n                jumpToPage(0);\n                break;\n            case 'LastPage':\n                jumpToPage(numPages - 1);\n                break;\n            case 'NextPage':\n                nextPage < numPages && jumpToPage(nextPage);\n                break;\n            case 'PrevPage':\n                previousPage >= 0 && jumpToPage(previousPage);\n                break;\n        }\n    };\n    var renderViewer = React__namespace.useCallback(function () {\n        var virtualItems = virtualizer.virtualItems;\n        var chunks = [];\n        switch (currentViewMode) {\n            case exports.ViewMode.DualPage:\n                chunks = chunk(virtualItems, 2);\n                break;\n            case exports.ViewMode.DualPageWithCover:\n                if (virtualItems.length) {\n                    chunks =\n                        virtualItems[0].index === 0\n                            ? [[virtualItems[0]]].concat(chunk(virtualItems.slice(1), 2))\n                            : chunk(virtualItems, 2);\n                }\n                break;\n            case exports.ViewMode.SinglePage:\n            default:\n                chunks = chunk(virtualItems, 1);\n                break;\n        }\n        var pageLabel = l10n && l10n.core ? l10n.core.pageLabel : 'Page {{pageIndex}}';\n        var slot = {\n            attrs: {\n                className: 'rpv-core__inner-container',\n                'data-testid': 'core__inner-container',\n                ref: containerRef,\n                style: {\n                    height: '100%',\n                },\n            },\n            children: React__namespace.createElement(React__namespace.Fragment, null),\n            subSlot: {\n                attrs: {\n                    'data-testid': 'core__inner-pages',\n                    className: classNames({\n                        'rpv-core__inner-pages': true,\n                        'rpv-core__inner-pages--horizontal': currentScrollMode === exports.ScrollMode.Horizontal,\n                        'rpv-core__inner-pages--rtl': isRtl,\n                        'rpv-core__inner-pages--single': currentScrollMode === exports.ScrollMode.Page,\n                        'rpv-core__inner-pages--vertical': currentScrollMode === exports.ScrollMode.Vertical,\n                        'rpv-core__inner-pages--wrapped': currentScrollMode === exports.ScrollMode.Wrapped,\n                    }),\n                    ref: pagesRef,\n                    style: {\n                        height: '100%',\n                        position: 'relative',\n                    },\n                },\n                children: (React__namespace.createElement(\"div\", { \"data-testid\": \"core__inner-current-page-\".concat(currentPage), style: Object.assign({\n                        '--scale-factor': scale,\n                    }, virtualizer.getContainerStyles()) }, chunks.map(function (items) { return (React__namespace.createElement(\"div\", { className: classNames({\n                        'rpv-core__inner-page-container': true,\n                        'rpv-core__inner-page-container--single': currentScrollMode === exports.ScrollMode.Page,\n                    }), style: virtualizer.getItemContainerStyles(items[0]), key: \"\".concat(items[0].index, \"-\").concat(currentViewMode) }, items.map(function (item) {\n                    var isCover = currentViewMode === exports.ViewMode.DualPageWithCover &&\n                        (item.index === 0 || (numPages % 2 === 0 && item.index === numPages - 1));\n                    return (React__namespace.createElement(\"div\", { \"aria-label\": pageLabel.replace('{{pageIndex}}', \"\".concat(item.index + 1)), className: classNames({\n                            'rpv-core__inner-page': true,\n                            'rpv-core__inner-page--dual-even': currentViewMode === exports.ViewMode.DualPage && item.index % 2 === 0,\n                            'rpv-core__inner-page--dual-odd': currentViewMode === exports.ViewMode.DualPage && item.index % 2 === 1,\n                            'rpv-core__inner-page--dual-cover': isCover,\n                            'rpv-core__inner-page--dual-cover-even': currentViewMode === exports.ViewMode.DualPageWithCover &&\n                                !isCover &&\n                                item.index % 2 === 0,\n                            'rpv-core__inner-page--dual-cover-odd': currentViewMode === exports.ViewMode.DualPageWithCover &&\n                                !isCover &&\n                                item.index % 2 === 1,\n                            'rpv-core__inner-page--single': currentViewMode === exports.ViewMode.SinglePage &&\n                                currentScrollMode === exports.ScrollMode.Page,\n                        }), role: \"region\", key: \"\".concat(item.index, \"-\").concat(currentViewMode), style: Object.assign({}, virtualizer.getItemStyles(item), layoutBuilder.buildPageStyles({\n                            numPages: numPages,\n                            pageIndex: item.index,\n                            scrollMode: currentScrollMode,\n                            viewMode: currentViewMode,\n                        })) },\n                        React__namespace.createElement(PageLayer, { doc: doc, measureRef: item.measureRef, outlines: outlines, pageIndex: item.index, pageRotation: pagesRotation.has(item.index) ? pagesRotation.get(item.index) : 0, pageSize: pageSizes[item.index], plugins: plugins, renderPage: renderPage, renderQueueKey: renderQueueKey, rotation: rotation, scale: scale, shouldRender: renderPageIndex === item.index, viewMode: currentViewMode, onExecuteNamedAction: executeNamedAction, onJumpFromLinkAnnotation: handleJumpFromLinkAnnotation, onJumpToDest: jumpToDestination, onRenderCompleted: handlePageRenderCompleted, onRotatePage: rotatePage })));\n                }))); }))),\n            },\n        };\n        plugins.forEach(function (plugin) {\n            if (plugin.renderViewer) {\n                slot = plugin.renderViewer({\n                    containerRef: containerRef,\n                    doc: doc,\n                    pagesContainerRef: pagesRef,\n                    pagesRotation: pagesRotation,\n                    pageSizes: pageSizes,\n                    rotation: rotation,\n                    slot: slot,\n                    themeContext: themeContext,\n                    jumpToPage: jumpToPage,\n                    openFile: openFile,\n                    rotate: rotate,\n                    rotatePage: rotatePage,\n                    switchScrollMode: switchScrollMode,\n                    switchViewMode: switchViewMode,\n                    zoom: zoom,\n                });\n            }\n        });\n        return slot;\n    }, [plugins, virtualizer]);\n    var renderSlot = React__namespace.useCallback(function (slot) { return (React__namespace.createElement(\"div\", __assign({}, slot.attrs, { style: slot.attrs && slot.attrs.style ? slot.attrs.style : {} }),\n        slot.children,\n        slot.subSlot && renderSlot(slot.subSlot))); }, []);\n    return renderSlot(renderViewer());\n};\n\nvar LEVELS = [\n    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3.0, 3.3, 3.7, 4.1, 4.6,\n    5.1, 5.7, 6.3, 7.0, 7.7, 8.5, 9.4, 10,\n];\nvar decrease = function (currentLevel) {\n    var found = LEVELS.findIndex(function (item) { return item >= currentLevel; });\n    return found === -1 || found === 0 ? currentLevel : LEVELS[found - 1];\n};\n\nvar RESERVE_HEIGHT = 45;\nvar RESERVE_WIDTH = 45;\nvar PageSizeCalculator = function (_a) {\n    var defaultScale = _a.defaultScale, doc = _a.doc, render = _a.render, scrollMode = _a.scrollMode, viewMode = _a.viewMode;\n    var pagesRef = React__namespace.useRef();\n    var _b = React__namespace.useState({\n        pageSizes: [],\n        scale: 0,\n    }), state = _b[0], setState = _b[1];\n    React__namespace.useLayoutEffect(function () {\n        var queryPageSizes = Array(doc.numPages)\n            .fill(0)\n            .map(function (_, i) {\n            return new Promise(function (resolve, _) {\n                getPage(doc, i).then(function (pdfPage) {\n                    var viewport = pdfPage.getViewport({ scale: 1 });\n                    resolve({\n                        pageHeight: viewport.height,\n                        pageWidth: viewport.width,\n                        rotation: viewport.rotation,\n                    });\n                });\n            });\n        });\n        Promise.all(queryPageSizes).then(function (pageSizes) {\n            var pagesEle = pagesRef.current;\n            if (!pagesEle || pageSizes.length === 0) {\n                return;\n            }\n            var w = pageSizes[0].pageWidth;\n            var h = pageSizes[0].pageHeight;\n            var parentEle = pagesEle.parentElement;\n            var scaleWidth = (parentEle.clientWidth - RESERVE_WIDTH) / w;\n            var scaleHeight = (parentEle.clientHeight - RESERVE_HEIGHT) / h;\n            var scaled = scaleWidth;\n            switch (scrollMode) {\n                case exports.ScrollMode.Horizontal:\n                    scaled = Math.min(scaleWidth, scaleHeight);\n                    break;\n                case exports.ScrollMode.Vertical:\n                default:\n                    scaled = scaleWidth;\n                    break;\n            }\n            var scale = defaultScale\n                ? typeof defaultScale === 'string'\n                    ? calculateScale(parentEle, h, w, defaultScale, viewMode, doc.numPages)\n                    : defaultScale\n                : decrease(scaled);\n            setState({ pageSizes: pageSizes, scale: scale });\n        });\n    }, [doc.loadingTask.docId]);\n    return state.pageSizes.length === 0 || state.scale === 0 ? (React__namespace.createElement(\"div\", { className: \"rpv-core__page-size-calculator\", \"data-testid\": \"core__page-size-calculating\", ref: pagesRef },\n        React__namespace.createElement(Spinner, null))) : (render(state.pageSizes, state.scale));\n};\n\nvar LoadingStatus = (function () {\n    function LoadingStatus() {\n    }\n    return LoadingStatus;\n}());\n\nvar AskForPasswordState = (function (_super) {\n    __extends(AskForPasswordState, _super);\n    function AskForPasswordState(verifyPassword, passwordStatus) {\n        var _this = _super.call(this) || this;\n        _this.verifyPassword = verifyPassword;\n        _this.passwordStatus = passwordStatus;\n        return _this;\n    }\n    return AskForPasswordState;\n}(LoadingStatus));\n\nvar AskingPassword = function (_a) {\n    var passwordStatus = _a.passwordStatus, renderProtectedView = _a.renderProtectedView, verifyPassword = _a.verifyPassword, onDocumentAskPassword = _a.onDocumentAskPassword;\n    var l10n = React__namespace.useContext(LocalizationContext).l10n;\n    var _b = React__namespace.useState(''), password = _b[0], setPassword = _b[1];\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var submit = function () { return verifyPassword(password); };\n    var handleKeyDown = function (e) {\n        if (e.key === 'Enter') {\n            submit();\n        }\n    };\n    React__namespace.useEffect(function () {\n        if (onDocumentAskPassword) {\n            onDocumentAskPassword({\n                verifyPassword: verifyPassword,\n            });\n        }\n    }, []);\n    if (renderProtectedView) {\n        return renderProtectedView({\n            passwordStatus: passwordStatus,\n            verifyPassword: verifyPassword,\n        });\n    }\n    return (React__namespace.createElement(\"div\", { className: \"rpv-core__asking-password-wrapper\" },\n        React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__asking-password': true,\n                'rpv-core__asking-password--rtl': isRtl,\n            }) },\n            React__namespace.createElement(\"div\", { className: \"rpv-core__asking-password-message\" },\n                passwordStatus === exports.PasswordStatus.RequiredPassword &&\n                    l10n.core.askingPassword\n                        .requirePasswordToOpen,\n                passwordStatus === exports.PasswordStatus.WrongPassword &&\n                    l10n.core.wrongPassword.tryAgain),\n            React__namespace.createElement(\"div\", { className: \"rpv-core__asking-password-body\" },\n                React__namespace.createElement(\"div\", { className: classNames({\n                        'rpv-core__asking-password-input': true,\n                        'rpv-core__asking-password-input--ltr': !isRtl,\n                        'rpv-core__asking-password-input--rtl': isRtl,\n                    }) },\n                    React__namespace.createElement(TextBox, { testId: \"core__asking-password-input\", type: \"password\", value: password, onChange: setPassword, onKeyDown: handleKeyDown })),\n                React__namespace.createElement(PrimaryButton, { onClick: submit }, l10n.core.askingPassword.submit)))));\n};\n\nvar CompletedState = (function (_super) {\n    __extends(CompletedState, _super);\n    function CompletedState(doc) {\n        var _this = _super.call(this) || this;\n        _this.doc = doc;\n        return _this;\n    }\n    return CompletedState;\n}(LoadingStatus));\n\nvar FailureState = (function (_super) {\n    __extends(FailureState, _super);\n    function FailureState(error) {\n        var _this = _super.call(this) || this;\n        _this.error = error;\n        return _this;\n    }\n    return FailureState;\n}(LoadingStatus));\n\nvar LoadingState = (function (_super) {\n    __extends(LoadingState, _super);\n    function LoadingState(percentages) {\n        var _this = _super.call(this) || this;\n        _this.percentages = percentages;\n        return _this;\n    }\n    return LoadingState;\n}(LoadingStatus));\n\nvar DocumentLoader = function (_a) {\n    var characterMap = _a.characterMap, file = _a.file, httpHeaders = _a.httpHeaders, render = _a.render, renderError = _a.renderError, renderLoader = _a.renderLoader, renderProtectedView = _a.renderProtectedView, transformGetDocumentParams = _a.transformGetDocumentParams, withCredentials = _a.withCredentials, onDocumentAskPassword = _a.onDocumentAskPassword;\n    var direction = React__namespace.useContext(ThemeContext).direction;\n    var isRtl = direction === exports.TextDirection.RightToLeft;\n    var _b = React__namespace.useState(new LoadingState(0)), status = _b[0], setStatus = _b[1];\n    var docRef = React__namespace.useRef('');\n    var isMounted = useIsMounted();\n    React__namespace.useEffect(function () {\n        docRef.current = '';\n        setStatus(new LoadingState(0));\n        var worker = new PdfJsApi__namespace.PDFWorker({ name: \"PDFWorker_\".concat(Date.now()) });\n        var params = Object.assign({\n            httpHeaders: httpHeaders,\n            withCredentials: withCredentials,\n            worker: worker,\n        }, 'string' === typeof file ? { url: file } : { data: file }, characterMap\n            ? {\n                cMapUrl: characterMap.url,\n                cMapPacked: characterMap.isCompressed,\n            }\n            : {});\n        var transformParams = transformGetDocumentParams ? transformGetDocumentParams(params) : params;\n        var loadingTask = PdfJsApi__namespace.getDocument(transformParams);\n        loadingTask.onPassword = function (verifyPassword, reason) {\n            switch (reason) {\n                case PdfJsApi__namespace.PasswordResponses.NEED_PASSWORD:\n                    isMounted.current &&\n                        setStatus(new AskForPasswordState(verifyPassword, exports.PasswordStatus.RequiredPassword));\n                    break;\n                case PdfJsApi__namespace.PasswordResponses.INCORRECT_PASSWORD:\n                    isMounted.current &&\n                        setStatus(new AskForPasswordState(verifyPassword, exports.PasswordStatus.WrongPassword));\n                    break;\n            }\n        };\n        loadingTask.onProgress = function (progress) {\n            var loaded = progress.total > 0\n                ?\n                    Math.min(100, (100 * progress.loaded) / progress.total)\n                : 100;\n            if (isMounted.current && docRef.current === '') {\n                setStatus(new LoadingState(loaded));\n            }\n        };\n        loadingTask.promise.then(function (doc) {\n            docRef.current = doc.loadingTask.docId;\n            isMounted.current && setStatus(new CompletedState(doc));\n        }, function (err) {\n            return isMounted.current &&\n                !worker.destroyed &&\n                setStatus(new FailureState({\n                    message: err.message || 'Cannot load document',\n                    name: err.name,\n                }));\n        });\n        return function () {\n            loadingTask.destroy();\n            worker.destroy();\n        };\n    }, [file]);\n    if (status instanceof AskForPasswordState) {\n        return (React__namespace.createElement(AskingPassword, { passwordStatus: status.passwordStatus, renderProtectedView: renderProtectedView, verifyPassword: status.verifyPassword, onDocumentAskPassword: onDocumentAskPassword }));\n    }\n    if (status instanceof CompletedState) {\n        return render(status.doc);\n    }\n    if (status instanceof FailureState) {\n        return renderError ? (renderError(status.error)) : (React__namespace.createElement(\"div\", { className: classNames({\n                'rpv-core__doc-error': true,\n                'rpv-core__doc-error--rtl': isRtl,\n            }) },\n            React__namespace.createElement(\"div\", { className: \"rpv-core__doc-error-text\" }, status.error.message)));\n    }\n    return (React__namespace.createElement(\"div\", { \"data-testid\": \"core__doc-loading\", className: classNames({\n            'rpv-core__doc-loading': true,\n            'rpv-core__doc-loading--rtl': isRtl,\n        }) }, renderLoader ? renderLoader(status.percentages) : React__namespace.createElement(Spinner, null)));\n};\n\nvar isDarkMode = function () {\n    return typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n};\n\nvar withTheme = function (theme, onSwitchTheme) {\n    var initialTheme = React__namespace.useMemo(function () { return (theme === 'auto' ? (isDarkMode() ? 'dark' : 'light') : theme); }, []);\n    var _a = React__namespace.useState(initialTheme), currentTheme = _a[0], setCurrentTheme = _a[1];\n    var prevTheme = usePrevious(currentTheme);\n    React__namespace.useEffect(function () {\n        if (theme !== 'auto') {\n            return;\n        }\n        var media = window.matchMedia('(prefers-color-scheme: dark)');\n        var handler = function (e) {\n            setCurrentTheme(e.matches ? 'dark' : 'light');\n        };\n        media.addEventListener('change', handler);\n        return function () { return media.removeEventListener('change', handler); };\n    }, []);\n    React__namespace.useEffect(function () {\n        if (currentTheme !== prevTheme && onSwitchTheme) {\n            onSwitchTheme(currentTheme);\n        }\n    }, [currentTheme]);\n    React__namespace.useEffect(function () {\n        if (theme !== currentTheme) {\n            setCurrentTheme(theme);\n        }\n    }, [theme]);\n    return {\n        currentTheme: currentTheme,\n        setCurrentTheme: setCurrentTheme,\n    };\n};\n\nvar isSameUrl = function (a, b) {\n    var typeA = typeof a;\n    var typeB = typeof b;\n    if (typeA === 'string' && typeB === 'string' && a === b) {\n        return true;\n    }\n    if (typeA === 'object' && typeB === 'object') {\n        return a.length === b.length && a.every(function (v, i) { return v === b[i]; });\n    }\n    return false;\n};\n\nvar NUM_OVERSCAN_PAGES = 3;\nvar DEFAULT_RENDER_RANGE = function (visiblePagesRange) {\n    return {\n        startPage: visiblePagesRange.startPage - NUM_OVERSCAN_PAGES,\n        endPage: visiblePagesRange.endPage + NUM_OVERSCAN_PAGES,\n    };\n};\nvar Viewer = function (_a) {\n    var characterMap = _a.characterMap, defaultScale = _a.defaultScale, _b = _a.enableSmoothScroll, enableSmoothScroll = _b === void 0 ? true : _b, fileUrl = _a.fileUrl, _c = _a.httpHeaders, httpHeaders = _c === void 0 ? {} : _c, _d = _a.initialPage, initialPage = _d === void 0 ? 0 : _d, pageLayout = _a.pageLayout, _e = _a.initialRotation, initialRotation = _e === void 0 ? 0 : _e, localization = _a.localization, _f = _a.plugins, plugins = _f === void 0 ? [] : _f, renderError = _a.renderError, renderLoader = _a.renderLoader, renderPage = _a.renderPage, renderProtectedView = _a.renderProtectedView, _g = _a.scrollMode, scrollMode = _g === void 0 ? exports.ScrollMode.Vertical : _g, _h = _a.setRenderRange, setRenderRange = _h === void 0 ? DEFAULT_RENDER_RANGE : _h, transformGetDocumentParams = _a.transformGetDocumentParams, _j = _a.theme, theme = _j === void 0 ? {\n        direction: exports.TextDirection.LeftToRight,\n        theme: 'light',\n    } : _j, _k = _a.viewMode, viewMode = _k === void 0 ? exports.ViewMode.SinglePage : _k, _l = _a.withCredentials, withCredentials = _l === void 0 ? false : _l, onDocumentAskPassword = _a.onDocumentAskPassword, _m = _a.onDocumentLoad, onDocumentLoad = _m === void 0 ? function () {\n    } : _m, _o = _a.onPageChange, onPageChange = _o === void 0 ? function () {\n    } : _o, _p = _a.onRotate, onRotate = _p === void 0 ? function () {\n    } : _p, _q = _a.onRotatePage, onRotatePage = _q === void 0 ? function () {\n    } : _q, _r = _a.onSwitchTheme, onSwitchTheme = _r === void 0 ? function () {\n    } : _r, _s = _a.onZoom, onZoom = _s === void 0 ? function () {\n    } : _s;\n    var _t = React__namespace.useState({\n        data: fileUrl,\n        name: typeof fileUrl === 'string' ? fileUrl : '',\n        shouldLoad: false,\n    }), file = _t[0], setFile = _t[1];\n    var openFile = function (fileName, data) {\n        setFile({\n            data: data,\n            name: fileName,\n            shouldLoad: true,\n        });\n    };\n    var _u = React__namespace.useState(false), visible = _u[0], setVisible = _u[1];\n    var prevFile = usePrevious(file);\n    React__namespace.useEffect(function () {\n        if (!isSameUrl(prevFile.data, fileUrl)) {\n            setFile({\n                data: fileUrl,\n                name: typeof fileUrl === 'string' ? fileUrl : '',\n                shouldLoad: visible,\n            });\n        }\n    }, [fileUrl, visible]);\n    var visibilityChanged = function (params) {\n        setVisible(params.isVisible);\n        if (params.isVisible) {\n            setFile(function (currentFile) { return Object.assign({}, currentFile, { shouldLoad: true }); });\n        }\n    };\n    var containerRef = useIntersectionObserver({\n        onVisibilityChanged: visibilityChanged,\n    });\n    var themeProps = typeof theme === 'string' ? { direction: exports.TextDirection.LeftToRight, theme: theme } : theme;\n    var _v = React__namespace.useState(localization || DefaultLocalization), l10n = _v[0], setL10n = _v[1];\n    var localizationContext = { l10n: l10n, setL10n: setL10n };\n    var themeContext = Object.assign({}, { direction: themeProps.direction }, withTheme(themeProps.theme || 'light', onSwitchTheme));\n    React__namespace.useEffect(function () {\n        if (localization) {\n            setL10n(localization);\n        }\n    }, [localization]);\n    return (React__namespace.createElement(LocalizationContext.Provider, { value: localizationContext },\n        React__namespace.createElement(ThemeContext.Provider, { value: themeContext },\n            React__namespace.createElement(\"div\", { ref: containerRef, className: \"rpv-core__viewer rpv-core__viewer--\".concat(themeContext.currentTheme), \"data-testid\": \"core__viewer\", style: {\n                    height: '100%',\n                    width: '100%',\n                } }, file.shouldLoad && (React__namespace.createElement(DocumentLoader, { characterMap: characterMap, file: file.data, httpHeaders: httpHeaders, render: function (doc) { return (React__namespace.createElement(PageSizeCalculator, { defaultScale: defaultScale, doc: doc, render: function (pageSizes, initialScale) { return (React__namespace.createElement(Inner, { currentFile: {\n                            data: file.data,\n                            name: file.name,\n                        }, defaultScale: defaultScale, doc: doc, enableSmoothScroll: enableSmoothScroll, initialPage: initialPage, initialRotation: initialRotation, initialScale: initialScale, pageLayout: pageLayout, pageSizes: pageSizes, plugins: plugins, renderPage: renderPage, scrollMode: scrollMode, setRenderRange: setRenderRange, viewMode: viewMode, viewerState: {\n                            file: file,\n                            fullScreenMode: exports.FullScreenMode.Normal,\n                            pageIndex: -1,\n                            pageHeight: pageSizes[0].pageHeight,\n                            pageWidth: pageSizes[0].pageWidth,\n                            pagesRotation: new Map(),\n                            rotation: initialRotation,\n                            scale: initialScale,\n                            scrollMode: scrollMode,\n                            viewMode: viewMode,\n                        }, onDocumentLoad: onDocumentLoad, onOpenFile: openFile, onPageChange: onPageChange, onRotate: onRotate, onRotatePage: onRotatePage, onZoom: onZoom })); }, scrollMode: scrollMode, viewMode: viewMode })); }, renderError: renderError, renderLoader: renderLoader, renderProtectedView: renderProtectedView, transformGetDocumentParams: transformGetDocumentParams, withCredentials: withCredentials, onDocumentAskPassword: onDocumentAskPassword }))))));\n};\n\nvar Worker = function (_a) {\n    var children = _a.children, workerUrl = _a.workerUrl;\n    PdfJsApi__namespace.GlobalWorkerOptions.workerSrc = workerUrl;\n    return React__namespace.createElement(React__namespace.Fragment, null, children);\n};\n\nexports.Button = Button;\nexports.Icon = Icon;\nexports.LazyRender = LazyRender;\nexports.LocalizationContext = LocalizationContext;\nexports.Menu = Menu;\nexports.MenuDivider = MenuDivider;\nexports.MenuItem = MenuItem;\nexports.MinimalButton = MinimalButton;\nexports.Modal = Modal;\nexports.Popover = Popover;\nexports.PrimaryButton = PrimaryButton;\nexports.ProgressBar = ProgressBar;\nexports.Separator = Separator;\nexports.Spinner = Spinner;\nexports.Splitter = Splitter;\nexports.TextBox = TextBox;\nexports.ThemeContext = ThemeContext;\nexports.Tooltip = Tooltip;\nexports.Viewer = Viewer;\nexports.Worker = Worker;\nexports.chunk = chunk;\nexports.classNames = classNames;\nexports.createStore = createStore;\nexports.getDestination = getDestination;\nexports.getPage = getPage;\nexports.isFullScreenEnabled = isFullScreenEnabled;\nexports.isMac = isMac;\nexports.useDebounceCallback = useDebounceCallback;\nexports.useIntersectionObserver = useIntersectionObserver;\nexports.useIsMounted = useIsMounted;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.usePrevious = usePrevious;\nexports.useRenderQueue = useRenderQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZi12aWV3ZXIrY29yZUAzLjEyLjBfcGRmanMtZGlzdEAzLjQuMTIwX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYtdmlld2VyL2NvcmUvbGliL2Nqcy9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywrTEFBTztBQUMzQixlQUFlLG1CQUFPLENBQUMsc0dBQVk7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLHNCQUFzQixLQUFLOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLHFCQUFxQixLQUFLO0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLCtDQUErQztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxRUFBcUUsdUNBQXVDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsc0RBQXNEO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3RUFBd0UsZ0VBQWdFO0FBQ3hJLGdGQUFnRiwyRUFBMkU7QUFDM0osdUVBQXVFLHlGQUF5RjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBLG1CQUFtQix1RUFBdUUsZ0dBQWdHLDZEQUE2RCxtRkFBbUYsZ0RBQWdEO0FBQzFYO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0pBQW9KLEtBQUssOENBQThDLEtBQUssME9BQTBPO0FBQy9jOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIsMkJBQTJCO0FBQzNCLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsZUFBZTtBQUNmLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2IsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixvQkFBb0I7QUFDcEIsaUNBQWlDO0FBQ2pDLG1CQUFtQjtBQUNuQixzQkFBc0IiLCJzb3VyY2VzIjpbIi9ob21lL25vZS1jYW1wby9kZWxvcy9wcm9qZXQvbGFiLWtzL2tzLWxhYi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZi12aWV3ZXIrY29yZUAzLjEyLjBfcGRmanMtZGlzdEAzLjQuMTIwX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYtdmlld2VyL2NvcmUvbGliL2Nqcy9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBQZGZKc0FwaSA9IHJlcXVpcmUoJ3BkZmpzLWRpc3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG4uZGVmYXVsdCA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChSZWFjdCk7XG52YXIgUGRmSnNBcGlfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoUGRmSnNBcGkpO1xuXG5leHBvcnRzLkFubm90YXRpb25UeXBlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChBbm5vdGF0aW9uVHlwZSkge1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiVGV4dFwiXSA9IDFdID0gXCJUZXh0XCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJMaW5rXCJdID0gMl0gPSBcIkxpbmtcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIkZyZWVUZXh0XCJdID0gM10gPSBcIkZyZWVUZXh0XCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJMaW5lXCJdID0gNF0gPSBcIkxpbmVcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlNxdWFyZVwiXSA9IDVdID0gXCJTcXVhcmVcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIkNpcmNsZVwiXSA9IDZdID0gXCJDaXJjbGVcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlBvbHlnb25cIl0gPSA3XSA9IFwiUG9seWdvblwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiUG9seWxpbmVcIl0gPSA4XSA9IFwiUG9seWxpbmVcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIkhpZ2hsaWdodFwiXSA9IDldID0gXCJIaWdobGlnaHRcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlVuZGVybGluZVwiXSA9IDEwXSA9IFwiVW5kZXJsaW5lXCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJTcXVpZ2dseVwiXSA9IDExXSA9IFwiU3F1aWdnbHlcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlN0cmlrZU91dFwiXSA9IDEyXSA9IFwiU3RyaWtlT3V0XCI7XG4gICAgQW5ub3RhdGlvblR5cGVbQW5ub3RhdGlvblR5cGVbXCJTdGFtcFwiXSA9IDEzXSA9IFwiU3RhbXBcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIkNhcmV0XCJdID0gMTRdID0gXCJDYXJldFwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiSW5rXCJdID0gMTVdID0gXCJJbmtcIjtcbiAgICBBbm5vdGF0aW9uVHlwZVtBbm5vdGF0aW9uVHlwZVtcIlBvcHVwXCJdID0gMTZdID0gXCJQb3B1cFwiO1xuICAgIEFubm90YXRpb25UeXBlW0Fubm90YXRpb25UeXBlW1wiRmlsZUF0dGFjaG1lbnRcIl0gPSAxN10gPSBcIkZpbGVBdHRhY2htZW50XCI7XG59KShleHBvcnRzLkFubm90YXRpb25UeXBlIHx8IChleHBvcnRzLkFubm90YXRpb25UeXBlID0ge30pKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG5leHBvcnRzLlRleHREaXJlY3Rpb24gPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFRleHREaXJlY3Rpb24pIHtcbiAgICBUZXh0RGlyZWN0aW9uW1wiUmlnaHRUb0xlZnRcIl0gPSBcIlJUTFwiO1xuICAgIFRleHREaXJlY3Rpb25bXCJMZWZ0VG9SaWdodFwiXSA9IFwiTFRSXCI7XG59KShleHBvcnRzLlRleHREaXJlY3Rpb24gfHwgKGV4cG9ydHMuVGV4dERpcmVjdGlvbiA9IHt9KSk7XG52YXIgVGhlbWVDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KHtcbiAgICBjdXJyZW50VGhlbWU6ICdsaWdodCcsXG4gICAgZGlyZWN0aW9uOiBleHBvcnRzLlRleHREaXJlY3Rpb24uTGVmdFRvUmlnaHQsXG4gICAgc2V0Q3VycmVudFRoZW1lOiBmdW5jdGlvbiAoKSB7IH0sXG59KTtcblxudmFyIGNsYXNzTmFtZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjbGFzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICBpZiAoY2xhenogJiYgY2xhc3Nlc1tjbGF6el0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xufTtcblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCB0ZXN0SWQgPSBfYS50ZXN0SWQsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIGF0dHJzID0gdGVzdElkID8geyAnZGF0YS10ZXN0aWQnOiB0ZXN0SWQgfSA6IHt9O1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fYnV0dG9uJzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fYnV0dG9uLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgfSksIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IG9uQ2xpY2sgfSwgYXR0cnMpLCBjaGlsZHJlbikpO1xufTtcblxudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0X19uYW1lc3BhY2UudXNlTGF5b3V0RWZmZWN0IDogUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3Q7XG5cbnZhciB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlciA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBjb250YWluZXJSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihudWxsKTtcbiAgICB2YXIgb25jZSA9IHByb3BzLm9uY2UsIHRocmVzaG9sZCA9IHByb3BzLnRocmVzaG9sZCwgb25WaXNpYmlsaXR5Q2hhbmdlZCA9IHByb3BzLm9uVmlzaWJpbGl0eUNoYW5nZWQ7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uVHJhY2tlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgICAgICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2VkKHsgaXNWaXNpYmxlOiBpc1Zpc2libGUsIHJhdGlvOiByYXRpbyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlICYmIG9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uVHJhY2tlci51bm9ic2VydmUoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uVHJhY2tlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRocmVzaG9sZDogdGhyZXNob2xkIHx8IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBpbnRlcnNlY3Rpb25UcmFja2VyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblRyYWNrZXIudW5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25UcmFja2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lclJlZjtcbn07XG5cbnZhciBMYXp5UmVuZGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGF0dHJzID0gX2EuYXR0cnMsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIHRlc3RJZCA9IF9hLnRlc3RJZDtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKSwgdmlzaWJsZSA9IF9iWzBdLCBzZXRWaXNpYmxlID0gX2JbMV07XG4gICAgdmFyIGNvbnRhaW5lckF0dHJzID0gdGVzdElkID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGF0dHJzKSwgeyAnZGF0YS10ZXN0aWQnOiB0ZXN0SWQgfSkgOiBhdHRycztcbiAgICB2YXIgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBzZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoe1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2VkOiBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCxcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7IHJlZjogY29udGFpbmVyUmVmIH0sIGNvbnRhaW5lckF0dHJzKSwgdmlzaWJsZSAmJiBjaGlsZHJlbikpO1xufTtcblxudmFyIE1lbnUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgdmlzaWJsZU1lbnVJdGVtc1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKFtdKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbW92ZVRvSXRlbShmdW5jdGlvbiAoXywgY3VycmVudEluZGV4KSB7IHJldHVybiBjdXJyZW50SW5kZXggKyAxOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBtb3ZlVG9JdGVtKGZ1bmN0aW9uIChfLCBjdXJyZW50SW5kZXgpIHsgcmV0dXJuIGN1cnJlbnRJbmRleCAtIDE7IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbW92ZVRvSXRlbShmdW5jdGlvbiAoaXRlbXMsIF8pIHsgcmV0dXJuIGl0ZW1zLmxlbmd0aCAtIDE7IH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG1vdmVUb0l0ZW0oZnVuY3Rpb24gKF8sIF9fKSB7IHJldHVybiAwOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG1vdmVUb0l0ZW0gPSBmdW5jdGlvbiAoZ2V0TmV4dEl0ZW0pIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtcyA9IHZpc2libGVNZW51SXRlbXNSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09ICcwJzsgfSk7XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IE1hdGgubWluKGl0ZW1zLmxlbmd0aCAtIDEsIE1hdGgubWF4KDAsIGdldE5leHRJdGVtKGl0ZW1zLCBjdXJyZW50SW5kZXgpKSk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gMCAmJiBjdXJyZW50SW5kZXggPD0gaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaXRlbXNbY3VycmVudEluZGV4XS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbXNbdGFyZ2V0SW5kZXhdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICBpdGVtc1t0YXJnZXRJbmRleF0uZm9jdXMoKTtcbiAgICB9O1xuICAgIHZhciBmaW5kVmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgdmlzaWJsZUl0ZW1zID0gW107XG4gICAgICAgIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcucnB2LWNvcmVfX21lbnUtaXRlbVtyb2xlPVwibWVudWl0ZW1cIl0nKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gaXRlbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfMSA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudF8xKS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZpc2libGVJdGVtcztcbiAgICB9O1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpc2libGVJdGVtcyA9IGZpbmRWaXNpYmxlSXRlbXMoY29udGFpbmVyKTtcbiAgICAgICAgdmlzaWJsZU1lbnVJdGVtc1JlZi5jdXJyZW50ID0gdmlzaWJsZUl0ZW1zO1xuICAgIH0sIFtdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyUmVmLCBcImFyaWEtb3JpZW50YXRpb25cIjogXCJ2ZXJ0aWNhbFwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51JzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fbWVudS0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pLCByb2xlOiBcIm1lbnVcIiwgdGFiSW5kZXg6IDAgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBNZW51RGl2aWRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtb3JpZW50YXRpb25cIjogXCJob3Jpem9udGFsXCIsIGNsYXNzTmFtZTogXCJycHYtY29yZV9fbWVudS1kaXZpZGVyXCIsIHJvbGU6IFwic2VwYXJhdG9yXCIgfSkpOyB9O1xuXG52YXIgSWNvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYiA9IF9hLmlnbm9yZURpcmVjdGlvbiwgaWdub3JlRGlyZWN0aW9uID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gX2Euc2l6ZSwgc2l6ZSA9IF9jID09PSB2b2lkIDAgPyAyNCA6IF9jO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIGlzUnRsID0gIWlnbm9yZURpcmVjdGlvbiAmJiBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgd2lkdGggPSBcIlwiLmNvbmNhdChzaXplIHx8IDI0LCBcInB4XCIpO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9faWNvbic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX2ljb24tLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSwgZm9jdXNhYmxlOiBcImZhbHNlXCIsIGhlaWdodDogd2lkdGgsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIHdpZHRoOiB3aWR0aCB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIENoZWNrSWNvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSWNvbiwgeyBzaXplOiAxNiB9LFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0yMy41LDAuNDk5bC0xNi41LDIzbC02LjUtNi41XCIgfSkpKTsgfTtcblxudmFyIE1lbnVJdGVtID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuY2hlY2tlZCwgY2hlY2tlZCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYyA9IF9hLmljb24sIGljb24gPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jLCBfZCA9IF9hLmlzRGlzYWJsZWQsIGlzRGlzYWJsZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgdGVzdElkID0gX2EudGVzdElkLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBhdHRycyA9IHRlc3RJZCA/IHsgJ2RhdGEtdGVzdGlkJzogdGVzdElkIH0gOiB7fTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbSc6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS0tZGlzYWJsZWQnOiBpc0Rpc2FibGVkLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tLWx0cic6ICFpc1J0bCxcbiAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgfSksIHJvbGU6IFwibWVudWl0ZW1cIiwgdGFiSW5kZXg6IC0xLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBvbkNsaWNrIH0sIGF0dHJzKSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS1pY29uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS1pY29uLS1sdHInOiAhaXNSdGwsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0taWNvbi0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICB9KSB9LCBpY29uKSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS1sYWJlbCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tbGFiZWwtLWx0cic6ICFpc1J0bCxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX21lbnUtaXRlbS1sYWJlbC0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICB9KSB9LCBjaGlsZHJlbiksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tY2hlY2snOiB0cnVlLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fbWVudS1pdGVtLWNoZWNrLS1sdHInOiAhaXNSdGwsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19tZW51LWl0ZW0tY2hlY2stLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgfSkgfSwgY2hlY2tlZCAmJiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ2hlY2tJY29uLCBudWxsKSkpKTtcbn07XG5cbnZhciBNaW5pbWFsQnV0dG9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuYXJpYUxhYmVsLCBhcmlhTGFiZWwgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYiwgX2MgPSBfYS5hcmlhS2V5U2hvcnRjdXRzLCBhcmlhS2V5U2hvcnRjdXRzID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2MsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIF9kID0gX2EuaXNEaXNhYmxlZCwgaXNEaXNhYmxlZCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IF9hLmlzU2VsZWN0ZWQsIGlzU2VsZWN0ZWQgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgdGVzdElkID0gX2EudGVzdElkLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBhdHRycyA9IHRlc3RJZCA/IHsgJ2RhdGEtdGVzdGlkJzogdGVzdElkIH0gOiB7fTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfX2Fzc2lnbih7IFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwgfSwgKGFyaWFLZXlTaG9ydGN1dHMgJiYgeyAnYXJpYS1rZXlzaG9ydGN1dHMnOiBhcmlhS2V5U2hvcnRjdXRzIH0pLCAoaXNEaXNhYmxlZCAmJiB7ICdhcmlhLWRpc2FibGVkJzogdHJ1ZSB9KSwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19taW5pbWFsLWJ1dHRvbic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21pbmltYWwtYnV0dG9uLS1kaXNhYmxlZCc6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICAncnB2LWNvcmVfX21pbmltYWwtYnV0dG9uLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgICdycHYtY29yZV9fbWluaW1hbC1idXR0b24tLXNlbGVjdGVkJzogaXNTZWxlY3RlZCxcbiAgICAgICAgfSksIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IG9uQ2xpY2sgfSwgYXR0cnMpLCBjaGlsZHJlbikpO1xufTtcblxudmFyIFByaW1hcnlCdXR0b24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgdGVzdElkID0gX2EudGVzdElkLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBhdHRycyA9IHRlc3RJZCA/IHsgJ2RhdGEtdGVzdGlkJzogdGVzdElkIH0gOiB7fTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX3ByaW1hcnktYnV0dG9uJzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fcHJpbWFyeS1idXR0b24tLXJ0bCc6IGlzUnRsLFxuICAgICAgICB9KSwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogb25DbGljayB9LCBhdHRycyksIGNoaWxkcmVuKSk7XG59O1xuXG52YXIgUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBfYS5wcm9ncmVzcztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fcHJvZ3Jlc3MtYmFyJzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fcHJvZ3Jlc3MtYmFyLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgfSkgfSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19wcm9ncmVzcy1iYXItcHJvZ3Jlc3NcIiwgc3R5bGU6IHsgd2lkdGg6IFwiXCIuY29uY2F0KHByb2dyZXNzLCBcIiVcIikgfSB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICBcIiVcIikpKTtcbn07XG5cbnZhciBTZXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX3NlcGFyYXRvclwiIH0pOyB9O1xuXG52YXIgU3Bpbm5lciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLnNpemUsIHNpemUgPSBfYiA9PT0gdm9pZCAwID8gJzRyZW0nIDogX2IsIHRlc3RJZCA9IF9hLnRlc3RJZDtcbiAgICB2YXIgX2MgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKSwgdmlzaWJsZSA9IF9jWzBdLCBzZXRWaXNpYmxlID0gX2NbMV07XG4gICAgdmFyIGF0dHJzID0gdGVzdElkID8geyAnZGF0YS10ZXN0aWQnOiB0ZXN0SWQgfSA6IHt9O1xuICAgIHZhciBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgc2V0VmlzaWJsZShwYXJhbXMuaXNWaXNpYmxlKTtcbiAgICB9O1xuICAgIHZhciBjb250YWluZXJSZWYgPSB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcih7XG4gICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZWQ6IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkLFxuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBhdHRycywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19zcGlubmVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fc3Bpbm5lci0tYW5pbWF0aW5nJzogdmlzaWJsZSxcbiAgICAgICAgfSksIHJlZjogY29udGFpbmVyUmVmLCBzdHlsZTogeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0gfSkpKTtcbn07XG5cbnZhciBTcGxpdHRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjb25zdHJhaW4gPSBfYS5jb25zdHJhaW47XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgcmVzaXplclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGxlZnRTaWRlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgcmlnaHRTaWRlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgeFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKDApO1xuICAgIHZhciB5UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoMCk7XG4gICAgdmFyIGxlZnRXaWR0aFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKDApO1xuICAgIHZhciByZXNpemVyV2lkdGhSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigwKTtcbiAgICB2YXIgZXZlbnRPcHRpb25zID0ge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgIH07XG4gICAgdmFyIGhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByZXNpemVyRWxlID0gcmVzaXplclJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgbGVmdFNpZGUgPSBsZWZ0U2lkZVJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgcmlnaHRTaWRlID0gcmlnaHRTaWRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghcmVzaXplckVsZSB8fCAhbGVmdFNpZGUgfHwgIXJpZ2h0U2lkZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNpemVyV2lkdGggPSByZXNpemVyV2lkdGhSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGR4ID0gZS5jbGllbnRYIC0geFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgZmlyc3RIYWxmU2l6ZSA9IGxlZnRXaWR0aFJlZi5jdXJyZW50ICsgKGlzUnRsID8gLWR4IDogZHgpO1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSByZXNpemVyRWxlLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIHZhciBmaXJzdEhhbGZQZXJjZW50YWdlID0gKGZpcnN0SGFsZlNpemUgKiAxMDApIC8gY29udGFpbmVyV2lkdGg7XG4gICAgICAgIHJlc2l6ZXJFbGUuY2xhc3NMaXN0LmFkZCgncnB2LWNvcmVfX3NwbGl0dGVyLS1yZXNpemluZycpO1xuICAgICAgICBpZiAoY29uc3RyYWluKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kSGFsZlNpemUgPSBjb250YWluZXJXaWR0aCAtIGZpcnN0SGFsZlNpemUgLSByZXNpemVyV2lkdGg7XG4gICAgICAgICAgICB2YXIgc2Vjb25kSGFsZlBlcmNlbnRhZ2UgPSAoc2Vjb25kSGFsZlNpemUgKiAxMDApIC8gY29udGFpbmVyV2lkdGg7XG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbih7IGZpcnN0SGFsZlBlcmNlbnRhZ2U6IGZpcnN0SGFsZlBlcmNlbnRhZ2UsIGZpcnN0SGFsZlNpemU6IGZpcnN0SGFsZlNpemUsIHNlY29uZEhhbGZQZXJjZW50YWdlOiBzZWNvbmRIYWxmUGVyY2VudGFnZSwgc2Vjb25kSGFsZlNpemU6IHNlY29uZEhhbGZTaXplIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnRTaWRlLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoZmlyc3RIYWxmUGVyY2VudGFnZSwgXCIlXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3Jwdi1jb3JlX19zcGxpdHRlci1ib2R5LS1yZXNpemluZycpO1xuICAgICAgICBsZWZ0U2lkZS5jbGFzc0xpc3QuYWRkKCdycHYtY29yZV9fc3BsaXR0ZXItc2libGluZy0tcmVzaXppbmcnKTtcbiAgICAgICAgcmlnaHRTaWRlLmNsYXNzTGlzdC5hZGQoJ3Jwdi1jb3JlX19zcGxpdHRlci1zaWJsaW5nLS1yZXNpemluZycpO1xuICAgIH07XG4gICAgdmFyIGhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcmVzaXplckVsZSA9IHJlc2l6ZXJSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGxlZnRTaWRlID0gbGVmdFNpZGVSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIHJpZ2h0U2lkZSA9IHJpZ2h0U2lkZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXJlc2l6ZXJFbGUgfHwgIWxlZnRTaWRlIHx8ICFyaWdodFNpZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3Jwdi1jb3JlX19zcGxpdHRlci1ib2R5LS1yZXNpemluZycpO1xuICAgICAgICByZXNpemVyRWxlLmNsYXNzTGlzdC5yZW1vdmUoJ3Jwdi1jb3JlX19zcGxpdHRlci0tcmVzaXppbmcnKTtcbiAgICAgICAgbGVmdFNpZGUuY2xhc3NMaXN0LnJlbW92ZSgncnB2LWNvcmVfX3NwbGl0dGVyLXNpYmxpbmctLXJlc2l6aW5nJyk7XG4gICAgICAgIHJpZ2h0U2lkZS5jbGFzc0xpc3QucmVtb3ZlKCdycHYtY29yZV9fc3BsaXR0ZXItc2libGluZy0tcmVzaXppbmcnKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCwgZXZlbnRPcHRpb25zKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbGVmdFNpZGUgPSBsZWZ0U2lkZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWxlZnRTaWRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeFJlZi5jdXJyZW50ID0gZS5jbGllbnRYO1xuICAgICAgICB5UmVmLmN1cnJlbnQgPSBlLmNsaWVudFk7XG4gICAgICAgIGxlZnRXaWR0aFJlZi5jdXJyZW50ID0gbGVmdFNpZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXAsIGV2ZW50T3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXNpemVyRWxlID0gcmVzaXplclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXJlc2l6ZXJFbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNpemVyV2lkdGhSZWYuY3VycmVudCA9IHJlc2l6ZXJFbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGxlZnRTaWRlUmVmLmN1cnJlbnQgPSByZXNpemVyRWxlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgIHJpZ2h0U2lkZVJlZi5jdXJyZW50ID0gcmVzaXplckVsZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJlc2l6ZXJSZWYsIGNsYXNzTmFtZTogXCJycHYtY29yZV9fc3BsaXR0ZXJcIiwgb25Nb3VzZURvd246IGhhbmRsZU1vdXNlRG93biB9KTtcbn07XG5cbnZhciBUZXh0Qm94ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuYXJpYUxhYmVsLCBhcmlhTGFiZWwgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYiwgX2MgPSBfYS5hdXRvRm9jdXMsIGF1dG9Gb2N1cyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLnBsYWNlaG9sZGVyLCBwbGFjZWhvbGRlciA9IF9kID09PSB2b2lkIDAgPyAnJyA6IF9kLCB0ZXN0SWQgPSBfYS50ZXN0SWQsIF9lID0gX2EudHlwZSwgdHlwZSA9IF9lID09PSB2b2lkIDAgPyAndGV4dCcgOiBfZSwgX2YgPSBfYS52YWx1ZSwgdmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gJycgOiBfZiwgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgX2cgPSBfYS5vbktleURvd24sIG9uS2V5RG93biA9IF9nID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7IH0gOiBfZztcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciB0ZXh0Ym94UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIHJlZjogdGV4dGJveFJlZixcbiAgICAgICAgJ2RhdGEtdGVzdGlkJzogJycsXG4gICAgICAgICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX190ZXh0Ym94JzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fdGV4dGJveC0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pLFxuICAgICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkNoYW5nZShlLnRhcmdldC52YWx1ZSk7IH0sXG4gICAgICAgIG9uS2V5RG93bjogb25LZXlEb3duLFxuICAgIH07XG4gICAgaWYgKHRlc3RJZCkge1xuICAgICAgICBhdHRyc1snZGF0YS10ZXN0aWQnXSA9IHRlc3RJZDtcbiAgICB9XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhdXRvRm9jdXMpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0Ym94RWxlID0gdGV4dGJveFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHRleHRib3hFbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICAgICAgdGV4dGJveEVsZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHQnID8gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX19hc3NpZ24oeyB0eXBlOiBcInRleHRcIiB9LCBhdHRycykpIDogUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX19hc3NpZ24oeyB0eXBlOiBcInBhc3N3b3JkXCIgfSwgYXR0cnMpKTtcbn07XG5cbnZhciBBcGk7XG4oZnVuY3Rpb24gKEFwaSkge1xuICAgIEFwaVtBcGlbXCJFeGl0RnVsbFNjcmVlblwiXSA9IDBdID0gXCJFeGl0RnVsbFNjcmVlblwiO1xuICAgIEFwaVtBcGlbXCJGdWxsU2NyZWVuQ2hhbmdlXCJdID0gMV0gPSBcIkZ1bGxTY3JlZW5DaGFuZ2VcIjtcbiAgICBBcGlbQXBpW1wiRnVsbFNjcmVlbkVsZW1lbnRcIl0gPSAyXSA9IFwiRnVsbFNjcmVlbkVsZW1lbnRcIjtcbiAgICBBcGlbQXBpW1wiRnVsbFNjcmVlbkVuYWJsZWRcIl0gPSAzXSA9IFwiRnVsbFNjcmVlbkVuYWJsZWRcIjtcbiAgICBBcGlbQXBpW1wiUmVxdWVzdEZ1bGxTY3JlZW5cIl0gPSA0XSA9IFwiUmVxdWVzdEZ1bGxTY3JlZW5cIjtcbn0pKEFwaSB8fCAoQXBpID0ge30pKTtcbnZhciBkZWZhdWx0VmVuZG9yID0ge1xuICAgIEV4aXRGdWxsU2NyZWVuOiAnZXhpdEZ1bGxzY3JlZW4nLFxuICAgIEZ1bGxTY3JlZW5DaGFuZ2U6ICdmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICBGdWxsU2NyZWVuRWxlbWVudDogJ2Z1bGxzY3JlZW5FbGVtZW50JyxcbiAgICBGdWxsU2NyZWVuRW5hYmxlZDogJ2Z1bGxzY3JlZW5FbmFibGVkJyxcbiAgICBSZXF1ZXN0RnVsbFNjcmVlbjogJ3JlcXVlc3RGdWxsc2NyZWVuJyxcbn07XG52YXIgd2Via2l0VmVuZG9yID0ge1xuICAgIEV4aXRGdWxsU2NyZWVuOiAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxuICAgIEZ1bGxTY3JlZW5DaGFuZ2U6ICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICBGdWxsU2NyZWVuRWxlbWVudDogJ3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50JyxcbiAgICBGdWxsU2NyZWVuRW5hYmxlZDogJ3dlYmtpdEZ1bGxzY3JlZW5FbmFibGVkJyxcbiAgICBSZXF1ZXN0RnVsbFNjcmVlbjogJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcbn07XG52YXIgbXNWZW5kb3IgPSB7XG4gICAgRXhpdEZ1bGxTY3JlZW46ICdtc0V4aXRGdWxsc2NyZWVuJyxcbiAgICBGdWxsU2NyZWVuQ2hhbmdlOiAnbXNGdWxsc2NyZWVuQ2hhbmdlJyxcbiAgICBGdWxsU2NyZWVuRWxlbWVudDogJ21zRnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgIEZ1bGxTY3JlZW5FbmFibGVkOiAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgUmVxdWVzdEZ1bGxTY3JlZW46ICdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcbn07XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgdmVuZG9yID0gaXNCcm93c2VyXG4gICAgPyAoQXBpLkZ1bGxTY3JlZW5FbmFibGVkIGluIGRvY3VtZW50ICYmIGRlZmF1bHRWZW5kb3IpIHx8XG4gICAgICAgICh3ZWJraXRWZW5kb3IuRnVsbFNjcmVlbkVuYWJsZWQgaW4gZG9jdW1lbnQgJiYgd2Via2l0VmVuZG9yKSB8fFxuICAgICAgICAobXNWZW5kb3IuRnVsbFNjcmVlbkVuYWJsZWQgaW4gZG9jdW1lbnQgJiYgbXNWZW5kb3IpIHx8XG4gICAgICAgIGRlZmF1bHRWZW5kb3JcbiAgICA6IGRlZmF1bHRWZW5kb3I7XG52YXIgaXNGdWxsU2NyZWVuRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHZlbmRvci5GdWxsU2NyZWVuRW5hYmxlZCBpbiBkb2N1bWVudCAmJiBkb2N1bWVudFt2ZW5kb3IuRnVsbFNjcmVlbkVuYWJsZWRdID09PSB0cnVlO1xufTtcbnZhciBhZGRGdWxsU2NyZWVuQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2ZW5kb3IuRnVsbFNjcmVlbkNoYW5nZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbnZhciByZW1vdmVGdWxsU2NyZWVuQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih2ZW5kb3IuRnVsbFNjcmVlbkNoYW5nZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbnZhciBleGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlclxuICAgICAgICA/XG4gICAgICAgICAgICBlbGVtZW50W3ZlbmRvci5FeGl0RnVsbFNjcmVlbl0oKVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh7fSk7XG59O1xudmFyIGdldEZ1bGxTY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0Jyb3dzZXIgPyBkb2N1bWVudFt2ZW5kb3IuRnVsbFNjcmVlbkVsZW1lbnRdIDogbnVsbDtcbn07XG52YXIgcmVxdWVzdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgZWxlbWVudFt2ZW5kb3IuUmVxdWVzdEZ1bGxTY3JlZW5dKCk7XG4gICAgfVxufTtcblxudmFyIHVzZURlYm91bmNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHdhaXQpIHtcbiAgICB2YXIgdGltZW91dCA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0LmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwKCk7IH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgfSwgW2NhbGxiYWNrLCB3YWl0XSk7XG59O1xuXG52YXIgdXNlSXNNb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihmYWxzZSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gaXNNb3VudGVkUmVmO1xufTtcblxudmFyIHVzZVByZXZpb3VzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHZhbHVlKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcblxudmFyIFBhZ2VSZW5kZXJTdGF0dXM7XG4oZnVuY3Rpb24gKFBhZ2VSZW5kZXJTdGF0dXMpIHtcbiAgICBQYWdlUmVuZGVyU3RhdHVzW1wiTm90UmVuZGVyZWRZZXRcIl0gPSBcIk5vdFJlbmRlcmVkWWV0XCI7XG4gICAgUGFnZVJlbmRlclN0YXR1c1tcIlJlbmRlcmluZ1wiXSA9IFwiUmVuZGVyaW5nXCI7XG4gICAgUGFnZVJlbmRlclN0YXR1c1tcIlJlbmRlcmVkXCJdID0gXCJSZW5kZXJlZFwiO1xufSkoUGFnZVJlbmRlclN0YXR1cyB8fCAoUGFnZVJlbmRlclN0YXR1cyA9IHt9KSk7XG52YXIgT1VUX09GX1JBTkdFX1ZJU0lCSUxJVFkgPSAtOTk5OTtcbnZhciB1c2VSZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkb2MgPSBfYS5kb2M7XG4gICAgdmFyIG51bVBhZ2VzID0gZG9jLm51bVBhZ2VzO1xuICAgIHZhciBkb2NJZCA9IGRvYy5sb2FkaW5nVGFzay5kb2NJZDtcbiAgICB2YXIgaW5pdGlhbFBhZ2VWaXNpYmlsaXRpZXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkobnVtUGFnZXMpXG4gICAgICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoXywgcGFnZUluZGV4KSB7IHJldHVybiAoe1xuICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICByZW5kZXJTdGF0dXM6IFBhZ2VSZW5kZXJTdGF0dXMuTm90UmVuZGVyZWRZZXQsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBPVVRfT0ZfUkFOR0VfVklTSUJJTElUWSxcbiAgICAgICAgfSk7IH0pO1xuICAgIH0sIFtkb2NJZF0pO1xuICAgIHZhciBsYXRlc3RSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZih7XG4gICAgICAgIGN1cnJlbnRSZW5kZXJpbmdQYWdlOiAtMSxcbiAgICAgICAgc3RhcnRSYW5nZTogMCxcbiAgICAgICAgZW5kUmFuZ2U6IG51bVBhZ2VzIC0gMSxcbiAgICAgICAgdmlzaWJpbGl0aWVzOiBpbml0aWFsUGFnZVZpc2liaWxpdGllcyxcbiAgICB9KTtcbiAgICB2YXIgbWFya05vdFJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LnZpc2liaWxpdGllc1tpXS5yZW5kZXJTdGF0dXMgPSBQYWdlUmVuZGVyU3RhdHVzLk5vdFJlbmRlcmVkWWV0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgbWFya1JlbmRlcmVkID0gZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbcGFnZUluZGV4XS5yZW5kZXJTdGF0dXMgPSBQYWdlUmVuZGVyU3RhdHVzLlJlbmRlcmVkO1xuICAgIH07XG4gICAgdmFyIG1hcmtSZW5kZXJpbmcgPSBmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICAgIGlmIChsYXRlc3RSZWYuY3VycmVudC5jdXJyZW50UmVuZGVyaW5nUGFnZSAhPT0gLTEgJiZcbiAgICAgICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LmN1cnJlbnRSZW5kZXJpbmdQYWdlICE9PSBwYWdlSW5kZXggJiZcbiAgICAgICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LnZpc2liaWxpdGllc1tsYXRlc3RSZWYuY3VycmVudC5jdXJyZW50UmVuZGVyaW5nUGFnZV0ucmVuZGVyU3RhdHVzID09PVxuICAgICAgICAgICAgICAgIFBhZ2VSZW5kZXJTdGF0dXMuUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbbGF0ZXN0UmVmLmN1cnJlbnQuY3VycmVudFJlbmRlcmluZ1BhZ2VdLnJlbmRlclN0YXR1cyA9XG4gICAgICAgICAgICAgICAgUGFnZVJlbmRlclN0YXR1cy5Ob3RSZW5kZXJlZFlldDtcbiAgICAgICAgfVxuICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbcGFnZUluZGV4XS5yZW5kZXJTdGF0dXMgPSBQYWdlUmVuZGVyU3RhdHVzLlJlbmRlcmluZztcbiAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQuY3VycmVudFJlbmRlcmluZ1BhZ2UgPSBwYWdlSW5kZXg7XG4gICAgfTtcbiAgICB2YXIgc2V0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQuc3RhcnRSYW5nZSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LmVuZFJhbmdlID0gZW5kSW5kZXg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUGFnZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBzdGFydEluZGV4IHx8IGkgPiBlbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LnZpc2liaWxpdGllc1tpXS52aXNpYmlsaXR5ID0gT1VUX09GX1JBTkdFX1ZJU0lCSUxJVFk7XG4gICAgICAgICAgICAgICAgbGF0ZXN0UmVmLmN1cnJlbnQudmlzaWJpbGl0aWVzW2ldLnJlbmRlclN0YXR1cyA9IFBhZ2VSZW5kZXJTdGF0dXMuTm90UmVuZGVyZWRZZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzZXRPdXRPZlJhbmdlID0gZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgICBzZXRWaXNpYmlsaXR5KHBhZ2VJbmRleCwgT1VUX09GX1JBTkdFX1ZJU0lCSUxJVFkpO1xuICAgIH07XG4gICAgdmFyIHNldFZpc2liaWxpdHkgPSBmdW5jdGlvbiAocGFnZUluZGV4LCB2aXNpYmlsaXR5KSB7XG4gICAgICAgIGxhdGVzdFJlZi5jdXJyZW50LnZpc2liaWxpdGllc1twYWdlSW5kZXhdLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuICAgIH07XG4gICAgdmFyIGdldEhpZ2hlc3RQcmlvcml0eVBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2aXNpYmxlUGFnZXMgPSBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNcbiAgICAgICAgICAgIC5zbGljZShsYXRlc3RSZWYuY3VycmVudC5zdGFydFJhbmdlLCBsYXRlc3RSZWYuY3VycmVudC5lbmRSYW5nZSArIDEpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZpc2liaWxpdHkgPiBPVVRfT0ZfUkFOR0VfVklTSUJJTElUWTsgfSk7XG4gICAgICAgIGlmICghdmlzaWJsZVBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdFZpc2libGVQYWdlID0gdmlzaWJsZVBhZ2VzWzBdLnBhZ2VJbmRleDtcbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlUGFnZSA9IHZpc2libGVQYWdlc1t2aXNpYmxlUGFnZXMubGVuZ3RoIC0gMV0ucGFnZUluZGV4O1xuICAgICAgICB2YXIgbnVtVmlzaWJsZVBhZ2VzID0gdmlzaWJsZVBhZ2VzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WaXNpYmxlUGFnZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZpc2libGVQYWdlc1tpXS5yZW5kZXJTdGF0dXMgPT09IFBhZ2VSZW5kZXJTdGF0dXMuUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpc2libGVQYWdlc1tpXS5yZW5kZXJTdGF0dXMgPT09IFBhZ2VSZW5kZXJTdGF0dXMuTm90UmVuZGVyZWRZZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZVBhZ2VzW2ldLnBhZ2VJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFZpc2libGVQYWdlICsgMSA8IG51bVBhZ2VzICYmXG4gICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbbGFzdFZpc2libGVQYWdlICsgMV0ucmVuZGVyU3RhdHVzICE9PSBQYWdlUmVuZGVyU3RhdHVzLlJlbmRlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZpc2libGVQYWdlICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaXJzdFZpc2libGVQYWdlIC0gMSA+PSAwICYmXG4gICAgICAgICAgICBsYXRlc3RSZWYuY3VycmVudC52aXNpYmlsaXRpZXNbZmlyc3RWaXNpYmxlUGFnZSAtIDFdLnJlbmRlclN0YXR1cyAhPT0gUGFnZVJlbmRlclN0YXR1cy5SZW5kZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0VmlzaWJsZVBhZ2UgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIHZhciBpc0luUmFuZ2UgPSBmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBwYWdlSW5kZXggPj0gbGF0ZXN0UmVmLmN1cnJlbnQuc3RhcnRSYW5nZSAmJiBwYWdlSW5kZXggPD0gbGF0ZXN0UmVmLmN1cnJlbnQuZW5kUmFuZ2U7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRIaWdoZXN0UHJpb3JpdHlQYWdlOiBnZXRIaWdoZXN0UHJpb3JpdHlQYWdlLFxuICAgICAgICBpc0luUmFuZ2U6IGlzSW5SYW5nZSxcbiAgICAgICAgbWFya05vdFJlbmRlcmVkOiBtYXJrTm90UmVuZGVyZWQsXG4gICAgICAgIG1hcmtSZW5kZXJlZDogbWFya1JlbmRlcmVkLFxuICAgICAgICBtYXJrUmVuZGVyaW5nOiBtYXJrUmVuZGVyaW5nLFxuICAgICAgICBzZXRPdXRPZlJhbmdlOiBzZXRPdXRPZlJhbmdlLFxuICAgICAgICBzZXRSYW5nZTogc2V0UmFuZ2UsXG4gICAgICAgIHNldFZpc2liaWxpdHk6IHNldFZpc2liaWxpdHksXG4gICAgfTtcbn07XG5cbnZhciBjb3JlID0ge1xuXHRhc2tpbmdQYXNzd29yZDoge1xuXHRcdHJlcXVpcmVQYXNzd29yZFRvT3BlbjogXCJUaGlzIGRvY3VtZW50IHJlcXVpcmVzIGEgcGFzc3dvcmQgdG8gb3BlblwiLFxuXHRcdHN1Ym1pdDogXCJTdWJtaXRcIlxuXHR9LFxuXHR3cm9uZ1Bhc3N3b3JkOiB7XG5cdFx0dHJ5QWdhaW46IFwiVGhlIHBhc3N3b3JkIGlzIHdyb25nLiBQbGVhc2UgdHJ5IGFnYWluXCJcblx0fSxcblx0cGFnZUxhYmVsOiBcIlBhZ2Uge3twYWdlSW5kZXh9fVwiXG59O1xudmFyIGVuVXMgPSB7XG5cdGNvcmU6IGNvcmVcbn07XG5cbnZhciBEZWZhdWx0TG9jYWxpemF0aW9uID0gZW5VcztcbnZhciBMb2NhbGl6YXRpb25Db250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KHtcbiAgICBsMTBuOiBEZWZhdWx0TG9jYWxpemF0aW9uLFxuICAgIHNldEwxMG46IGZ1bmN0aW9uICgpIHsgfSxcbn0pO1xuXG52YXIgaWQgPSAwO1xudmFyIHVuaXF1ZUlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaWQrKzsgfTtcblxudmFyIHVzZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChjbG9zZU9uQ2xpY2tPdXRzaWRlLCB0YXJnZXRSZWYsIG9uQ2xpY2tPdXRzaWRlKSB7XG4gICAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xpY2tlZFRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoY2xpY2tlZFRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgY2xpY2tlZFRhcmdldC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA+IDAgJiYgIXRhcmdldC5jb250YWlucyhwYXRoc1swXSkpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrT3V0c2lkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0YXJnZXQuY29udGFpbnMoY2xpY2tlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tPdXRzaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjbG9zZU9uQ2xpY2tPdXRzaWRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyLCBldmVudE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcblxudmFyIHVzZUVzY2FwZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgdmFyIGtleVVwSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGtleVVwSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGtleVVwSGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcblxudmFyIHVzZUxvY2tTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLm92ZXJmbG93O1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3JpZ2luYWxTdHlsZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59O1xuXG52YXIgTW9kYWxCb2R5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFyaWFDb250cm9sc1N1ZmZpeCA9IF9hLmFyaWFDb250cm9sc1N1ZmZpeCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xvc2VPbkNsaWNrT3V0c2lkZSA9IF9hLmNsb3NlT25DbGlja091dHNpZGUsIGNsb3NlT25Fc2NhcGUgPSBfYS5jbG9zZU9uRXNjYXBlLCBvblRvZ2dsZSA9IF9hLm9uVG9nZ2xlO1xuICAgIHZhciBjb250ZW50UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHVzZUxvY2tTY3JvbGwoKTtcbiAgICB1c2VFc2NhcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGVudFJlZi5jdXJyZW50ICYmIGNsb3NlT25Fc2NhcGUpIHtcbiAgICAgICAgICAgIG9uVG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VDbGlja091dHNpZGUoY2xvc2VPbkNsaWNrT3V0c2lkZSwgY29udGVudFJlZiwgb25Ub2dnbGUpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGVudEVsZSA9IGNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250ZW50RWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heEhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0ICogMC43NTtcbiAgICAgICAgaWYgKGNvbnRlbnRFbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID49IG1heEhlaWdodCkge1xuICAgICAgICAgICAgY29udGVudEVsZS5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIGNvbnRlbnRFbGUuc3R5bGUubWF4SGVpZ2h0ID0gXCJcIi5jb25jYXQobWF4SGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19tb2RhbC1ib2R5JzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fbW9kYWwtYm9keS0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pLCBpZDogXCJycHYtY29yZV9fbW9kYWwtYm9keS1cIi5jb25jYXQoYXJpYUNvbnRyb2xzU3VmZml4KSwgcmVmOiBjb250ZW50UmVmLCByb2xlOiBcImRpYWxvZ1wiLCB0YWJJbmRleDogLTEgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBNb2RhbE92ZXJsYXkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19tb2RhbC1vdmVybGF5XCIgfSwgY2hpbGRyZW4pO1xufTtcblxuZXhwb3J0cy5Ub2dnbGVTdGF0dXMgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFRvZ2dsZVN0YXR1cykge1xuICAgIFRvZ2dsZVN0YXR1c1tcIkNsb3NlXCJdID0gXCJDbG9zZVwiO1xuICAgIFRvZ2dsZVN0YXR1c1tcIk9wZW5cIl0gPSBcIk9wZW5cIjtcbiAgICBUb2dnbGVTdGF0dXNbXCJUb2dnbGVcIl0gPSBcIlRvZ2dsZVwiO1xufSkoZXhwb3J0cy5Ub2dnbGVTdGF0dXMgfHwgKGV4cG9ydHMuVG9nZ2xlU3RhdHVzID0ge30pKTtcblxudmFyIHVzZVRvZ2dsZSA9IGZ1bmN0aW9uIChpc09wZW5lZCkge1xuICAgIHZhciBfYSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoaXNPcGVuZWQpLCBvcGVuZWQgPSBfYVswXSwgc2V0T3BlbmVkID0gX2FbMV07XG4gICAgdmFyIHRvZ2dsZSA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2dnbGVTdGF0dXMuQ2xvc2U6XG4gICAgICAgICAgICAgICAgc2V0T3BlbmVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2dnbGVTdGF0dXMuT3BlbjpcbiAgICAgICAgICAgICAgICBzZXRPcGVuZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9nZ2xlU3RhdHVzLlRvZ2dsZTpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc2V0T3BlbmVkKGZ1bmN0aW9uIChpc09wZW5lZCkgeyByZXR1cm4gIWlzT3BlbmVkOyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgb3BlbmVkOiBvcGVuZWQsIHRvZ2dsZTogdG9nZ2xlIH07XG59O1xuXG52YXIgUG9ydGFsID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBfYS5jb250ZW50LCBfYiA9IF9hLmlzT3BlbmVkLCBpc09wZW5lZCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgdmFyIF9jID0gdXNlVG9nZ2xlKGlzT3BlbmVkKSwgb3BlbmVkID0gX2Mub3BlbmVkLCB0b2dnbGUgPSBfYy50b2dnbGU7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgdGFyZ2V0ICYmIHRhcmdldCh0b2dnbGUsIG9wZW5lZCksXG4gICAgICAgIG9wZW5lZCAmJiBjb250ZW50KHRvZ2dsZSkpKTtcbn07XG5cbnZhciBNb2RhbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhcmlhQ29udHJvbHNTdWZmaXggPSBfYS5hcmlhQ29udHJvbHNTdWZmaXgsIGNsb3NlT25DbGlja091dHNpZGUgPSBfYS5jbG9zZU9uQ2xpY2tPdXRzaWRlLCBjbG9zZU9uRXNjYXBlID0gX2EuY2xvc2VPbkVzY2FwZSwgY29udGVudCA9IF9hLmNvbnRlbnQsIF9iID0gX2EuaXNPcGVuZWQsIGlzT3BlbmVkID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICB2YXIgY29udHJvbHNTdWZmaXggPSBhcmlhQ29udHJvbHNTdWZmaXggfHwgXCJcIi5jb25jYXQodW5pcXVlSWQoKSk7XG4gICAgdmFyIHJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICh0b2dnbGUsIG9wZW5lZCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1leHBhbmRlZFwiOiBvcGVuZWQgPyAndHJ1ZScgOiAnZmFsc2UnLCBcImFyaWEtaGFzcG9wdXBcIjogXCJkaWFsb2dcIiwgXCJhcmlhLWNvbnRyb2xzXCI6IFwicnB2LWNvcmVfX21vZGFsLWJvZHktXCIuY29uY2F0KGNvbnRyb2xzU3VmZml4KSB9LCB0YXJnZXQodG9nZ2xlLCBvcGVuZWQpKSk7IH07XG4gICAgdmFyIHJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAodG9nZ2xlKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE1vZGFsT3ZlcmxheSwgbnVsbCxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KE1vZGFsQm9keSwgeyBhcmlhQ29udHJvbHNTdWZmaXg6IGNvbnRyb2xzU3VmZml4LCBjbG9zZU9uQ2xpY2tPdXRzaWRlOiBjbG9zZU9uQ2xpY2tPdXRzaWRlLCBjbG9zZU9uRXNjYXBlOiBjbG9zZU9uRXNjYXBlLCBvblRvZ2dsZTogdG9nZ2xlIH0sIGNvbnRlbnQodG9nZ2xlKSkpKTsgfTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBvcnRhbCwgeyB0YXJnZXQ6IHRhcmdldCA/IHJlbmRlclRhcmdldCA6IG51bGwsIGNvbnRlbnQ6IHJlbmRlckNvbnRlbnQsIGlzT3BlbmVkOiBpc09wZW5lZCB9KTtcbn07XG5cbmV4cG9ydHMuUG9zaXRpb24gPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgUG9zaXRpb25bXCJUb3BMZWZ0XCJdID0gXCJUT1BfTEVGVFwiO1xuICAgIFBvc2l0aW9uW1wiVG9wQ2VudGVyXCJdID0gXCJUT1BfQ0VOVEVSXCI7XG4gICAgUG9zaXRpb25bXCJUb3BSaWdodFwiXSA9IFwiVE9QX1JJR0hUXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodFRvcFwiXSA9IFwiUklHSFRfVE9QXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodENlbnRlclwiXSA9IFwiUklHSFRfQ0VOVEVSXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodEJvdHRvbVwiXSA9IFwiUklHSFRfQk9UVE9NXCI7XG4gICAgUG9zaXRpb25bXCJCb3R0b21MZWZ0XCJdID0gXCJCT1RUT01fTEVGVFwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tQ2VudGVyXCJdID0gXCJCT1RUT01fQ0VOVEVSXCI7XG4gICAgUG9zaXRpb25bXCJCb3R0b21SaWdodFwiXSA9IFwiQk9UVE9NX1JJR0hUXCI7XG4gICAgUG9zaXRpb25bXCJMZWZ0VG9wXCJdID0gXCJMRUZUX1RPUFwiO1xuICAgIFBvc2l0aW9uW1wiTGVmdENlbnRlclwiXSA9IFwiTEVGVF9DRU5URVJcIjtcbiAgICBQb3NpdGlvbltcIkxlZnRCb3R0b21cIl0gPSBcIkxFRlRfQk9UVE9NXCI7XG59KShleHBvcnRzLlBvc2l0aW9uIHx8IChleHBvcnRzLlBvc2l0aW9uID0ge30pKTtcblxudmFyIGNhbGN1bGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnQsIHRhcmdldCwgcG9zaXRpb24sIG9mZnNldCkge1xuICAgIHZhciB0YXJnZXRSZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGhlaWdodCA9IGNvbnRlbnRSZWN0LmhlaWdodCwgd2lkdGggPSBjb250ZW50UmVjdC53aWR0aDtcbiAgICB2YXIgdG9wID0gMDtcbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIGV4cG9ydHMuUG9zaXRpb24uVG9wTGVmdDpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wIC0gaGVpZ2h0O1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUG9zaXRpb24uVG9wQ2VudGVyOlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgLSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAvIDIgLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLlRvcFJpZ2h0OlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgLSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAtIHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5SaWdodFRvcDpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wO1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLlJpZ2h0Q2VudGVyOlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgKyB0YXJnZXRSZWN0LmhlaWdodCAvIDIgLSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLlJpZ2h0Qm90dG9tOlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgKyB0YXJnZXRSZWN0LmhlaWdodCAtIGhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Qb3NpdGlvbi5Cb3R0b21MZWZ0OlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgKyB0YXJnZXRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLkJvdHRvbUNlbnRlcjpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCAvIDIgLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLkJvdHRvbVJpZ2h0OlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0UmVjdC50b3AgKyB0YXJnZXRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoIC0gd2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBleHBvcnRzLlBvc2l0aW9uLkxlZnRUb3A6XG4gICAgICAgICAgICB0b3AgPSB0YXJnZXRSZWN0LnRvcDtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgLSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUG9zaXRpb24uTGVmdENlbnRlcjpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgLSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUG9zaXRpb24uTGVmdEJvdHRvbTpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldFJlY3QudG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0IC0gd2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCArIChvZmZzZXQubGVmdCB8fCAwKSxcbiAgICAgICAgdG9wOiB0b3AgKyAob2Zmc2V0LnRvcCB8fCAwKSxcbiAgICB9O1xufTtcblxudmFyIHVzZVBvc2l0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnRSZWYsIHRhcmdldFJlZiwgYW5jaG9yUmVmLCBwb3NpdGlvbiwgb2Zmc2V0KSB7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXJnZXRFbGUgPSB0YXJnZXRSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGNvbnRlbnRFbGUgPSBjb250ZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBhbmNob3JFbGUgPSBhbmNob3JSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250ZW50RWxlIHx8ICF0YXJnZXRFbGUgfHwgIWFuY2hvckVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmNob3JSZWN0ID0gYW5jaG9yRWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgX2EgPSBjYWxjdWxhdGVQb3NpdGlvbihjb250ZW50RWxlLCB0YXJnZXRFbGUsIHBvc2l0aW9uLCBvZmZzZXQpLCB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0O1xuICAgICAgICBjb250ZW50RWxlLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHRvcCAtIGFuY2hvclJlY3QudG9wLCBcInB4XCIpO1xuICAgICAgICBjb250ZW50RWxlLnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChsZWZ0IC0gYW5jaG9yUmVjdC5sZWZ0LCBcInB4XCIpO1xuICAgIH0sIFtdKTtcbn07XG5cbnZhciBBcnJvdyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgY3VzdG9tQ2xhc3NOYW1lID0gX2EuY3VzdG9tQ2xhc3NOYW1lLCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKChfYiA9IHtcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93LS10bCc6IHBvc2l0aW9uID09PSBleHBvcnRzLlBvc2l0aW9uLlRvcExlZnQsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tdGMnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5Ub3BDZW50ZXIsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tdHInOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5Ub3BSaWdodCxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93LS1ydCc6IHBvc2l0aW9uID09PSBleHBvcnRzLlBvc2l0aW9uLlJpZ2h0VG9wLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLXJjJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uUmlnaHRDZW50ZXIsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tcmInOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5SaWdodEJvdHRvbSxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93LS1ibCc6IHBvc2l0aW9uID09PSBleHBvcnRzLlBvc2l0aW9uLkJvdHRvbUxlZnQsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tYmMnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5Cb3R0b21DZW50ZXIsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tYnInOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5Cb3R0b21SaWdodCxcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fycm93LS1sdCc6IHBvc2l0aW9uID09PSBleHBvcnRzLlBvc2l0aW9uLkxlZnRUb3AsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hcnJvdy0tbGMnOiBwb3NpdGlvbiA9PT0gZXhwb3J0cy5Qb3NpdGlvbi5MZWZ0Q2VudGVyLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXJyb3ctLWxiJzogcG9zaXRpb24gPT09IGV4cG9ydHMuUG9zaXRpb24uTGVmdEJvdHRvbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iW1wiXCIuY29uY2F0KGN1c3RvbUNsYXNzTmFtZSldID0gY3VzdG9tQ2xhc3NOYW1lICE9PSAnJyxcbiAgICAgICAgICAgIF9iKSkgfSkpO1xufTtcblxudmFyIFBvcG92ZXJCb2R5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFyaWFDb250cm9sc1N1ZmZpeCA9IF9hLmFyaWFDb250cm9sc1N1ZmZpeCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xvc2VPbkNsaWNrT3V0c2lkZSA9IF9hLmNsb3NlT25DbGlja091dHNpZGUsIG9mZnNldCA9IF9hLm9mZnNldCwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgdGFyZ2V0UmVmID0gX2EudGFyZ2V0UmVmLCBvbkNsb3NlID0gX2Eub25DbG9zZTtcbiAgICB2YXIgY29udGVudFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGlubmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgYW5jaG9yUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCkuZGlyZWN0aW9uO1xuICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHVzZUNsaWNrT3V0c2lkZShjbG9zZU9uQ2xpY2tPdXRzaWRlLCBjb250ZW50UmVmLCBvbkNsb3NlKTtcbiAgICB1c2VQb3NpdGlvbihjb250ZW50UmVmLCB0YXJnZXRSZWYsIGFuY2hvclJlZiwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lckNvbnRlbnRFbGUgPSBpbm5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWlubmVyQ29udGVudEVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCAqIDAuNzU7XG4gICAgICAgIGlmIChpbm5lckNvbnRlbnRFbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID49IG1heEhlaWdodCkge1xuICAgICAgICAgICAgaW5uZXJDb250ZW50RWxlLnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgICAgICAgICAgaW5uZXJDb250ZW50RWxlLnN0eWxlLm1heEhlaWdodCA9IFwiXCIuY29uY2F0KG1heEhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB2YXIgaW5uZXJJZCA9IFwicnB2LWNvcmVfX3BvcG92ZXItYm9keS1pbm5lci1cIi5jb25jYXQoYXJpYUNvbnRyb2xzU3VmZml4KTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGFuY2hvclJlZiwgc3R5bGU6IHsgbGVmdDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogMCB9IH0pLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtZGVzY3JpYmVkYnlcIjogaW5uZXJJZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX3BvcG92ZXItYm9keSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19wb3BvdmVyLWJvZHktLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgfSksIGlkOiBcInJwdi1jb3JlX19wb3BvdmVyLWJvZHktXCIuY29uY2F0KGFyaWFDb250cm9sc1N1ZmZpeCksIHJlZjogY29udGVudFJlZiwgcm9sZTogXCJkaWFsb2dcIiwgdGFiSW5kZXg6IC0xIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXJyb3csIHsgY3VzdG9tQ2xhc3NOYW1lOiBcInJwdi1jb3JlX19wb3BvdmVyLWJvZHktYXJyb3dcIiwgcG9zaXRpb246IHBvc2l0aW9uIH0pLFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGlubmVySWQsIHJlZjogaW5uZXJSZWYgfSwgY2hpbGRyZW4pKSkpO1xufTtcblxudmFyIFBvcG92ZXJPdmVybGF5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNsb3NlT25Fc2NhcGUgPSBfYS5jbG9zZU9uRXNjYXBlLCBvbkNsb3NlID0gX2Eub25DbG9zZTtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB1c2VFc2NhcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQgJiYgY2xvc2VPbkVzY2FwZSkge1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fcG9wb3Zlci1vdmVybGF5XCIsIHJlZjogY29udGFpbmVyUmVmIH0pO1xufTtcblxudmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5hcmlhSGFzUG9wdXAsIGFyaWFIYXNQb3B1cCA9IF9iID09PSB2b2lkIDAgPyAnZGlhbG9nJyA6IF9iLCBhcmlhQ29udHJvbHNTdWZmaXggPSBfYS5hcmlhQ29udHJvbHNTdWZmaXgsIGNsb3NlT25DbGlja091dHNpZGUgPSBfYS5jbG9zZU9uQ2xpY2tPdXRzaWRlLCBjbG9zZU9uRXNjYXBlID0gX2EuY2xvc2VPbkVzY2FwZSwgY29udGVudCA9IF9hLmNvbnRlbnQsIF9jID0gX2EubG9ja1Njcm9sbCwgbG9ja1Njcm9sbCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIG9mZnNldCA9IF9hLm9mZnNldCwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgIHZhciBfZCA9IHVzZVRvZ2dsZShmYWxzZSksIG9wZW5lZCA9IF9kLm9wZW5lZCwgdG9nZ2xlID0gX2QudG9nZ2xlO1xuICAgIHZhciB0YXJnZXRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBjb250cm9sc1N1ZmZpeCA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmlhQ29udHJvbHNTdWZmaXggfHwgXCJcIi5jb25jYXQodW5pcXVlSWQoKSk7IH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGFyZ2V0UmVmLCBcImFyaWEtZXhwYW5kZWRcIjogb3BlbmVkID8gJ3RydWUnIDogJ2ZhbHNlJywgXCJhcmlhLWhhc3BvcHVwXCI6IGFyaWFIYXNQb3B1cCwgXCJhcmlhLWNvbnRyb2xzXCI6IFwicnB2LWNvcmVfX3BvcHZlci1ib2R5LVwiLmNvbmNhdChjb250cm9sc1N1ZmZpeCkgfSxcbiAgICAgICAgdGFyZ2V0KHRvZ2dsZSwgb3BlbmVkKSxcbiAgICAgICAgb3BlbmVkICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIGxvY2tTY3JvbGwgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBvcG92ZXJPdmVybGF5LCB7IGNsb3NlT25Fc2NhcGU6IGNsb3NlT25Fc2NhcGUsIG9uQ2xvc2U6IHRvZ2dsZSB9KSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3BvdmVyQm9keSwgeyBhcmlhQ29udHJvbHNTdWZmaXg6IGNvbnRyb2xzU3VmZml4LCBjbG9zZU9uQ2xpY2tPdXRzaWRlOiBjbG9zZU9uQ2xpY2tPdXRzaWRlLCBvZmZzZXQ6IG9mZnNldCwgcG9zaXRpb246IHBvc2l0aW9uLCB0YXJnZXRSZWY6IHRhcmdldFJlZiwgb25DbG9zZTogdG9nZ2xlIH0sIGNvbnRlbnQodG9nZ2xlKSkpKSkpO1xufTtcblxudmFyIFRvb2x0aXBCb2R5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFyaWFDb250cm9sc1N1ZmZpeCA9IF9hLmFyaWFDb250cm9sc1N1ZmZpeCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY29udGVudFJlZiA9IF9hLmNvbnRlbnRSZWYsIG9mZnNldCA9IF9hLm9mZnNldCwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgdGFyZ2V0UmVmID0gX2EudGFyZ2V0UmVmO1xuICAgIHZhciBhbmNob3JSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdXNlUG9zaXRpb24oY29udGVudFJlZiwgdGFyZ2V0UmVmLCBhbmNob3JSZWYsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYW5jaG9yUmVmLCBzdHlsZTogeyBsZWZ0OiAwLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAwIH0gfSksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX190b29sdGlwLWJvZHknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fdG9vbHRpcC1ib2R5LS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgIH0pLCBpZDogXCJycHYtY29yZV9fdG9vbHRpcC1ib2R5LVwiLmNvbmNhdChhcmlhQ29udHJvbHNTdWZmaXgpLCByZWY6IGNvbnRlbnRSZWYsIHJvbGU6IFwidG9vbHRpcFwiIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXJyb3csIHsgY3VzdG9tQ2xhc3NOYW1lOiBcInJwdi1jb3JlX190b29sdGlwLWJvZHktYXJyb3dcIiwgcG9zaXRpb246IHBvc2l0aW9uIH0pLFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX190b29sdGlwLWJvZHktY29udGVudFwiIH0sIGNoaWxkcmVuKSkpKTtcbn07XG5cbnZhciBUb29sdGlwID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFyaWFDb250cm9sc1N1ZmZpeCA9IF9hLmFyaWFDb250cm9sc1N1ZmZpeCwgY29udGVudCA9IF9hLmNvbnRlbnQsIG9mZnNldCA9IF9hLm9mZnNldCwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgIHZhciBfYiA9IHVzZVRvZ2dsZShmYWxzZSksIG9wZW5lZCA9IF9iLm9wZW5lZCwgdG9nZ2xlID0gX2IudG9nZ2xlO1xuICAgIHZhciB0YXJnZXRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBjb250ZW50UmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgY29udHJvbHNTdWZmaXggPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJpYUNvbnRyb2xzU3VmZml4IHx8IFwiXCIuY29uY2F0KHVuaXF1ZUlkKCkpOyB9LCBbXSk7XG4gICAgdXNlRXNjYXBlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhcmdldFJlZi5jdXJyZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgdGFyZ2V0UmVmLmN1cnJlbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9nZ2xlKGV4cG9ydHMuVG9nZ2xlU3RhdHVzLk9wZW4pO1xuICAgIH07XG4gICAgdmFyIGNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0b2dnbGUoZXhwb3J0cy5Ub2dnbGVTdGF0dXMuQ2xvc2UpO1xuICAgIH07XG4gICAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBzaG91bGRIaWRlVG9vbHRpcCA9IGUucmVsYXRlZFRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQucGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnBhcmVudEVsZW1lbnQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgaWYgKHNob3VsZEhpZGVUb29sdGlwKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGVudFJlZi5jdXJyZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRhcmdldFJlZiwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IFwicnB2LWNvcmVfX3Rvb2x0aXAtYm9keS1cIi5jb25jYXQoY29udHJvbHNTdWZmaXgpLCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb3Blbiwgb25Nb3VzZUVudGVyOiBvcGVuLCBvbk1vdXNlTGVhdmU6IGNsb3NlIH0sIHRhcmdldCksXG4gICAgICAgIG9wZW5lZCAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFRvb2x0aXBCb2R5LCB7IGFyaWFDb250cm9sc1N1ZmZpeDogY29udHJvbHNTdWZmaXgsIGNvbnRlbnRSZWY6IGNvbnRlbnRSZWYsIG9mZnNldDogb2Zmc2V0LCBwb3NpdGlvbjogcG9zaXRpb24sIHRhcmdldFJlZjogdGFyZ2V0UmVmIH0sIGNvbnRlbnQoKSkpKSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSBpbml0aWFsU3RhdGUgfHwge307XG4gICAgdmFyIGxpc3RlbmVycyA9IHt9O1xuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3RhdGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCAoX2EgPSB7fSwgX2Fba2V5XSA9IGRhdGEsIF9hKSk7XG4gICAgICAgIChsaXN0ZW5lcnNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihzdGF0ZVtrZXldKTsgfSk7XG4gICAgfTtcbiAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc3RhdGVba2V5XTsgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChrZXksIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1trZXldID0gKGxpc3RlbmVyc1trZXldIHx8IFtdKS5jb25jYXQoaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoa2V5LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNba2V5XSA9IChsaXN0ZW5lcnNba2V5XSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmICE9PSBoYW5kbGVyOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XG4gICAgICAgICAgICB1cGRhdGUoa2V5LCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ3VycmVudFZhbHVlOiBmdW5jdGlvbiAoa2V5LCB1cGRhdGVyKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUoa2V5LCB1cGRhdGVyKGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQoa2V5KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5leHBvcnRzLkZ1bGxTY3JlZW5Nb2RlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChGdWxsU2NyZWVuTW9kZSkge1xuICAgIEZ1bGxTY3JlZW5Nb2RlW1wiTm9ybWFsXCJdID0gXCJOb3JtYWxcIjtcbiAgICBGdWxsU2NyZWVuTW9kZVtcIkVudGVyaW5nXCJdID0gXCJFbnRlcmluZ1wiO1xuICAgIEZ1bGxTY3JlZW5Nb2RlW1wiRW50ZXJlZFwiXSA9IFwiRW50ZXJlZFwiO1xuICAgIEZ1bGxTY3JlZW5Nb2RlW1wiRW50ZXJlZENvbXBsZXRlbHlcIl0gPSBcIkVudGVyZWRDb21wbGV0ZWx5XCI7XG4gICAgRnVsbFNjcmVlbk1vZGVbXCJFeGl0dGluZ1wiXSA9IFwiRXhpdHRpbmdcIjtcbiAgICBGdWxsU2NyZWVuTW9kZVtcIkV4aXRlZFwiXSA9IFwiRXhpdGVkXCI7XG59KShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlIHx8IChleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlID0ge30pKTtcblxuZXhwb3J0cy5MYXllclJlbmRlclN0YXR1cyA9IHZvaWQgMDtcbihmdW5jdGlvbiAoTGF5ZXJSZW5kZXJTdGF0dXMpIHtcbiAgICBMYXllclJlbmRlclN0YXR1c1tMYXllclJlbmRlclN0YXR1c1tcIlByZVJlbmRlclwiXSA9IDBdID0gXCJQcmVSZW5kZXJcIjtcbiAgICBMYXllclJlbmRlclN0YXR1c1tMYXllclJlbmRlclN0YXR1c1tcIkRpZFJlbmRlclwiXSA9IDFdID0gXCJEaWRSZW5kZXJcIjtcbn0pKGV4cG9ydHMuTGF5ZXJSZW5kZXJTdGF0dXMgfHwgKGV4cG9ydHMuTGF5ZXJSZW5kZXJTdGF0dXMgPSB7fSkpO1xuXG5leHBvcnRzLlBhZ2VNb2RlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChQYWdlTW9kZSkge1xuICAgIFBhZ2VNb2RlW1wiQXR0YWNobWVudHNcIl0gPSBcIlVzZUF0dGFjaG1lbnRzXCI7XG4gICAgUGFnZU1vZGVbXCJCb29rbWFya3NcIl0gPSBcIlVzZU91dGxpbmVzXCI7XG4gICAgUGFnZU1vZGVbXCJDb250ZW50R3JvdXBcIl0gPSBcIlVzZU9DXCI7XG4gICAgUGFnZU1vZGVbXCJEZWZhdWx0XCJdID0gXCJVc2VyTm9uZVwiO1xuICAgIFBhZ2VNb2RlW1wiRnVsbFNjcmVlblwiXSA9IFwiRnVsbFNjcmVlblwiO1xuICAgIFBhZ2VNb2RlW1wiVGh1bWJuYWlsc1wiXSA9IFwiVXNlVGh1bWJzXCI7XG59KShleHBvcnRzLlBhZ2VNb2RlIHx8IChleHBvcnRzLlBhZ2VNb2RlID0ge30pKTtcblxuZXhwb3J0cy5QYXNzd29yZFN0YXR1cyA9IHZvaWQgMDtcbihmdW5jdGlvbiAoUGFzc3dvcmRTdGF0dXMpIHtcbiAgICBQYXNzd29yZFN0YXR1c1tcIlJlcXVpcmVkUGFzc3dvcmRcIl0gPSBcIlJlcXVpcmVkUGFzc3dvcmRcIjtcbiAgICBQYXNzd29yZFN0YXR1c1tcIldyb25nUGFzc3dvcmRcIl0gPSBcIldyb25nUGFzc3dvcmRcIjtcbn0pKGV4cG9ydHMuUGFzc3dvcmRTdGF0dXMgfHwgKGV4cG9ydHMuUGFzc3dvcmRTdGF0dXMgPSB7fSkpO1xuXG5leHBvcnRzLlJvdGF0ZURpcmVjdGlvbiA9IHZvaWQgMDtcbihmdW5jdGlvbiAoUm90YXRlRGlyZWN0aW9uKSB7XG4gICAgUm90YXRlRGlyZWN0aW9uW1wiQmFja3dhcmRcIl0gPSBcIkJhY2t3YXJkXCI7XG4gICAgUm90YXRlRGlyZWN0aW9uW1wiRm9yd2FyZFwiXSA9IFwiRm9yd2FyZFwiO1xufSkoZXhwb3J0cy5Sb3RhdGVEaXJlY3Rpb24gfHwgKGV4cG9ydHMuUm90YXRlRGlyZWN0aW9uID0ge30pKTtcblxuZXhwb3J0cy5TY3JvbGxNb2RlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChTY3JvbGxNb2RlKSB7XG4gICAgU2Nyb2xsTW9kZVtcIlBhZ2VcIl0gPSBcIlBhZ2VcIjtcbiAgICBTY3JvbGxNb2RlW1wiSG9yaXpvbnRhbFwiXSA9IFwiSG9yaXpvbnRhbFwiO1xuICAgIFNjcm9sbE1vZGVbXCJWZXJ0aWNhbFwiXSA9IFwiVmVydGljYWxcIjtcbiAgICBTY3JvbGxNb2RlW1wiV3JhcHBlZFwiXSA9IFwiV3JhcHBlZFwiO1xufSkoZXhwb3J0cy5TY3JvbGxNb2RlIHx8IChleHBvcnRzLlNjcm9sbE1vZGUgPSB7fSkpO1xuXG5leHBvcnRzLlNwZWNpYWxab29tTGV2ZWwgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFNwZWNpYWxab29tTGV2ZWwpIHtcbiAgICBTcGVjaWFsWm9vbUxldmVsW1wiQWN0dWFsU2l6ZVwiXSA9IFwiQWN0dWFsU2l6ZVwiO1xuICAgIFNwZWNpYWxab29tTGV2ZWxbXCJQYWdlRml0XCJdID0gXCJQYWdlRml0XCI7XG4gICAgU3BlY2lhbFpvb21MZXZlbFtcIlBhZ2VXaWR0aFwiXSA9IFwiUGFnZVdpZHRoXCI7XG59KShleHBvcnRzLlNwZWNpYWxab29tTGV2ZWwgfHwgKGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbCA9IHt9KSk7XG5cbmV4cG9ydHMuVmlld01vZGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFZpZXdNb2RlKSB7XG4gICAgVmlld01vZGVbXCJEdWFsUGFnZVwiXSA9IFwiRHVhbFBhZ2VcIjtcbiAgICBWaWV3TW9kZVtcIkR1YWxQYWdlV2l0aENvdmVyXCJdID0gXCJEdWFsUGFnZVdpdGhDb3ZlclwiO1xuICAgIFZpZXdNb2RlW1wiU2luZ2xlUGFnZVwiXSA9IFwiU2luZ2xlUGFnZVwiO1xufSkoZXhwb3J0cy5WaWV3TW9kZSB8fCAoZXhwb3J0cy5WaWV3TW9kZSA9IHt9KSk7XG5cbnZhciBjaHVuayA9IGZ1bmN0aW9uIChhcnIsIHNpemUpIHtcbiAgICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlLCBpKSB7IHJldHVybiAoaSAlIHNpemUgPyBhY2NbYWNjLmxlbmd0aCAtIDFdLnB1c2goZSkgOiBhY2MucHVzaChbZV0pLCBhY2MpOyB9LCBbXSk7XG59O1xuXG52YXIgaXNNYWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAvKE1hY3xpUGhvbmV8aVBvZHxpUGFkKS9pLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlKTsgfTtcblxudmFyIG5vcm1hbGl6ZURlc3RpbmF0aW9uID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgZGVzdEFycmF5KSB7XG4gICAgc3dpdGNoIChkZXN0QXJyYXlbMV0ubmFtZSkge1xuICAgICAgICBjYXNlICdYWVonOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib3R0b21PZmZzZXQ6IGZ1bmN0aW9uIChfLCB2aWV3cG9ydEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzdEFycmF5WzNdID09PSBudWxsID8gdmlld3BvcnRIZWlnaHQgOiBkZXN0QXJyYXlbM107XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0OiBmdW5jdGlvbiAoXywgX18pIHsgcmV0dXJuIChkZXN0QXJyYXlbMl0gPT09IG51bGwgPyAwIDogZGVzdEFycmF5WzJdKTsgfSxcbiAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICBzY2FsZVRvOiBkZXN0QXJyYXlbNF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdGaXQnOlxuICAgICAgICBjYXNlICdGaXRCJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm90dG9tT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgc2NhbGVUbzogZXhwb3J0cy5TcGVjaWFsWm9vbUxldmVsLlBhZ2VGaXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdGaXRIJzpcbiAgICAgICAgY2FzZSAnRml0QkgnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib3R0b21PZmZzZXQ6IGRlc3RBcnJheVsyXSxcbiAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgIHNjYWxlVG86IGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlV2lkdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBib3R0b21PZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgbGVmdE9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICBzY2FsZVRvOiAxLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIHBhZ2VPdXRsaW5lc01hcCA9IG5ldyBNYXAoKTtcbnZhciBwYWdlc01hcCA9IG5ldyBNYXAoKTtcbnZhciBnZW5lcmF0ZVJlZktleSA9IGZ1bmN0aW9uIChkb2MsIG91dGxpbmUpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoZG9jLmxvYWRpbmdUYXNrLmRvY0lkLCBcIl9fX1wiKS5jb25jYXQob3V0bGluZS5udW0sIFwiUlwiKS5jb25jYXQob3V0bGluZS5nZW4gPT09IDAgPyAnJyA6IG91dGxpbmUuZ2VuKTtcbn07XG52YXIgZ2V0UGFnZUluZGV4ID0gZnVuY3Rpb24gKGRvYywgb3V0bGluZSkge1xuICAgIHZhciBrZXkgPSBnZW5lcmF0ZVJlZktleShkb2MsIG91dGxpbmUpO1xuICAgIHJldHVybiBwYWdlT3V0bGluZXNNYXAuaGFzKGtleSkgPyBwYWdlT3V0bGluZXNNYXAuZ2V0KGtleSkgOiBudWxsO1xufTtcbnZhciBjYWNoZU91dGxpbmVSZWYgPSBmdW5jdGlvbiAoZG9jLCBvdXRsaW5lLCBwYWdlSW5kZXgpIHtcbiAgICBwYWdlT3V0bGluZXNNYXAuc2V0KGdlbmVyYXRlUmVmS2V5KGRvYywgb3V0bGluZSksIHBhZ2VJbmRleCk7XG59O1xudmFyIGNsZWFyUGFnZXNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYWdlT3V0bGluZXNNYXAuY2xlYXIoKTtcbiAgICBwYWdlc01hcC5jbGVhcigpO1xufTtcbnZhciBnZXRQYWdlID0gZnVuY3Rpb24gKGRvYywgcGFnZUluZGV4KSB7XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdUaGUgZG9jdW1lbnQgaXMgbm90IGxvYWRlZCB5ZXQnKTtcbiAgICB9XG4gICAgdmFyIHBhZ2VLZXkgPSBcIlwiLmNvbmNhdChkb2MubG9hZGluZ1Rhc2suZG9jSWQsIFwiX19fXCIpLmNvbmNhdChwYWdlSW5kZXgpO1xuICAgIHZhciBwYWdlID0gcGFnZXNNYXAuZ2V0KHBhZ2VLZXkpO1xuICAgIGlmIChwYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFnZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICBkb2MuZ2V0UGFnZShwYWdlSW5kZXggKyAxKS50aGVuKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICBwYWdlc01hcC5zZXQocGFnZUtleSwgcGFnZSk7XG4gICAgICAgICAgICBpZiAocGFnZS5yZWYpIHtcbiAgICAgICAgICAgICAgICBjYWNoZU91dGxpbmVSZWYoZG9jLCBwYWdlLnJlZiwgcGFnZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocGFnZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnZhciBnZXREZXN0aW5hdGlvbiA9IGZ1bmN0aW9uIChkb2MsIGRlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRvYy5nZXREZXN0aW5hdGlvbihkZXN0KS50aGVuKGZ1bmN0aW9uIChkZXN0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0QXJyYXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGVzdEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBkZXN0QXJyYXlbMF0gJiYgZGVzdEFycmF5WzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dGxpbmVSZWZfMSA9IGRlc3RBcnJheVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gZ2V0UGFnZUluZGV4KGRvYywgb3V0bGluZVJlZl8xKTtcbiAgICAgICAgICAgICAgICBpZiAocGFnZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvYy5nZXRQYWdlSW5kZXgob3V0bGluZVJlZl8xKS50aGVuKGZ1bmN0aW9uIChwYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlT3V0bGluZVJlZihkb2MsIG91dGxpbmVSZWZfMSwgcGFnZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldERlc3RpbmF0aW9uKGRvYywgZGVzdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXMocmVzdWx0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzKG5vcm1hbGl6ZURlc3RpbmF0aW9uKHBhZ2VJbmRleCwgZGVzdEFycmF5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG5vcm1hbGl6ZURlc3RpbmF0aW9uKGRlc3RBcnJheVswXSwgZGVzdEFycmF5KTtcbiAgICAgICAgICAgICAgICByZXModGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG52YXIgdXNlUnVuT25jZSA9IGZ1bmN0aW9uIChjYiwgY29uZGl0aW9uKSB7XG4gICAgdmFyIGlzQ2FsbGVkUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoZmFsc2UpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29uZGl0aW9uICYmICFpc0NhbGxlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpc0NhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9LCBbY2IsIGNvbmRpdGlvbl0pO1xufTtcblxudmFyIHVzZVRyYWNrUmVzaXplID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHRhcmdldFJlZiA9IF9hLnRhcmdldFJlZiwgb25SZXNpemUgPSBfYS5vblJlc2l6ZTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlvID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgb25SZXNpemUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRhcmdldFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlvLm9ic2VydmUoY29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlvLnVub2JzZXJ2ZShjb250YWluZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbnZhciBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlO1xuKGZ1bmN0aW9uIChBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlKSB7XG4gICAgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW1wiU29saWRcIl0gPSAxXSA9IFwiU29saWRcIjtcbiAgICBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW0Fubm90YXRpb25Cb3JkZXJTdHlsZVR5cGVbXCJEYXNoZWRcIl0gPSAyXSA9IFwiRGFzaGVkXCI7XG4gICAgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW1wiQmV2ZWxlZFwiXSA9IDNdID0gXCJCZXZlbGVkXCI7XG4gICAgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZVtBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW1wiSW5zZXRcIl0gPSA0XSA9IFwiSW5zZXRcIjtcbiAgICBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlW0Fubm90YXRpb25Cb3JkZXJTdHlsZVR5cGVbXCJVbmRlcmxpbmVcIl0gPSA1XSA9IFwiVW5kZXJsaW5lXCI7XG59KShBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlIHx8IChBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge30pKTtcblxudmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoJ15EOicgK1xuICAgICcoXFxcXGR7NH0pJyArXG4gICAgJyhcXFxcZHsyfSk/JyArXG4gICAgJyhcXFxcZHsyfSk/JyArXG4gICAgJyhcXFxcZHsyfSk/JyArXG4gICAgJyhcXFxcZHsyfSk/JyArXG4gICAgJyhcXFxcZHsyfSk/JyArXG4gICAgJyhbWnwrfC1dKT8nICtcbiAgICAnKFxcXFxkezJ9KT8nICtcbiAgICBcIic/XCIgK1xuICAgICcoXFxcXGR7Mn0pPycgK1xuICAgIFwiJz9cIik7XG52YXIgcGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4LCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICByZXR1cm4gcGFyc2VkID49IG1pbiAmJiBwYXJzZWQgPD0gbWF4ID8gcGFyc2VkIDogZGVmYXVsdFZhbHVlO1xufTtcbnZhciBjb252ZXJ0RGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBtYXRjaGVzID0gZGF0ZVJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgdmFyIG1vbnRoID0gcGFyc2UobWF0Y2hlc1syXSwgMSwgMTIsIDEpIC0gMTtcbiAgICB2YXIgZGF5ID0gcGFyc2UobWF0Y2hlc1szXSwgMSwgMzEsIDEpO1xuICAgIHZhciBob3VyID0gcGFyc2UobWF0Y2hlc1s0XSwgMCwgMjMsIDApO1xuICAgIHZhciBtaW51dGUgPSBwYXJzZShtYXRjaGVzWzVdLCAwLCA1OSwgMCk7XG4gICAgdmFyIHNlY29uZCA9IHBhcnNlKG1hdGNoZXNbNl0sIDAsIDU5LCAwKTtcbiAgICB2YXIgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCAnWic7XG4gICAgdmFyIG9mZnNldEhvdXIgPSBwYXJzZShtYXRjaGVzWzhdLCAwLCAyMywgMCk7XG4gICAgdmFyIG9mZnNldE1pbnV0ZSA9IHBhcnNlKG1hdGNoZXNbOV0sIDAsIDU5LCAwKTtcbiAgICBzd2l0Y2ggKHVuaXZlcnNhbFRpbWVSZWxhdGlvbikge1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIGhvdXIgKz0gb2Zmc2V0SG91cjtcbiAgICAgICAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBob3VyIC09IG9mZnNldEhvdXI7XG4gICAgICAgICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xufTtcblxudmFyIGdldENvbnRlbnRzID0gZnVuY3Rpb24gKGFubm90YXRpb24pIHtcbiAgICByZXR1cm4gYW5ub3RhdGlvbi5jb250ZW50c09iaiA/IGFubm90YXRpb24uY29udGVudHNPYmouc3RyIDogYW5ub3RhdGlvbi5jb250ZW50cyB8fCAnJztcbn07XG5cbnZhciBnZXRUaXRsZSA9IGZ1bmN0aW9uIChhbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuIGFubm90YXRpb24udGl0bGVPYmogPyBhbm5vdGF0aW9uLnRpdGxlT2JqLnN0ciA6IGFubm90YXRpb24udGl0bGUgfHwgJyc7XG59O1xuXG52YXIgUG9wdXBXcmFwcGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uO1xuICAgIHZhciBkaXJlY3Rpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KS5kaXJlY3Rpb247XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUnRsID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlRleHREaXJlY3Rpb24uUmlnaHRUb0xlZnQ7XG4gICAgdmFyIGNvbnRhaW5lclJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGRhdGVTdHIgPSAnJztcbiAgICBpZiAoYW5ub3RhdGlvbi5tb2RpZmljYXRpb25EYXRlKSB7XG4gICAgICAgIHZhciBkYXRlID0gY29udmVydERhdGUoYW5ub3RhdGlvbi5tb2RpZmljYXRpb25EYXRlKTtcbiAgICAgICAgZGF0ZVN0ciA9IGRhdGUgPyBcIlwiLmNvbmNhdChkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpLCBcIiwgXCIpLmNvbmNhdChkYXRlLnRvTG9jYWxlVGltZVN0cmluZygpKSA6ICcnO1xuICAgIH1cbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXJFbGUgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250YWluZXJFbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbkVsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1hbm5vdGF0aW9uLWlkPVxcXCJcIi5jb25jYXQoYW5ub3RhdGlvbi5pZCwgXCJcXFwiXVwiKSk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbkVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGUgPSBhbm5vdGF0aW9uRWxlO1xuICAgICAgICBlbGUuc3R5bGUuekluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbGUuc3R5bGUuekluZGV4ID0gXCJcIi5jb25jYXQocGFyc2VJbnQoZWxlLnN0eWxlLnpJbmRleCwgMTApIC0gMSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBjb250YWluZXJSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAncnB2LWNvcmVfX2Fubm90YXRpb24tcG9wdXAtd3JhcHBlcic6IHRydWUsXG4gICAgICAgICAgICAncnB2LWNvcmVfX2Fubm90YXRpb24tcG9wdXAtd3JhcHBlci0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pLCBzdHlsZToge1xuICAgICAgICAgICAgdG9wOiBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlID09PSBleHBvcnRzLkFubm90YXRpb25UeXBlLlBvcHVwID8gJycgOiAnMTAwJScsXG4gICAgICAgIH0gfSxcbiAgICAgICAgdGl0bGUgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hbm5vdGF0aW9uLXBvcHVwLXRpdGxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hbm5vdGF0aW9uLXBvcHVwLXRpdGxlLS1sdHInOiAhaXNSdGwsXG4gICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9fYW5ub3RhdGlvbi1wb3B1cC10aXRsZS0tcnRsJzogaXNSdGwsXG4gICAgICAgICAgICAgICAgfSkgfSwgdGl0bGUpLFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uLXBvcHVwLWRhdGVcIiB9LCBkYXRlU3RyKSkpLFxuICAgICAgICBjb250ZW50cyAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uLXBvcHVwLWNvbnRlbnRcIiB9LCBjb250ZW50cy5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSkpOyB9KSkpKSk7XG59O1xuXG52YXIgVG9nZ2xlUG9wdXBCeTtcbihmdW5jdGlvbiAoVG9nZ2xlUG9wdXBCeSkge1xuICAgIFRvZ2dsZVBvcHVwQnlbXCJDbGlja1wiXSA9IFwiQ2xpY2tcIjtcbiAgICBUb2dnbGVQb3B1cEJ5W1wiSG92ZXJcIl0gPSBcIkhvdmVyXCI7XG59KShUb2dnbGVQb3B1cEJ5IHx8IChUb2dnbGVQb3B1cEJ5ID0ge30pKTtcbnZhciB1c2VUb2dnbGVQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB1c2VUb2dnbGUoZmFsc2UpLCBvcGVuZWQgPSBfYS5vcGVuZWQsIHRvZ2dsZSA9IF9hLnRvZ2dsZTtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFRvZ2dsZVBvcHVwQnkuSG92ZXIpLCB0b2dnbGVQb3B1cEJ5ID0gX2JbMF0sIHNldFRvb2dsZVBvcHVwQnkgPSBfYlsxXTtcbiAgICB2YXIgdG9nZ2xlT25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0b2dnbGVQb3B1cEJ5KSB7XG4gICAgICAgICAgICBjYXNlIFRvZ2dsZVBvcHVwQnkuQ2xpY2s6XG4gICAgICAgICAgICAgICAgb3BlbmVkICYmIHNldFRvb2dsZVBvcHVwQnkoVG9nZ2xlUG9wdXBCeS5Ib3Zlcik7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKGV4cG9ydHMuVG9nZ2xlU3RhdHVzLlRvZ2dsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRvZ2dsZVBvcHVwQnkuSG92ZXI6XG4gICAgICAgICAgICAgICAgc2V0VG9vZ2xlUG9wdXBCeShUb2dnbGVQb3B1cEJ5LkNsaWNrKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUoZXhwb3J0cy5Ub2dnbGVTdGF0dXMuT3Blbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvcGVuT25Ib3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9nZ2xlUG9wdXBCeSA9PT0gVG9nZ2xlUG9wdXBCeS5Ib3ZlciAmJiB0b2dnbGUoZXhwb3J0cy5Ub2dnbGVTdGF0dXMuT3Blbik7XG4gICAgfTtcbiAgICB2YXIgY2xvc2VPbkhvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0b2dnbGVQb3B1cEJ5ID09PSBUb2dnbGVQb3B1cEJ5LkhvdmVyICYmIHRvZ2dsZShleHBvcnRzLlRvZ2dsZVN0YXR1cy5DbG9zZSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcGVuZWQ6IG9wZW5lZCxcbiAgICAgICAgY2xvc2VPbkhvdmVyOiBjbG9zZU9uSG92ZXIsXG4gICAgICAgIG9wZW5PbkhvdmVyOiBvcGVuT25Ib3ZlcixcbiAgICAgICAgdG9nZ2xlT25DbGljazogdG9nZ2xlT25DbGljayxcbiAgICB9O1xufTtcblxudmFyIEFubm90YXRpb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGlnbm9yZUJvcmRlciA9IF9hLmlnbm9yZUJvcmRlciwgaGFzUG9wdXAgPSBfYS5oYXNQb3B1cCwgaXNSZW5kZXJhYmxlID0gX2EuaXNSZW5kZXJhYmxlLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgcmVjdCA9IGFubm90YXRpb24ucmVjdDtcbiAgICB2YXIgX2IgPSB1c2VUb2dnbGVQb3B1cCgpLCBjbG9zZU9uSG92ZXIgPSBfYi5jbG9zZU9uSG92ZXIsIG9wZW5lZCA9IF9iLm9wZW5lZCwgb3Blbk9uSG92ZXIgPSBfYi5vcGVuT25Ib3ZlciwgdG9nZ2xlT25DbGljayA9IF9iLnRvZ2dsZU9uQ2xpY2s7XG4gICAgdmFyIG5vcm1hbGl6ZVJlY3QgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gW1xuICAgICAgICBNYXRoLm1pbihyWzBdLCByWzJdKSxcbiAgICAgICAgTWF0aC5taW4oclsxXSwgclszXSksXG4gICAgICAgIE1hdGgubWF4KHJbMF0sIHJbMl0pLFxuICAgICAgICBNYXRoLm1heChyWzFdLCByWzNdKSxcbiAgICBdOyB9O1xuICAgIHZhciBib3VuZCA9IG5vcm1hbGl6ZVJlY3QoW1xuICAgICAgICByZWN0WzBdLFxuICAgICAgICBwYWdlLnZpZXdbM10gKyBwYWdlLnZpZXdbMV0gLSByZWN0WzFdLFxuICAgICAgICByZWN0WzJdLFxuICAgICAgICBwYWdlLnZpZXdbM10gKyBwYWdlLnZpZXdbMV0gLSByZWN0WzNdLFxuICAgIF0pO1xuICAgIHZhciB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgIGJvcmRlclJhZGl1czogJycsXG4gICAgICAgIGJvcmRlclN0eWxlOiAnJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6ICcnLFxuICAgIH07XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgICAgc3dpdGNoIChhbm5vdGF0aW9uLmJvcmRlclN0eWxlLnN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuRGFzaGVkOlxuICAgICAgICAgICAgICAgIHN0eWxlcy5ib3JkZXJTdHlsZSA9ICdkYXNoZWQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNvbGlkOlxuICAgICAgICAgICAgICAgIHN0eWxlcy5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVW5kZXJsaW5lOlxuICAgICAgICAgICAgICAgIHN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b21TdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgICB9LCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJldmVsZWQ6XG4gICAgICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSW5zZXQ6XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICAgICAgc3R5bGVzLmJvcmRlcldpZHRoID0gXCJcIi5jb25jYXQoYm9yZGVyV2lkdGgsIFwicHhcIik7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uLmJvcmRlclN0eWxlLnN0eWxlICE9PSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVuZGVybGluZSkge1xuICAgICAgICAgICAgd2lkdGggPSB3aWR0aCAtIDIgKiBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIDIgKiBib3JkZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSBhbm5vdGF0aW9uLmJvcmRlclN0eWxlLCBob3Jpem9udGFsQ29ybmVyUmFkaXVzID0gX2MuaG9yaXpvbnRhbENvcm5lclJhZGl1cywgdmVydGljYWxDb3JuZXJSYWRpdXMgPSBfYy52ZXJ0aWNhbENvcm5lclJhZGl1cztcbiAgICAgICAgaWYgKGhvcml6b250YWxDb3JuZXJSYWRpdXMgPiAwIHx8IHZlcnRpY2FsQ29ybmVyUmFkaXVzID4gMCkge1xuICAgICAgICAgICAgc3R5bGVzLmJvcmRlclJhZGl1cyA9IFwiXCIuY29uY2F0KGhvcml6b250YWxDb3JuZXJSYWRpdXMsIFwicHggLyBcIikuY29uY2F0KHZlcnRpY2FsQ29ybmVyUmFkaXVzLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGFubm90YXRpb24uY29sb3JcbiAgICAgICAgICAgID8gKHN0eWxlcy5ib3JkZXJDb2xvciA9IFwicmdiKFwiLmNvbmNhdChhbm5vdGF0aW9uLmNvbG9yWzBdIHwgMCwgXCIsIFwiKS5jb25jYXQoYW5ub3RhdGlvbi5jb2xvclsxXSB8IDAsIFwiLCBcIikuY29uY2F0KGFubm90YXRpb24uY29sb3JbMl0gfCAwLCBcIilcIikpXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgKHN0eWxlcy5ib3JkZXJXaWR0aCA9ICcwJyk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIGlzUmVuZGVyYWJsZSAmJlxuICAgICAgICBjaGlsZHJlbih7XG4gICAgICAgICAgICBwb3B1cDoge1xuICAgICAgICAgICAgICAgIG9wZW5lZDogb3BlbmVkLFxuICAgICAgICAgICAgICAgIGNsb3NlT25Ib3ZlcjogY2xvc2VPbkhvdmVyLFxuICAgICAgICAgICAgICAgIG9wZW5PbkhvdmVyOiBvcGVuT25Ib3ZlcixcbiAgICAgICAgICAgICAgICB0b2dnbGVPbkNsaWNrOiB0b2dnbGVPbkNsaWNrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3Q6IHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KGJvdW5kWzBdLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdChib3VuZFsxXSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJtYXRyaXgoXCIuY29uY2F0KHZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKCcsJyksIFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCItXCIuY29uY2F0KGJvdW5kWzBdLCBcInB4IC1cIikuY29uY2F0KGJvdW5kWzFdLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICB9LCBzdHlsZXMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCBoYXNQb3B1cCAmJiBvcGVuZWQgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBvcHVwV3JhcHBlciwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uIH0pKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKSk7XG59O1xuXG52YXIgQ2FyZXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLWNhcmV0XCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBDaXJjbGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgcmVjdCA9IGFubm90YXRpb24ucmVjdDtcbiAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgdmFyIGJvcmRlcldpZHRoID0gYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLWNpcmNsZVwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCBcIi5jb25jYXQod2lkdGgsIFwiIFwiKS5jb25jYXQoaGVpZ2h0KSwgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBjeTogaGVpZ2h0IC8gMiwgZmlsbDogXCJub25lXCIsIHJ4OiB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIsIHJ5OiBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRoIHx8IDEgfSkpLFxuICAgICAgICBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBnZXRGaWxlTmFtZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICB2YXIgc3RyID0gdXJsLnNwbGl0KCcvJykucG9wKCk7XG4gICAgcmV0dXJuIHN0ciA/IHN0ci5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF0gOiB1cmw7XG59O1xuXG52YXIgZG93bmxvYWRGaWxlID0gZnVuY3Rpb24gKHVybCwgZGF0YSkge1xuICAgIHZhciBibG9iVXJsID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gJycgOiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiAnJyB9KSk7XG4gICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGluay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGxpbmsuaHJlZiA9IGJsb2JVcmwgfHwgdXJsO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGdldEZpbGVOYW1lKHVybCkpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbGluay5jbGljaygpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgaWYgKGJsb2JVcmwpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICB9XG59O1xuXG52YXIgRmlsZUF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlICYmICghIXRpdGxlIHx8ICEhY29udGVudHMpO1xuICAgIHZhciBkb3VibGVDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBhbm5vdGF0aW9uLmZpbGU7XG4gICAgICAgIGZpbGUgJiYgZG93bmxvYWRGaWxlKGZpbGUuZmlsZW5hbWUsIGZpbGUuY29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IHRydWUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1maWxlLWF0dGFjaG1lbnRcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Eb3VibGVDbGljazogZG91YmxlQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBGcmVlVGV4dCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IHRydWUsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tZnJlZS10ZXh0XCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBQb3B1cCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgaWdub3JlZFBhcmVudHMgPSBbJ0NpcmNsZScsICdJbmsnLCAnTGluZScsICdQb2x5Z29uJywgJ1BvbHlMaW5lJywgJ1NxdWFyZSddO1xuICAgIHZhciBoYXNQb3B1cCA9ICFhbm5vdGF0aW9uLnBhcmVudFR5cGUgfHwgaWdub3JlZFBhcmVudHMuaW5kZXhPZihhbm5vdGF0aW9uLnBhcmVudFR5cGUpICE9PSAtMTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9uLnBhcmVudElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1hbm5vdGF0aW9uLWlkPVxcXCJcIi5jb25jYXQoYW5ub3RhdGlvbi5wYXJlbnRJZCwgXCJcXFwiXVwiKSk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYW5ub3RhdGlvbi1pZD1cXFwiXCIuY29uY2F0KGFubm90YXRpb24uaWQsIFwiXFxcIl1cIikpO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCAhY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSBwYXJzZUZsb2F0KHBhcmVudC5zdHlsZS5sZWZ0KTtcbiAgICAgICAgdmFyIHRvcCA9IHBhcnNlRmxvYXQocGFyZW50LnN0eWxlLnRvcCkgKyBwYXJzZUZsb2F0KHBhcmVudC5zdHlsZS5oZWlnaHQpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KGxlZnQsIFwicHhcIik7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcIi1cIi5jb25jYXQobGVmdCwgXCJweCAtXCIpLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IGZhbHNlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXBvcHVwXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQgfSksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3B1cFdyYXBwZXIsIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiB9KSkpOyB9KSk7XG59O1xuXG52YXIgSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBjaGlsZEFubm90YXRpb24gPSBfYS5jaGlsZEFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgaGFzUXVhZFBvaW50cyA9IGFubm90YXRpb24ucXVhZFBvaW50cyAmJiBhbm5vdGF0aW9uLnF1YWRQb2ludHMubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzUXVhZFBvaW50cykge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uLnF1YWRQb2ludHMubWFwKGZ1bmN0aW9uIChxdWFkUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhbm5vdGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgcmVjdDogW3F1YWRQb2ludFsyXS54LCBxdWFkUG9pbnRbMl0ueSwgcXVhZFBvaW50WzFdLngsIHF1YWRQb2ludFsxXS55XSxcbiAgICAgICAgICAgICAgICBxdWFkUG9pbnRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgYW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uIChhbm4sIGluZGV4KSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEhpZ2hsaWdodCwgeyBrZXk6IGluZGV4LCBhbm5vdGF0aW9uOiBhbm4sIGNoaWxkQW5ub3RhdGlvbjogY2hpbGRBbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSkpOyB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1oaWdobGlnaHRcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksIHByb3BzLnNsb3QuY2hpbGRyZW4pLFxuICAgICAgICBjaGlsZEFubm90YXRpb24gJiZcbiAgICAgICAgICAgIGNoaWxkQW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZSA9PT0gZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5Qb3B1cCAmJlxuICAgICAgICAgICAgcHJvcHMucG9wdXAub3BlbmVkICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3B1cCwgeyBhbm5vdGF0aW9uOiBjaGlsZEFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9KSkpOyB9KSk7XG59O1xuXG52YXIgSW5rID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIHJlY3QgPSBhbm5vdGF0aW9uLnJlY3Q7XG4gICAgdmFyIHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1pbmtcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksXG4gICAgICAgIGFubm90YXRpb24uaW5rTGlzdHMgJiYgYW5ub3RhdGlvbi5pbmtMaXN0cy5sZW5ndGggJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodCksIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSB9LCBhbm5vdGF0aW9uLmlua0xpc3RzLm1hcChmdW5jdGlvbiAoaW5rTGlzdCwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IGtleTogaW5kZXgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRoIHx8IDEsIHBvaW50czogaW5rTGlzdC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIFwiXCIuY29uY2F0KGl0ZW0ueCAtIHJlY3RbMF0sIFwiLFwiKS5jb25jYXQocmVjdFszXSAtIGl0ZW0ueSk7IH0pLmpvaW4oJyAnKSB9KSk7IH0pKSksXG4gICAgICAgIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIExpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgcmVjdCA9IGFubm90YXRpb24ucmVjdDtcbiAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgdmFyIGJvcmRlcldpZHRoID0gYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLWxpbmVcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodCksIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBzdHJva2VXaWR0aDogYm9yZGVyV2lkdGggfHwgMSwgeDE6IHJlY3RbMl0gLSBhbm5vdGF0aW9uLmxpbmVDb29yZGluYXRlc1swXSwgeDI6IHJlY3RbMl0gLSBhbm5vdGF0aW9uLmxpbmVDb29yZGluYXRlc1syXSwgeTE6IHJlY3RbM10gLSBhbm5vdGF0aW9uLmxpbmVDb29yZGluYXRlc1sxXSwgeTI6IHJlY3RbM10gLSBhbm5vdGF0aW9uLmxpbmVDb29yZGluYXRlc1szXSB9KSksXG4gICAgICAgIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIElOVkFMSURfUFJPVE9DT0wgPSAvXihbXlxcd10qKShqYXZhc2NyaXB0fGRhdGF8dmJzY3JpcHQpL2ltO1xudmFyIEhUTUxfRU5USVRJRVMgPSAvJiMoXFx3KykoXlxcd3w7KT8vZztcbnZhciBDVFJMX0NIQVJTID0gL1tcXHUwMDAwLVxcdTAwMUZcXHUwMDdGLVxcdTAwOUZcXHUyMDAwLVxcdTIwMERcXHVGRUZGXS9naW07XG52YXIgVVJMX1NDSEVNRSA9IC9eKFteOl0rKTovZ207XG52YXIgZGVjb2RlSHRtbEVudGl0aWVzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FTlRJVElFUywgZnVuY3Rpb24gKF8sIGRlYykgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMpOyB9KTsgfTtcbnZhciBzYW5pdGl6ZVVybCA9IGZ1bmN0aW9uICh1cmwsIGRlZmF1bHRVcmwpIHtcbiAgICBpZiAoZGVmYXVsdFVybCA9PT0gdm9pZCAwKSB7IGRlZmF1bHRVcmwgPSAnYWJvdXQ6YmxhbmsnOyB9XG4gICAgdmFyIHJlc3VsdCA9IGRlY29kZUh0bWxFbnRpdGllcyh1cmwgfHwgJycpXG4gICAgICAgIC5yZXBsYWNlKENUUkxfQ0hBUlMsICcnKVxuICAgICAgICAudHJpbSgpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VXJsO1xuICAgIH1cbiAgICB2YXIgZmlyc3RDaGFyID0gcmVzdWx0WzBdO1xuICAgIGlmIChmaXJzdENoYXIgPT09ICcuJyB8fCBmaXJzdENoYXIgPT09ICcvJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgcGFyc2VkVXJsU2NoZW1lID0gcmVzdWx0Lm1hdGNoKFVSTF9TQ0hFTUUpO1xuICAgIGlmICghcGFyc2VkVXJsU2NoZW1lKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBzY2hlbWUgPSBwYXJzZWRVcmxTY2hlbWVbMF07XG4gICAgcmV0dXJuIElOVkFMSURfUFJPVE9DT0wudGVzdChzY2hlbWUpID8gZGVmYXVsdFVybCA6IHJlc3VsdDtcbn07XG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgYW5ub3RhdGlvbkNvbnRhaW5lclJlZiA9IF9hLmFubm90YXRpb25Db250YWluZXJSZWYsIGRvYyA9IF9hLmRvYywgb3V0bGluZXMgPSBfYS5vdXRsaW5lcywgcGFnZSA9IF9hLnBhZ2UsIHBhZ2VJbmRleCA9IF9hLnBhZ2VJbmRleCwgc2NhbGUgPSBfYS5zY2FsZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydCwgb25FeGVjdXRlTmFtZWRBY3Rpb24gPSBfYS5vbkV4ZWN1dGVOYW1lZEFjdGlvbiwgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uID0gX2Eub25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uLCBvbkp1bXBUb0Rlc3QgPSBfYS5vbkp1bXBUb0Rlc3Q7XG4gICAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciB0aXRsZSA9IG91dGxpbmVzICYmIG91dGxpbmVzLmxlbmd0aCAmJiBhbm5vdGF0aW9uLmRlc3QgJiYgdHlwZW9mIGFubm90YXRpb24uZGVzdCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyAoX2IgPSBvdXRsaW5lcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmRlc3QgPT09IGFubm90YXRpb24uZGVzdDsgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aXRsZVxuICAgICAgICA6ICcnO1xuICAgIHZhciBsaW5rID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhbm5vdGF0aW9uLmFjdGlvblxuICAgICAgICAgICAgPyBvbkV4ZWN1dGVOYW1lZEFjdGlvbihhbm5vdGF0aW9uLmFjdGlvbilcbiAgICAgICAgICAgIDogZ2V0RGVzdGluYXRpb24oZG9jLCBhbm5vdGF0aW9uLmRlc3QpLnRoZW4oZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQ29udGFpbmVyID0gYW5ub3RhdGlvbkNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGFubm90YXRpb25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eSgnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkxheWVyUmVjdCA9IGFubm90YXRpb25Db250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25Db250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2hlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd3aWR0aCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdE9mZnNldCA9IChsaW5rUmVjdC5sZWZ0IC0gYW5ub3RhdGlvbkxheWVyUmVjdC5sZWZ0KSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tT2Zmc2V0ID0gKGFubm90YXRpb25MYXllclJlY3QuYm90dG9tIC0gbGlua1JlY3QuYm90dG9tICsgbGlua1JlY3QuaGVpZ2h0KSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBvbkp1bXBGcm9tTGlua0Fubm90YXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tT2Zmc2V0OiBib3R0b21PZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0OiBsZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkp1bXBUb0Rlc3QodGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24udXJsIHx8IGFubm90YXRpb24uZGVzdCB8fCBhbm5vdGF0aW9uLmFjdGlvbiB8fCBhbm5vdGF0aW9uLnVuc2FmZVVybCk7XG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgaWYgKGFubm90YXRpb24udXJsIHx8IGFubm90YXRpb24udW5zYWZlVXJsKSB7XG4gICAgICAgIHZhciB0YXJnZXRVcmwgPSBzYW5pdGl6ZVVybChhbm5vdGF0aW9uLnVybCB8fCBhbm5vdGF0aW9uLnVuc2FmZVVybCwgJycpO1xuICAgICAgICBpZiAodGFyZ2V0VXJsKSB7XG4gICAgICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICAgICAgICAnZGF0YS10YXJnZXQnOiAnZXh0ZXJuYWwnLFxuICAgICAgICAgICAgICAgIGhyZWY6IHRhcmdldFVybCxcbiAgICAgICAgICAgICAgICByZWw6ICdub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93JyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGFubm90YXRpb24ubmV3V2luZG93ID8gJ19ibGFuaycgOiAnJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGFyZ2V0VXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICAgIGhyZWY6ICcnLFxuICAgICAgICAgICAgJ2RhdGEtYW5ub3RhdGlvbi1saW5rJzogYW5ub3RhdGlvbi5pZCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGxpbmssXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgICBhdHRycyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJzLCB7XG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRpdGxlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogZmFsc2UsIGlnbm9yZUJvcmRlcjogZmFsc2UsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tbGlua1wiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBcImRhdGEtdGVzdGlkXCI6IFwiY29yZV9fYW5ub3RhdGlvbi0tbGluay1cIi5jb25jYXQoYW5ub3RhdGlvbi5pZCkgfSksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oeyByZWY6IGVsZW1lbnRSZWYgfSwgYXR0cnMpKSkpOyB9KSk7XG59O1xuXG52YXIgUG9seWdvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHZhciByZWN0ID0gYW5ub3RhdGlvbi5yZWN0O1xuICAgIHZhciB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgIHZhciBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBhbm5vdGF0aW9uLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IHRydWUsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tcG9seWdvblwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSxcbiAgICAgICAgYW5ub3RhdGlvbi52ZXJ0aWNlcyAmJiBhbm5vdGF0aW9uLnZlcnRpY2VzLmxlbmd0aCAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCBcIi5jb25jYXQod2lkdGgsIFwiIFwiKS5jb25jYXQoaGVpZ2h0KSwgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwb2x5Z29uXCIsIHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBzdHJva2VXaWR0aDogYm9yZGVyV2lkdGggfHwgMSwgcG9pbnRzOiBhbm5vdGF0aW9uLnZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIFwiXCIuY29uY2F0KGl0ZW0ueCAtIHJlY3RbMF0sIFwiLFwiKS5jb25jYXQocmVjdFszXSAtIGl0ZW0ueSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJykgfSkpKSxcbiAgICAgICAgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgUG9seWxpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICB2YXIgcmVjdCA9IGFubm90YXRpb24ucmVjdDtcbiAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgdmFyIGJvcmRlcldpZHRoID0gYW5ub3RhdGlvbi5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXBvbHlsaW5lXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLFxuICAgICAgICBhbm5vdGF0aW9uLnZlcnRpY2VzICYmIGFubm90YXRpb24udmVydGljZXMubGVuZ3RoICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdCh3aWR0aCwgXCIgXCIpLmNvbmNhdChoZWlnaHQpLCB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikgfSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLCBzdHJva2VXaWR0aDogYm9yZGVyV2lkdGggfHwgMSwgcG9pbnRzOiBhbm5vdGF0aW9uLnZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIFwiXCIuY29uY2F0KGl0ZW0ueCAtIHJlY3RbMF0sIFwiLFwiKS5jb25jYXQocmVjdFszXSAtIGl0ZW0ueSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJykgfSkpKSxcbiAgICAgICAgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgU3F1YXJlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgdmFyIHJlY3QgPSBhbm5vdGF0aW9uLnJlY3Q7XG4gICAgdmFyIHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGFubm90YXRpb24uYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1zcXVhcmVcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodCksIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSB9LFxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IGhlaWdodDogaGVpZ2h0IC0gYm9yZGVyV2lkdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgc3Ryb2tlV2lkdGg6IGJvcmRlcldpZHRoIHx8IDEsIHg6IGJvcmRlcldpZHRoIC8gMiwgeTogYm9yZGVyV2lkdGggLyAyLCB3aWR0aDogd2lkdGggLSBib3JkZXJXaWR0aCB9KSksXG4gICAgICAgIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIFNxdWlnZ2x5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBfYS5hbm5vdGF0aW9uLCBwYWdlID0gX2EucGFnZSwgdmlld3BvcnQgPSBfYS52aWV3cG9ydDtcbiAgICB2YXIgaGFzUG9wdXAgPSBhbm5vdGF0aW9uLmhhc1BvcHVwID09PSBmYWxzZTtcbiAgICB2YXIgdGl0bGUgPSBnZXRUaXRsZShhbm5vdGF0aW9uKTtcbiAgICB2YXIgY29udGVudHMgPSBnZXRDb250ZW50cyhhbm5vdGF0aW9uKTtcbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEoYW5ub3RhdGlvbi5oYXNQb3B1cCB8fCB0aXRsZSB8fCBjb250ZW50cyk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBoYXNQb3B1cDogaGFzUG9wdXAsIGlnbm9yZUJvcmRlcjogdHJ1ZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLnNsb3QuYXR0cnMsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hbm5vdGF0aW9uIHJwdi1jb3JlX19hbm5vdGF0aW9uLS1zcXVpZ2dseVwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSwgcHJvcHMuc2xvdC5jaGlsZHJlbikpOyB9KSk7XG59O1xuXG52YXIgU3RhbXAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXN0YW1wXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBTdHJpa2VPdXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIHBhZ2UgPSBfYS5wYWdlLCB2aWV3cG9ydCA9IF9hLnZpZXdwb3J0O1xuICAgIHZhciBoYXNQb3B1cCA9IGFubm90YXRpb24uaGFzUG9wdXAgPT09IGZhbHNlO1xuICAgIHZhciB0aXRsZSA9IGdldFRpdGxlKGFubm90YXRpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGdldENvbnRlbnRzKGFubm90YXRpb24pO1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShhbm5vdGF0aW9uLmhhc1BvcHVwIHx8IHRpdGxlIHx8IGNvbnRlbnRzKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiB0cnVlLCBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IHZpZXdwb3J0IH0sIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMuc2xvdC5hdHRycywgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24gcnB2LWNvcmVfX2Fubm90YXRpb24tLXN0cmlrZS1vdXRcIiwgXCJkYXRhLWFubm90YXRpb24taWRcIjogYW5ub3RhdGlvbi5pZCwgb25DbGljazogcHJvcHMucG9wdXAudG9nZ2xlT25DbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5wb3B1cC5vcGVuT25Ib3Zlciwgb25Nb3VzZUxlYXZlOiBwcm9wcy5wb3B1cC5jbG9zZU9uSG92ZXIgfSksIHByb3BzLnNsb3QuY2hpbGRyZW4pKTsgfSkpO1xufTtcblxudmFyIENvbW1lbnRJY29uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJY29uLCB7IHNpemU6IDE2IH0sXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTS41LDE2LjVhMSwxLDAsMCwwLDEsMWgydjRsNC00aDE1YTEsMSwwLDAsMCwxLTFWMy41YTEsMSwwLDAsMC0xLTFIMS41YTEsMSwwLDAsMC0xLDFaXCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTcuMjUsOS43NUEuMjUuMjUsMCwxLDEsNywxMGEuMjUuMjUsMCwwLDEsLjI1LS4yNVwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMiw5Ljc1YS4yNS4yNSwwLDEsMS0uMjUuMjVBLjI1LjI1LDAsMCwxLDEyLDkuNzVcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTYuNzUsOS43NWEuMjUuMjUsMCwxLDEtLjI1LjI1LjI1LjI1LDAsMCwxLC4yNS0uMjVcIiB9KSkpOyB9O1xuXG52YXIgSGVscEljb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEljb24sIHsgc2l6ZTogMTYgfSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMC41MDAgMTIuMDAxIEExMS41MDAgMTEuNTAwIDAgMSAwIDIzLjUwMCAxMi4wMDEgQTExLjUwMCAxMS41MDAgMCAxIDAgMC41MDAgMTIuMDAxIFpcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNi4wMDAgMTIuMDAxIEE2LjAwMCA2LjAwMCAwIDEgMCAxOC4wMDAgMTIuMDAxIEE2LjAwMCA2LjAwMCAwIDEgMCA2LjAwMCAxMi4wMDEgWlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0yMS40MjMgNS40MDZMMTcuNDE1IDkuNDE0XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE0LjU4NyA2LjU4NUwxOC42MDcgMi41NjVcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNS40MDUgMjEuNDI0TDkuNDEzIDE3LjQxNlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02LjU4NSAxNC41ODhMMi41NzcgMTguNTk2XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4LjYwMiAyMS40MTlMMTQuNTk1IDE3LjQxMlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xNy40MTkgMTQuNThMMjEuNDI4IDE4LjU4OVwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0yLjU4MiA1LjM5OUw2LjU4OCA5LjQwNlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk05LjQyMSA2LjU4MUw1LjQxMiAyLjU3MlwiIH0pKSk7IH07XG5cbnZhciBLZXlJY29uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJY29uLCB7IHNpemU6IDE2IH0sXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTQuMDAwIDE4LjUwMCBBMS41MDAgMS41MDAgMCAxIDAgNy4wMDAgMTguNTAwIEExLjUwMCAxLjUwMCAwIDEgMCA0LjAwMCAxOC41MDAgWlwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0yMC41LjVsLTkuNzgyLDkuNzgzYTcsNywwLDEsMCwzLDNMMTcsMTBoMS41VjguNUwxOSw4aDEuNVY2LjVMMjEsNmgxLjVWNC41bDEtMVYuNVpcIiB9KSkpOyB9O1xuXG52YXIgTm90ZUljb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEljb24sIHsgc2l6ZTogMTYgfSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMi4wMDAgMi41MDAgTDIyLjAwMCAyLjUwMCBMMjIuMDAwIDIzLjUwMCBMMi4wMDAgMjMuNTAwIFpcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA0LjVMNiAwLjVcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggNC41TDE4IDAuNVwiIH0pLFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMCA0LjVMMTAgMC41XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE0IDQuNUwxNCAwLjVcIiB9KSkpOyB9O1xuXG52YXIgUGFyYWdyYXBoSWNvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSWNvbiwgeyBzaXplOiAxNiB9LFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xNy41IDAuNDk4TDE3LjUgMjMuNDk4XCIgfSksXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEwLjUgMC40OThMMTAuNSAyMy40OThcIiB9KSxcbiAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjMuNS41SDYuNWE2LDYsMCwwLDAsMCwxMmg0XCIgfSkpKTsgfTtcblxudmFyIFRyaWFuZ2xlSWNvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoSWNvbiwgeyBzaXplOiAxNiB9LFxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0yLjUgMjIuOTk1TDEyIDYuMDA1IDIxLjUgMjIuOTk1IDIuNSAyMi45OTV6XCIgfSkpKTsgfTtcblxudmFyIFRleHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIGNoaWxkQW5ub3RhdGlvbiA9IF9hLmNoaWxkQW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHZhciBuYW1lID0gYW5ub3RhdGlvbi5uYW1lID8gYW5ub3RhdGlvbi5uYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uLCB7IGFubm90YXRpb246IGFubm90YXRpb24sIGhhc1BvcHVwOiBoYXNQb3B1cCwgaWdub3JlQm9yZGVyOiBmYWxzZSwgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiB2aWV3cG9ydCB9LCBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tdGV4dFwiLCBcImRhdGEtYW5ub3RhdGlvbi1pZFwiOiBhbm5vdGF0aW9uLmlkLCBvbkNsaWNrOiBwcm9wcy5wb3B1cC50b2dnbGVPbkNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLnBvcHVwLm9wZW5PbkhvdmVyLCBvbk1vdXNlTGVhdmU6IHByb3BzLnBvcHVwLmNsb3NlT25Ib3ZlciB9KSxcbiAgICAgICAgICAgIG5hbWUgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbi10ZXh0LWljb25cIiB9LFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdjaGVjaycgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KENoZWNrSWNvbiwgbnVsbCksXG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2NvbW1lbnQnICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21tZW50SWNvbiwgbnVsbCksXG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2hlbHAnICYmIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChIZWxwSWNvbiwgbnVsbCksXG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2luc2VydCcgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFRyaWFuZ2xlSWNvbiwgbnVsbCksXG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2tleScgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEtleUljb24sIG51bGwpLFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdub3RlJyAmJiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTm90ZUljb24sIG51bGwpLFxuICAgICAgICAgICAgICAgIChuYW1lID09PSAnbmV3cGFyYWdyYXBoJyB8fCBuYW1lID09PSAncGFyYWdyYXBoJykgJiYgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBhcmFncmFwaEljb24sIG51bGwpKSksXG4gICAgICAgICAgICBwcm9wcy5zbG90LmNoaWxkcmVuKSxcbiAgICAgICAgY2hpbGRBbm5vdGF0aW9uICYmXG4gICAgICAgICAgICBjaGlsZEFubm90YXRpb24uYW5ub3RhdGlvblR5cGUgPT09IGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuUG9wdXAgJiZcbiAgICAgICAgICAgIHByb3BzLnBvcHVwLm9wZW5lZCAmJiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUG9wdXAsIHsgYW5ub3RhdGlvbjogY2hpbGRBbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSkpKTsgfSkpO1xufTtcblxudmFyIFVuZGVybGluZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgcGFnZSA9IF9hLnBhZ2UsIHZpZXdwb3J0ID0gX2Eudmlld3BvcnQ7XG4gICAgdmFyIGhhc1BvcHVwID0gYW5ub3RhdGlvbi5oYXNQb3B1cCA9PT0gZmFsc2U7XG4gICAgdmFyIHRpdGxlID0gZ2V0VGl0bGUoYW5ub3RhdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZ2V0Q29udGVudHMoYW5ub3RhdGlvbik7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKGFubm90YXRpb24uaGFzUG9wdXAgfHwgdGl0bGUgfHwgY29udGVudHMpO1xuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFubm90YXRpb24sIHsgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgaGFzUG9wdXA6IGhhc1BvcHVwLCBpZ25vcmVCb3JkZXI6IHRydWUsIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogdmlld3BvcnQgfSwgZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBwcm9wcy5zbG90LmF0dHJzLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYW5ub3RhdGlvbiBycHYtY29yZV9fYW5ub3RhdGlvbi0tdW5kZXJsaW5lXCIsIFwiZGF0YS1hbm5vdGF0aW9uLWlkXCI6IGFubm90YXRpb24uaWQsIG9uQ2xpY2s6IHByb3BzLnBvcHVwLnRvZ2dsZU9uQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMucG9wdXAub3Blbk9uSG92ZXIsIG9uTW91c2VMZWF2ZTogcHJvcHMucG9wdXAuY2xvc2VPbkhvdmVyIH0pLCBwcm9wcy5zbG90LmNoaWxkcmVuKSk7IH0pKTtcbn07XG5cbnZhciBBbm5vdGF0aW9uTGF5ZXJCb2R5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGFubm90YXRpb25zID0gX2EuYW5ub3RhdGlvbnMsIGRvYyA9IF9hLmRvYywgb3V0bGluZXMgPSBfYS5vdXRsaW5lcywgcGFnZSA9IF9hLnBhZ2UsIHBhZ2VJbmRleCA9IF9hLnBhZ2VJbmRleCwgcGx1Z2lucyA9IF9hLnBsdWdpbnMsIHJvdGF0aW9uID0gX2Eucm90YXRpb24sIHNjYWxlID0gX2Euc2NhbGUsIG9uRXhlY3V0ZU5hbWVkQWN0aW9uID0gX2Eub25FeGVjdXRlTmFtZWRBY3Rpb24sIG9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbiA9IF9hLm9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbiwgb25KdW1wVG9EZXN0ID0gX2Eub25KdW1wVG9EZXN0O1xuICAgIHZhciBjb250YWluZXJSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyByb3RhdGlvbjogcm90YXRpb24sIHNjYWxlOiBzY2FsZSB9KTtcbiAgICB2YXIgY2xvbmVkVmlld1BvcnQgPSB2aWV3cG9ydC5jbG9uZSh7IGRvbnRGbGlwOiB0cnVlIH0pO1xuICAgIHZhciBmaWx0ZXJBbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYW5ub3RhdGlvbikgeyByZXR1cm4gIWFubm90YXRpb24ucGFyZW50SWQ7IH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ub25Bbm5vdGF0aW9uTGF5ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ub25Bbm5vdGF0aW9uTGF5ZXJSZW5kZXIoe1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZmlsdGVyQW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyUmVmLCBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fubm90YXRpb24tbGF5ZXJcIiwgXCJkYXRhLXRlc3RpZFwiOiBcImNvcmVfX2Fubm90YXRpb24tbGF5ZXItXCIuY29uY2F0KHBhZ2VJbmRleCkgfSwgZmlsdGVyQW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uIChhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBjaGlsZEFubm90YXRpb24gPSBhbm5vdGF0aW9ucy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnBhcmVudElkID09PSBhbm5vdGF0aW9uLmlkOyB9KTtcbiAgICAgICAgc3dpdGNoIChhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuQ2FyZXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ2FyZXQsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkNpcmNsZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDaXJjbGUsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkZpbGVBdHRhY2htZW50OlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEZpbGVBdHRhY2htZW50LCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5GcmVlVGV4dDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChGcmVlVGV4dCwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuSGlnaGxpZ2h0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEhpZ2hsaWdodCwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIGNoaWxkQW5ub3RhdGlvbjogY2hpbGRBbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkluazpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJbmssIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLkxpbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTGluZSwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuTGluazpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChMaW5rLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgYW5ub3RhdGlvbkNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmLCBkb2M6IGRvYywgb3V0bGluZXM6IG91dGxpbmVzLCBwYWdlOiBwYWdlLCBwYWdlSW5kZXg6IHBhZ2VJbmRleCwgc2NhbGU6IHNjYWxlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQsIG9uRXhlY3V0ZU5hbWVkQWN0aW9uOiBvbkV4ZWN1dGVOYW1lZEFjdGlvbiwgb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uOiBvbkp1bXBGcm9tTGlua0Fubm90YXRpb24sIG9uSnVtcFRvRGVzdDogb25KdW1wVG9EZXN0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5Qb2x5Z29uOlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBvbHlnb24sIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLlBvbHlsaW5lOlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBvbHlsaW5lLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5Qb3B1cDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQb3B1cCwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuU3F1YXJlOlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFNxdWFyZSwgeyBrZXk6IGFubm90YXRpb24uaWQsIGFubm90YXRpb246IGFubm90YXRpb24sIHBhZ2U6IHBhZ2UsIHZpZXdwb3J0OiBjbG9uZWRWaWV3UG9ydCB9KSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQW5ub3RhdGlvblR5cGUuU3F1aWdnbHk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoU3F1aWdnbHksIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBwYWdlOiBwYWdlLCB2aWV3cG9ydDogY2xvbmVkVmlld1BvcnQgfSkpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkFubm90YXRpb25UeXBlLlN0YW1wOlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFN0YW1wLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5TdHJpa2VPdXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoU3RyaWtlT3V0LCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5UZXh0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFRleHQsIHsga2V5OiBhbm5vdGF0aW9uLmlkLCBhbm5vdGF0aW9uOiBhbm5vdGF0aW9uLCBjaGlsZEFubm90YXRpb246IGNoaWxkQW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZS5VbmRlcmxpbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoVW5kZXJsaW5lLCB7IGtleTogYW5ub3RhdGlvbi5pZCwgYW5ub3RhdGlvbjogYW5ub3RhdGlvbiwgcGFnZTogcGFnZSwgdmlld3BvcnQ6IGNsb25lZFZpZXdQb3J0IH0pKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCB7IGtleTogYW5ub3RhdGlvbi5pZCB9KTtcbiAgICAgICAgfVxuICAgIH0pKSk7XG59O1xuXG52YXIgQW5ub3RhdGlvbkxvYWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwYWdlID0gX2EucGFnZSwgcmVuZGVyQW5ub3RhdGlvbnMgPSBfYS5yZW5kZXJBbm5vdGF0aW9ucztcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7XG4gICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgIGFubm90YXRpb25zOiBbXSxcbiAgICB9KSwgc3RhdHVzID0gX2JbMF0sIHNldFN0YXR1cyA9IF9iWzFdO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFnZS5nZXRBbm5vdGF0aW9ucyh7IGludGVudDogJ2Rpc3BsYXknIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc3RhdHVzLmxvYWRpbmcgPyBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCkgOiByZW5kZXJBbm5vdGF0aW9ucyhzdGF0dXMuYW5ub3RhdGlvbnMpO1xufTtcblxudmFyIEFubm90YXRpb25MYXllciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkb2MgPSBfYS5kb2MsIG91dGxpbmVzID0gX2Eub3V0bGluZXMsIHBhZ2UgPSBfYS5wYWdlLCBwYWdlSW5kZXggPSBfYS5wYWdlSW5kZXgsIHBsdWdpbnMgPSBfYS5wbHVnaW5zLCByb3RhdGlvbiA9IF9hLnJvdGF0aW9uLCBzY2FsZSA9IF9hLnNjYWxlLCBvbkV4ZWN1dGVOYW1lZEFjdGlvbiA9IF9hLm9uRXhlY3V0ZU5hbWVkQWN0aW9uLCBvbkp1bXBGcm9tTGlua0Fubm90YXRpb24gPSBfYS5vbkp1bXBGcm9tTGlua0Fubm90YXRpb24sIG9uSnVtcFRvRGVzdCA9IF9hLm9uSnVtcFRvRGVzdDtcbiAgICB2YXIgcmVuZGVyQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAoYW5ub3RhdGlvbnMpIHsgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbkxheWVyQm9keSwgeyBhbm5vdGF0aW9uczogYW5ub3RhdGlvbnMsIGRvYzogZG9jLCBvdXRsaW5lczogb3V0bGluZXMsIHBhZ2U6IHBhZ2UsIHBhZ2VJbmRleDogcGFnZUluZGV4LCBwbHVnaW5zOiBwbHVnaW5zLCByb3RhdGlvbjogcm90YXRpb24sIHNjYWxlOiBzY2FsZSwgb25FeGVjdXRlTmFtZWRBY3Rpb246IG9uRXhlY3V0ZU5hbWVkQWN0aW9uLCBvbkp1bXBGcm9tTGlua0Fubm90YXRpb246IG9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbiwgb25KdW1wVG9EZXN0OiBvbkp1bXBUb0Rlc3QgfSkpOyB9O1xuICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbkxvYWRlciwgeyBwYWdlOiBwYWdlLCByZW5kZXJBbm5vdGF0aW9uczogcmVuZGVyQW5ub3RhdGlvbnMgfSk7XG59O1xuXG52YXIgZmxvYXRUb1JhdGlvID0gZnVuY3Rpb24gKHgsIGxpbWl0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoTWF0aC5mbG9vcih4KSA9PT0geCkge1xuICAgICAgICByZXR1cm4gW3gsIDFdO1xuICAgIH1cbiAgICB2YXIgeSA9IDEgLyB4O1xuICAgIGlmICh5ID4gbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFsxLCBsaW1pdF07XG4gICAgfVxuICAgIGlmIChNYXRoLmZsb29yKHkpID09PSB5KSB7XG4gICAgICAgIHJldHVybiBbMSwgeV07XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHggPiAxID8geSA6IHg7XG4gICAgdmFyIGEgPSAwO1xuICAgIHZhciBiID0gMTtcbiAgICB2YXIgYyA9IDE7XG4gICAgdmFyIGQgPSAxO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBudW1lcmF0b3IgPSBhICsgYztcbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gYiArIGQ7XG4gICAgICAgIGlmIChkZW5vbWluYXRvciA+IGxpbWl0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA8PSBudW1lcmF0b3IgLyBkZW5vbWluYXRvciA/IChfYSA9IFtudW1lcmF0b3IsIGRlbm9taW5hdG9yXSwgYyA9IF9hWzBdLCBkID0gX2FbMV0sIF9hKSA6IChfYiA9IFtudW1lcmF0b3IsIGRlbm9taW5hdG9yXSwgYSA9IF9iWzBdLCBiID0gX2JbMV0sIF9iKTtcbiAgICB9XG4gICAgdmFyIG1pZGRsZSA9IChhIC8gYiArIGMgLyBkKSAvIDI7XG4gICAgcmV0dXJuIHZhbHVlIDwgbWlkZGxlID8gKHZhbHVlID09PSB4ID8gW2EsIGJdIDogW2IsIGFdKSA6IHZhbHVlID09PSB4ID8gW2MsIGRdIDogW2QsIGNdO1xufTtcblxudmFyIHJvdW5kVG9EaXZpZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciByZW1haW5kZXIgPSBhICUgYjtcbiAgICByZXR1cm4gcmVtYWluZGVyID09PSAwID8gYSA6IE1hdGguZmxvb3IoYSAtIHJlbWFpbmRlcik7XG59O1xuXG52YXIgTUFYX0NBTlZBU19TSVpFID0gNDA5NiAqIDQwOTY7XG52YXIgQ2FudmFzTGF5ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2FudmFzTGF5ZXJSZWYgPSBfYS5jYW52YXNMYXllclJlZiwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBwYWdlID0gX2EucGFnZSwgcGFnZUluZGV4ID0gX2EucGFnZUluZGV4LCBwbHVnaW5zID0gX2EucGx1Z2lucywgcm90YXRpb24gPSBfYS5yb3RhdGlvbiwgc2NhbGUgPSBfYS5zY2FsZSwgd2lkdGggPSBfYS53aWR0aCwgb25SZW5kZXJDYW52YXNDb21wbGV0ZWQgPSBfYS5vblJlbmRlckNhbnZhc0NvbXBsZXRlZDtcbiAgICB2YXIgcmVuZGVyVGFzayA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXNrID0gcmVuZGVyVGFzay5jdXJyZW50O1xuICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgdGFzay5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FudmFzRWxlID0gY2FudmFzTGF5ZXJSZWYuY3VycmVudDtcbiAgICAgICAgY2FudmFzRWxlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ub25DYW52YXNMYXllclJlbmRlcikge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5vbkNhbnZhc0xheWVyUmVuZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlOiBjYW52YXNFbGUsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBleHBvcnRzLkxheWVyUmVuZGVyU3RhdHVzLlByZVJlbmRlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoe1xuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG91dHB1dFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgdmFyIG1heFNjYWxlID0gTWF0aC5zcXJ0KE1BWF9DQU5WQVNfU0laRSAvICh2aWV3cG9ydC53aWR0aCAqIHZpZXdwb3J0LmhlaWdodCkpO1xuICAgICAgICB2YXIgc2hvdWxkU2NhbGVCeUNTUyA9IG91dHB1dFNjYWxlID4gbWF4U2NhbGU7XG4gICAgICAgIHNob3VsZFNjYWxlQnlDU1MgPyAoY2FudmFzRWxlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoMSwgMSlcIikgOiBjYW52YXNFbGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgICB2YXIgcG9zc2libGVTY2FsZSA9IE1hdGgubWluKG1heFNjYWxlLCBvdXRwdXRTY2FsZSk7XG4gICAgICAgIHZhciBfYSA9IGZsb2F0VG9SYXRpbyhwb3NzaWJsZVNjYWxlLCA4KSwgeCA9IF9hWzBdLCB5ID0gX2FbMV07XG4gICAgICAgIGNhbnZhc0VsZS53aWR0aCA9IHJvdW5kVG9EaXZpZGUodmlld3BvcnQud2lkdGggKiBwb3NzaWJsZVNjYWxlLCB4KTtcbiAgICAgICAgY2FudmFzRWxlLmhlaWdodCA9IHJvdW5kVG9EaXZpZGUodmlld3BvcnQuaGVpZ2h0ICogcG9zc2libGVTY2FsZSwgeCk7XG4gICAgICAgIGNhbnZhc0VsZS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHJvdW5kVG9EaXZpZGUodmlld3BvcnQud2lkdGgsIHkpLCBcInB4XCIpO1xuICAgICAgICBjYW52YXNFbGUuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQocm91bmRUb0RpdmlkZSh2aWV3cG9ydC5oZWlnaHQsIHkpLCBcInB4XCIpO1xuICAgICAgICBjYW52YXNFbGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNhbnZhc0NvbnRleHQgPSBjYW52YXNFbGUuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHNob3VsZFNjYWxlQnlDU1MgfHwgb3V0cHV0U2NhbGUgIT09IDEgPyBbcG9zc2libGVTY2FsZSwgMCwgMCwgcG9zc2libGVTY2FsZSwgMCwgMF0gOiBudWxsO1xuICAgICAgICByZW5kZXJUYXNrLmN1cnJlbnQgPSBwYWdlLnJlbmRlcih7IGNhbnZhc0NvbnRleHQ6IGNhbnZhc0NvbnRleHQsIHRyYW5zZm9ybTogdHJhbnNmb3JtLCB2aWV3cG9ydDogdmlld3BvcnQgfSk7XG4gICAgICAgIHJlbmRlclRhc2suY3VycmVudC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FudmFzRWxlLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgY2FudmFzRWxlLnNldEF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnLCBcImNvcmVfX2NhbnZhcy1sYXllci1cIi5jb25jYXQocGFnZUluZGV4KSk7XG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ub25DYW52YXNMYXllclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ub25DYW52YXNMYXllclJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGU6IGNhbnZhc0VsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBleHBvcnRzLkxheWVyUmVuZGVyU3RhdHVzLkRpZFJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvblJlbmRlckNhbnZhc0NvbXBsZXRlZCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvblJlbmRlckNhbnZhc0NvbXBsZXRlZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjYW52YXNFbGUpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNFbGUud2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGNhbnZhc0VsZS5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fY2FudmFzLWxheWVyXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcbiAgICAgICAgfSB9LFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgeyByZWY6IGNhbnZhc0xheWVyUmVmIH0pKSk7XG59O1xuXG52YXIgU3ZnTGF5ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBwYWdlID0gX2EucGFnZSwgcm90YXRpb24gPSBfYS5yb3RhdGlvbiwgc2NhbGUgPSBfYS5zY2FsZSwgd2lkdGggPSBfYS53aWR0aDtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXJFbGUgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjb250YWluZXJFbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXJFbGUuaW5uZXJIVE1MID0gJyc7XG4gICAgfTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsZSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgcm90YXRpb246IHJvdGF0aW9uLCBzY2FsZTogc2NhbGUgfSk7XG4gICAgICAgIHBhZ2UuZ2V0T3BlcmF0b3JMaXN0KCkudGhlbihmdW5jdGlvbiAob3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgICBlbXB0eSgpO1xuICAgICAgICAgICAgdmFyIGdyYXBoaWMgPSBuZXcgUGRmSnNBcGlfX25hbWVzcGFjZS5TVkdHcmFwaGljcyhwYWdlLmNvbW1vbk9ianMsIHBhZ2Uub2Jqcyk7XG4gICAgICAgICAgICBncmFwaGljLmdldFNWRyhvcGVyYXRvckxpc3QsIHZpZXdwb3J0KS50aGVuKGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgICAgICAgICBzdmcuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIHN2Zy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZS5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19zdmctbGF5ZXJcIiwgcmVmOiBjb250YWluZXJSZWYgfSk7XG59O1xuXG52YXIgVGV4dExheWVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNvbnRhaW5lclJlZiA9IF9hLmNvbnRhaW5lclJlZiwgcGFnZSA9IF9hLnBhZ2UsIHBhZ2VJbmRleCA9IF9hLnBhZ2VJbmRleCwgcGx1Z2lucyA9IF9hLnBsdWdpbnMsIHJvdGF0aW9uID0gX2Eucm90YXRpb24sIHNjYWxlID0gX2Euc2NhbGUsIG9uUmVuZGVyVGV4dENvbXBsZXRlZCA9IF9hLm9uUmVuZGVyVGV4dENvbXBsZXRlZDtcbiAgICB2YXIgcmVuZGVyVGFzayA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyRWxlID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyRWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwYW5zID0gW10uc2xpY2UuY2FsbChjb250YWluZXJFbGUucXVlcnlTZWxlY3RvckFsbCgnLnJwdi1jb3JlX190ZXh0LWxheWVyLXRleHQnKSk7XG4gICAgICAgIHNwYW5zLmZvckVhY2goZnVuY3Rpb24gKHNwYW4pIHsgcmV0dXJuIGNvbnRhaW5lckVsZS5yZW1vdmVDaGlsZChzcGFuKTsgfSk7XG4gICAgICAgIHZhciBicmVha3MgPSBbXS5zbGljZS5jYWxsKGNvbnRhaW5lckVsZS5xdWVyeVNlbGVjdG9yQWxsKCdicltyb2xlPVwicHJlc2VudGF0aW9uXCJdJykpO1xuICAgICAgICBicmVha3MuZm9yRWFjaChmdW5jdGlvbiAoYnIpIHsgcmV0dXJuIGNvbnRhaW5lckVsZS5yZW1vdmVDaGlsZChicik7IH0pO1xuICAgIH07XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YXNrID0gcmVuZGVyVGFzay5jdXJyZW50O1xuICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgdGFzay5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbmVyRWxlID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY29udGFpbmVyRWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyRWxlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKTtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHJvdGF0aW9uOiByb3RhdGlvbiwgc2NhbGU6IHNjYWxlIH0pO1xuICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgICAgaWYgKHBsdWdpbi5vblRleHRMYXllclJlbmRlcikge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5vblRleHRMYXllclJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgIGVsZTogY29udGFpbmVyRWxlLFxuICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGV4cG9ydHMuTGF5ZXJSZW5kZXJTdGF0dXMuUHJlUmVuZGVyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFnZS5nZXRUZXh0Q29udGVudCgpLnRoZW4oZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICBlbXB0eSgpO1xuICAgICAgICAgICAgcmVuZGVyVGFzay5jdXJyZW50ID0gUGRmSnNBcGlfX25hbWVzcGFjZS5yZW5kZXJUZXh0TGF5ZXIoe1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyRWxlLFxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudFNvdXJjZTogdGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZW5kZXJUYXNrLmN1cnJlbnQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbGUuc2V0QXR0cmlidXRlKCdkYXRhLXRlc3RpZCcsIFwiY29yZV9fdGV4dC1sYXllci1cIi5jb25jYXQocGFnZUluZGV4KSk7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW5zID0gW10uc2xpY2UuY2FsbChjb250YWluZXJFbGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHNwYW5zLmZvckVhY2goZnVuY3Rpb24gKHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGFuLmNsYXNzTGlzdC5jb250YWlucygncnB2LWNvcmVfX3RleHQtbGF5ZXItdGV4dC0tbm90JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgncnB2LWNvcmVfX3RleHQtbGF5ZXItdGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5vblRleHRMYXllclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm9uVGV4dExheWVyUmVuZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGU6IGNvbnRhaW5lckVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBleHBvcnRzLkxheWVyUmVuZGVyU3RhdHVzLkRpZFJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25SZW5kZXJUZXh0Q29tcGxldGVkKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKTtcbiAgICAgICAgICAgICAgICBvblJlbmRlclRleHRDb21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGVtcHR5KCk7XG4gICAgICAgICAgICAoX2EgPSByZW5kZXJUYXNrLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWwoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fdGV4dC1sYXllclwiLCByZWY6IGNvbnRhaW5lclJlZiB9KTtcbn07XG5cbnZhciBQYWdlTGF5ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZG9jID0gX2EuZG9jLCBtZWFzdXJlUmVmID0gX2EubWVhc3VyZVJlZiwgb3V0bGluZXMgPSBfYS5vdXRsaW5lcywgcGFnZUluZGV4ID0gX2EucGFnZUluZGV4LCBwYWdlUm90YXRpb24gPSBfYS5wYWdlUm90YXRpb24sIHBhZ2VTaXplID0gX2EucGFnZVNpemUsIHBsdWdpbnMgPSBfYS5wbHVnaW5zLCByZW5kZXJQYWdlID0gX2EucmVuZGVyUGFnZSwgcmVuZGVyUXVldWVLZXkgPSBfYS5yZW5kZXJRdWV1ZUtleSwgcm90YXRpb24gPSBfYS5yb3RhdGlvbiwgc2NhbGUgPSBfYS5zY2FsZSwgc2hvdWxkUmVuZGVyID0gX2Euc2hvdWxkUmVuZGVyLCB2aWV3TW9kZSA9IF9hLnZpZXdNb2RlLCBvbkV4ZWN1dGVOYW1lZEFjdGlvbiA9IF9hLm9uRXhlY3V0ZU5hbWVkQWN0aW9uLCBvbkp1bXBGcm9tTGlua0Fubm90YXRpb24gPSBfYS5vbkp1bXBGcm9tTGlua0Fubm90YXRpb24sIG9uSnVtcFRvRGVzdCA9IF9hLm9uSnVtcFRvRGVzdCwgb25SZW5kZXJDb21wbGV0ZWQgPSBfYS5vblJlbmRlckNvbXBsZXRlZCwgb25Sb3RhdGVQYWdlID0gX2Eub25Sb3RhdGVQYWdlO1xuICAgIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKG51bGwpLCBwYWdlID0gX2JbMF0sIHNldFBhZ2UgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKSwgY2FudmFzTGF5ZXJSZW5kZXJlZCA9IF9jWzBdLCBzZXRDYW52YXNMYXllclJlbmRlcmVkID0gX2NbMV07XG4gICAgdmFyIF9kID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSksIHRleHRMYXllclJlbmRlcmVkID0gX2RbMF0sIHNldFRleHRMYXllclJlbmRlcmVkID0gX2RbMV07XG4gICAgdmFyIGNhbnZhc0xheWVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgdGV4dExheWVyUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoKTtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IE1hdGguYWJzKHJvdGF0aW9uICsgcGFnZVJvdGF0aW9uKSAlIDE4MCA9PT0gMDtcbiAgICB2YXIgc2NhbGVkV2lkdGggPSBwYWdlU2l6ZS5wYWdlV2lkdGggKiBzY2FsZTtcbiAgICB2YXIgc2NhbGVkSGVpZ2h0ID0gcGFnZVNpemUucGFnZUhlaWdodCAqIHNjYWxlO1xuICAgIHZhciB3ID0gaXNWZXJ0aWNhbCA/IHNjYWxlZFdpZHRoIDogc2NhbGVkSGVpZ2h0O1xuICAgIHZhciBoID0gaXNWZXJ0aWNhbCA/IHNjYWxlZEhlaWdodCA6IHNjYWxlZFdpZHRoO1xuICAgIHZhciByb3RhdGlvblZhbHVlID0gKHBhZ2VTaXplLnJvdGF0aW9uICsgcm90YXRpb24gKyBwYWdlUm90YXRpb24pICUgMzYwO1xuICAgIHZhciByZW5kZXJRdWV1ZUtleVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKDApO1xuICAgIHZhciBkZXRlcm1pbmVQYWdlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdldFBhZ2UoZG9jLCBwYWdlSW5kZXgpLnRoZW4oZnVuY3Rpb24gKHBkZlBhZ2UpIHtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJlbmRlclF1ZXVlS2V5UmVmLmN1cnJlbnQgPSByZW5kZXJRdWV1ZUtleTtcbiAgICAgICAgICAgICAgICBzZXRQYWdlKHBkZlBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0UGFnZVJlbmRlcmVyID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIHByb3BzLmNhbnZhc0xheWVyLmNoaWxkcmVuLFxuICAgICAgICBwcm9wcy50ZXh0TGF5ZXIuY2hpbGRyZW4sXG4gICAgICAgIHByb3BzLmFubm90YXRpb25MYXllci5jaGlsZHJlbikpOyB9O1xuICAgIHZhciByZW5kZXJQYWdlTGF5ZXIgPSByZW5kZXJQYWdlIHx8IGRlZmF1bHRQYWdlUmVuZGVyZXI7XG4gICAgdmFyIGhhbmRsZVJlbmRlckNhbnZhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRDYW52YXNMYXllclJlbmRlcmVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlUmVuZGVyVGV4dENvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRUZXh0TGF5ZXJSZW5kZXJlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRQYWdlKG51bGwpO1xuICAgICAgICBzZXRDYW52YXNMYXllclJlbmRlcmVkKGZhbHNlKTtcbiAgICAgICAgc2V0VGV4dExheWVyUmVuZGVyZWQoZmFsc2UpO1xuICAgIH0sIFtwYWdlUm90YXRpb24sIHJvdGF0aW9uLCBzY2FsZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlbmRlciAmJiBpc01vdW50ZWQuY3VycmVudCAmJiAhcGFnZSkge1xuICAgICAgICAgICAgZGV0ZXJtaW5lUGFnZUluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2hvdWxkUmVuZGVyLCBwYWdlXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2FudmFzTGF5ZXJSZW5kZXJlZCAmJiB0ZXh0TGF5ZXJSZW5kZXJlZCkge1xuICAgICAgICAgICAgaWYgKHJlbmRlclF1ZXVlS2V5ICE9PSByZW5kZXJRdWV1ZUtleVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0UGFnZShudWxsKTtcbiAgICAgICAgICAgICAgICBzZXRDYW52YXNMYXllclJlbmRlcmVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzZXRUZXh0TGF5ZXJSZW5kZXJlZChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvblJlbmRlckNvbXBsZXRlZChwYWdlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NhbnZhc0xheWVyUmVuZGVyZWQsIHRleHRMYXllclJlbmRlcmVkXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgJ3Jwdi1jb3JlX19wYWdlLWxheWVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdycHYtY29yZV9fcGFnZS1sYXllci0tZHVhbCc6IHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19wYWdlLWxheWVyLS1kdWFsLWNvdmVyJzogdmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIsXG4gICAgICAgICAgICAncnB2LWNvcmVfX3BhZ2UtbGF5ZXItLXNpbmdsZSc6IHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLlNpbmdsZVBhZ2UsXG4gICAgICAgIH0pLCBcImRhdGEtdGVzdGlkXCI6IFwiY29yZV9fcGFnZS1sYXllci1cIi5jb25jYXQocGFnZUluZGV4KSwgcmVmOiBtZWFzdXJlUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoLCBcInB4XCIpLFxuICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHcsIFwicHhcIiksXG4gICAgICAgIH0gfSwgIXBhZ2UgPyAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFNwaW5uZXIsIHsgdGVzdElkOiBcImNvcmVfX3BhZ2UtbGF5ZXItbG9hZGluZy1cIi5jb25jYXQocGFnZUluZGV4KSB9KSkgOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIHJlbmRlclBhZ2VMYXllcih7XG4gICAgICAgICAgICBhbm5vdGF0aW9uTGF5ZXI6IHtcbiAgICAgICAgICAgICAgICBhdHRyczoge30sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQW5ub3RhdGlvbkxheWVyLCB7IGRvYzogZG9jLCBvdXRsaW5lczogb3V0bGluZXMsIHBhZ2U6IHBhZ2UsIHBhZ2VJbmRleDogcGFnZUluZGV4LCBwbHVnaW5zOiBwbHVnaW5zLCByb3RhdGlvbjogcm90YXRpb25WYWx1ZSwgc2NhbGU6IHNjYWxlLCBvbkV4ZWN1dGVOYW1lZEFjdGlvbjogb25FeGVjdXRlTmFtZWRBY3Rpb24sIG9uSnVtcEZyb21MaW5rQW5ub3RhdGlvbjogb25KdW1wRnJvbUxpbmtBbm5vdGF0aW9uLCBvbkp1bXBUb0Rlc3Q6IG9uSnVtcFRvRGVzdCB9KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FudmFzTGF5ZXI6IHtcbiAgICAgICAgICAgICAgICBhdHRyczoge30sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQ2FudmFzTGF5ZXIsIHsgY2FudmFzTGF5ZXJSZWY6IGNhbnZhc0xheWVyUmVmLCBoZWlnaHQ6IGgsIHBhZ2U6IHBhZ2UsIHBhZ2VJbmRleDogcGFnZUluZGV4LCBwbHVnaW5zOiBwbHVnaW5zLCByb3RhdGlvbjogcm90YXRpb25WYWx1ZSwgc2NhbGU6IHNjYWxlLCB3aWR0aDogdywgb25SZW5kZXJDYW52YXNDb21wbGV0ZWQ6IGhhbmRsZVJlbmRlckNhbnZhc0NvbXBsZXRlZCB9KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FudmFzTGF5ZXJSZW5kZXJlZDogY2FudmFzTGF5ZXJSZW5kZXJlZCxcbiAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIHN2Z0xheWVyOiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFN2Z0xheWVyLCB7IGhlaWdodDogaCwgcGFnZTogcGFnZSwgcm90YXRpb246IHJvdGF0aW9uVmFsdWUsIHNjYWxlOiBzY2FsZSwgd2lkdGg6IHcgfSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRMYXllcjoge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChUZXh0TGF5ZXIsIHsgY29udGFpbmVyUmVmOiB0ZXh0TGF5ZXJSZWYsIHBhZ2U6IHBhZ2UsIHBhZ2VJbmRleDogcGFnZUluZGV4LCBwbHVnaW5zOiBwbHVnaW5zLCByb3RhdGlvbjogcm90YXRpb25WYWx1ZSwgc2NhbGU6IHNjYWxlLCBvblJlbmRlclRleHRDb21wbGV0ZWQ6IGhhbmRsZVJlbmRlclRleHRDb21wbGV0ZWQgfSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRMYXllclJlbmRlcmVkOiB0ZXh0TGF5ZXJSZW5kZXJlZCxcbiAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgbWFya1JlbmRlcmVkOiBvblJlbmRlckNvbXBsZXRlZCxcbiAgICAgICAgICAgIG9uUm90YXRlUGFnZTogZnVuY3Rpb24gKGRpcmVjdGlvbikgeyByZXR1cm4gb25Sb3RhdGVQYWdlKHBhZ2VJbmRleCwgZGlyZWN0aW9uKTsgfSxcbiAgICAgICAgfSksXG4gICAgICAgIHBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4sIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbi5yZW5kZXJQYWdlTGF5ZXIgPyAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIHsga2V5OiBpZHggfSwgcGx1Z2luLnJlbmRlclBhZ2VMYXllcih7XG4gICAgICAgICAgICAgICAgY2FudmFzTGF5ZXJSZWY6IGNhbnZhc0xheWVyUmVmLFxuICAgICAgICAgICAgICAgIGNhbnZhc0xheWVyUmVuZGVyZWQ6IGNhbnZhc0xheWVyUmVuZGVyZWQsXG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgICAgICB0ZXh0TGF5ZXJSZWY6IHRleHRMYXllclJlZixcbiAgICAgICAgICAgICAgICB0ZXh0TGF5ZXJSZW5kZXJlZDogdGV4dExheWVyUmVuZGVyZWQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICB9KSkpIDogKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCB7IGtleTogaWR4IH0pKTtcbiAgICAgICAgfSkpKSkpO1xufTtcblxudmFyIGdldEZpbGVFeHQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIHN0ciA9IHVybC5zcGxpdCgvXFwuLykucG9wKCk7XG4gICAgcmV0dXJuIHN0ciA/IHN0ci50b0xvd2VyQ2FzZSgpIDogJyc7XG59O1xuXG52YXIgcmVjdFJlZHVjZXIgPSBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgIHZhciByZWN0ID0gYWN0aW9uLnJlY3Q7XG4gICAgcmV0dXJuIHN0YXRlLmhlaWdodCAhPT0gcmVjdC5oZWlnaHQgfHwgc3RhdGUud2lkdGggIT09IHJlY3Qud2lkdGggPyByZWN0IDogc3RhdGU7XG59O1xudmFyIHVzZU1lYXN1cmVSZWN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGVsZW1lbnRSZWYgPSBfYS5lbGVtZW50UmVmO1xuICAgIHZhciBfYiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoZWxlbWVudFJlZi5jdXJyZW50KSwgZWxlbWVudCA9IF9iWzBdLCBzZXRFbGVtZW50ID0gX2JbMV07XG4gICAgdmFyIGluaXRpYWxpemVkUmVjdFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGZhbHNlKTtcbiAgICB2YXIgX2MgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZHVjZXIocmVjdFJlZHVjZXIsIHsgaGVpZ2h0OiAwLCB3aWR0aDogMCB9KSwgcmVjdCA9IF9jWzBdLCBkaXNwYXRjaCA9IF9jWzFdO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZWxlbWVudFJlZi5jdXJyZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBzZXRFbGVtZW50KGVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWluaXRpYWxpemVkUmVjdFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZFJlY3RSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2EgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBoZWlnaHQgPSBfYS5oZWlnaHQsIHdpZHRoID0gX2Eud2lkdGg7XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgcmVjdDogeyBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRoIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhY2tlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcywgX18pIHtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGVudHJ5LmNvbnRlbnRSZWN0LCBoZWlnaHQgPSBfYS5oZWlnaHQsIHdpZHRoID0gX2Eud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHsgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aCB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYWNrZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYWNrZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG52YXIgU2Nyb2xsRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICBTY3JvbGxEaXJlY3Rpb25bXCJIb3Jpem9udGFsXCJdID0gXCJIb3Jpem9udGFsXCI7XG4gICAgU2Nyb2xsRGlyZWN0aW9uW1wiVmVydGljYWxcIl0gPSBcIlZlcnRpY2FsXCI7XG4gICAgU2Nyb2xsRGlyZWN0aW9uW1wiQm90aFwiXSA9IFwiQm90aFwiO1xufSkoU2Nyb2xsRGlyZWN0aW9uIHx8IChTY3JvbGxEaXJlY3Rpb24gPSB7fSkpO1xuXG52YXIgZWFzZU91dFF1YXJ0ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgNCk7IH07XG5cbnZhciBFUFMgPSAwLjAwMDE7XG52YXIgc21vb3RoU2Nyb2xsID0gZnVuY3Rpb24gKGVsZSwgc2Nyb2xsRGlyZWN0aW9uLCB0YXJnZXRQb3NpdGlvbiwgZHVyYXRpb24sIGVhc2luZywgb25SZWFjaFRhcmdldCkge1xuICAgIGlmIChlYXNpbmcgPT09IHZvaWQgMCkgeyBlYXNpbmcgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTsgfVxuICAgIGlmIChvblJlYWNoVGFyZ2V0ID09PSB2b2lkIDApIHsgb25SZWFjaFRhcmdldCA9IGZ1bmN0aW9uICgpIHsgfTsgfVxuICAgIHZhciB0b3AgPSAwO1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgcmVhY2hUYXJnZXQgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHNjcm9sbERpcmVjdGlvbikge1xuICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgbGVmdCA9IGVsZS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uQm90aDpcbiAgICAgICAgICAgIGxlZnQgPSBlbGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHRvcCA9IGVsZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgIHRvcCA9IGVsZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1hcmtUYXJnZXRSZWFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlYWNoVGFyZ2V0KSB7XG4gICAgICAgICAgICByZWFjaFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICBlbGUuc2Nyb2xsTGVmdCA9IHRhcmdldFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICBlbGUuc2Nyb2xsVG9wID0gdGFyZ2V0UG9zaXRpb24udG9wO1xuICAgICAgICAgICAgb25SZWFjaFRhcmdldCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoTWF0aC5hYnModG9wIC0gdGFyZ2V0UG9zaXRpb24udG9wKSA8PSBFUFMgJiYgc2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWwpIHtcbiAgICAgICAgbWFya1RhcmdldFJlYWNoZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMobGVmdCAtIHRhcmdldFBvc2l0aW9uLmxlZnQpIDw9IEVQUyAmJiBzY3JvbGxEaXJlY3Rpb24gPT09IFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsKSB7XG4gICAgICAgIG1hcmtUYXJnZXRSZWFjaGVkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VGltZSA9IC0xO1xuICAgIHZhciByZXF1ZXN0SWQ7XG4gICAgdmFyIG9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogbGVmdCAtIHRhcmdldFBvc2l0aW9uLmxlZnQsXG4gICAgICAgIHRvcDogdG9wIC0gdGFyZ2V0UG9zaXRpb24udG9wLFxuICAgIH07XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUpIHtcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIHZhciBwZXJjZW50ID0gTWF0aC5taW4odGltZSAvIGR1cmF0aW9uLCAxKTtcbiAgICAgICAgdmFyIGVhc2VkUGVyY2VudCA9IGVhc2luZyhwZXJjZW50KTtcbiAgICAgICAgdmFyIHVwZGF0ZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCAtIG9mZnNldC5sZWZ0ICogZWFzZWRQZXJjZW50LFxuICAgICAgICAgICAgdG9wOiB0b3AgLSBvZmZzZXQudG9wICogZWFzZWRQZXJjZW50LFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHNjcm9sbERpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbDpcbiAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsTGVmdCA9IHVwZGF0ZVBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Cb3RoOlxuICAgICAgICAgICAgICAgIGVsZS5zY3JvbGxMZWZ0ID0gdXBkYXRlUG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsVG9wID0gdXBkYXRlUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGVsZS5zY3JvbGxUb3AgPSB1cGRhdGVQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKHVwZGF0ZVBvc2l0aW9uLnRvcCAtIHRhcmdldFBvc2l0aW9uLnRvcCkgPD0gRVBTICYmXG4gICAgICAgICAgICBNYXRoLmFicyh1cGRhdGVQb3NpdGlvbi5sZWZ0IC0gdGFyZ2V0UG9zaXRpb24ubGVmdCkgPD0gRVBTICYmXG4gICAgICAgICAgICAhcmVhY2hUYXJnZXQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgbWFya1RhcmdldFJlYWNoZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICByZXF1ZXN0SWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3RJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG59O1xuXG52YXIgWkVST19PRkZTRVQkNiA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbn07XG52YXIgU0NST0xMX0VWRU5UX09QVElPTlMgPSB7XG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgcGFzc2l2ZTogdHJ1ZSxcbn07XG52YXIgU0NST0xMX0RVUkFUSU9OID0gNDAwO1xudmFyIHVzZVNjcm9sbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBlbGVtZW50UmVmID0gX2EuZWxlbWVudFJlZiwgZW5hYmxlU21vb3RoU2Nyb2xsID0gX2EuZW5hYmxlU21vb3RoU2Nyb2xsLCBpc1J0bCA9IF9hLmlzUnRsLCBzY3JvbGxEaXJlY3Rpb24gPSBfYS5zY3JvbGxEaXJlY3Rpb24sIG9uU21vb3RoU2Nyb2xsID0gX2Eub25TbW9vdGhTY3JvbGw7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShaRVJPX09GRlNFVCQ2KSwgc2Nyb2xsT2Zmc2V0ID0gX2JbMF0sIHNldFNjcm9sbE9mZnNldCA9IF9iWzFdO1xuICAgIHZhciBfYyA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoZWxlbWVudFJlZi5jdXJyZW50KSwgZWxlbWVudCA9IF9jWzBdLCBzZXRFbGVtZW50ID0gX2NbMV07XG4gICAgdmFyIGZhY3RvciA9IGlzUnRsID8gLTEgOiAxO1xuICAgIHZhciBsYXRlc3RSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihzY3JvbGxEaXJlY3Rpb24pO1xuICAgIGxhdGVzdFJlZi5jdXJyZW50ID0gc2Nyb2xsRGlyZWN0aW9uO1xuICAgIHZhciBsYXRlc3RPZmZzZXRSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihaRVJPX09GRlNFVCQ2KTtcbiAgICB2YXIgaXNTbW9vdGhTY3JvbGxpbmdEb25lUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYodHJ1ZSk7XG4gICAgdmFyIGhhbmRsZVNtb290aFNjcm9sbGluZ0NvbXBsZXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzU21vb3RoU2Nyb2xsaW5nRG9uZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVuYWJsZVNtb290aFNjcm9sbCkge1xuICAgICAgICAgICAgc2V0U2Nyb2xsT2Zmc2V0KGxhdGVzdE9mZnNldFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBvblNtb290aFNjcm9sbChmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBoYW5kbGVTY3JvbGwgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChsYXRlc3RSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbDpcbiAgICAgICAgICAgICAgICBsYXRlc3RPZmZzZXRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFjdG9yICogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkJvdGg6XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2Zmc2V0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhY3RvciAqIGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxhdGVzdE9mZnNldFJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmFibGVTbW9vdGhTY3JvbGwgfHwgaXNTbW9vdGhTY3JvbGxpbmdEb25lUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNldFNjcm9sbE9mZnNldChsYXRlc3RPZmZzZXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRFbGVtZW50KGVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCBTQ1JPTExfRVZFTlRfT1BUSU9OUyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCwgU0NST0xMX0VWRU5UX09QVElPTlMpO1xuICAgICAgICB9O1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgdmFyIHNjcm9sbFRvID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0UG9zaXRpb24sIHdpdGhTbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKGxhdGVzdFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uLmxlZnQgPSBmYWN0b3IgKiB0YXJnZXRQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uQm90aDpcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbi5sZWZ0ID0gZmFjdG9yICogdGFyZ2V0UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbi50b3AgPSB0YXJnZXRQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5WZXJ0aWNhbDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24udG9wID0gdGFyZ2V0UG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aXRoU21vb3RoU2Nyb2xsKSB7XG4gICAgICAgICAgICBpc1Ntb290aFNjcm9sbGluZ0RvbmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgb25TbW9vdGhTY3JvbGwodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIF8pIHtcbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGwoZWxlLCBsYXRlc3RSZWYuY3VycmVudCwgdXBkYXRlUG9zaXRpb24sIFNDUk9MTF9EVVJBVElPTiwgZWFzZU91dFF1YXJ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNtb290aFNjcm9sbGluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICAgICAgc3dpdGNoIChsYXRlc3RSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgICAgIGVsZS5zY3JvbGxMZWZ0ID0gdXBkYXRlUG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uQm90aDpcbiAgICAgICAgICAgICAgICAgICAgZWxlLnNjcm9sbExlZnQgPSB1cGRhdGVQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsVG9wID0gdXBkYXRlUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5WZXJ0aWNhbDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBlbGUuc2Nyb2xsVG9wID0gdXBkYXRlUG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2VsZW1lbnRSZWZdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JvbGxPZmZzZXQ6IHNjcm9sbE9mZnNldCxcbiAgICAgICAgc2Nyb2xsVG86IHNjcm9sbFRvLFxuICAgIH07XG59O1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiAobWluLCBtYXgsIHZhbHVlKSB7IHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTsgfTtcblxudmFyIGluZGV4T2ZNYXggPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpLCBhKSB7IHJldHVybiAoY3VyciA+IGFbcHJldl0gPyBpIDogcHJldik7IH0sIDApOyB9O1xuXG52YXIgYnVpbGRDb250YWluZXJTdHlsZXMgPSBmdW5jdGlvbiAodG90YWxTaXplLCBzY3JvbGxNb2RlKSB7XG4gICAgc3dpdGNoIChzY3JvbGxNb2RlKSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh0b3RhbFNpemUud2lkdGgsIFwicHhcIiksXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdCh0b3RhbFNpemUuaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICB9O1xuICAgIH1cbn07XG5cbnZhciBidWlsZEl0ZW1Db250YWluZXJTdHlsZXMgPSBmdW5jdGlvbiAoaXRlbSwgcGFyZW50UmVjdCwgc2Nyb2xsTW9kZSkge1xuICAgIHJldHVybiBzY3JvbGxNb2RlICE9PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZVxuICAgICAgICA/IHt9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChwYXJlbnRSZWN0LmhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdChpdGVtLnN0YXJ0LnRvcCwgXCJweClcIiksXG4gICAgICAgIH07XG59O1xuXG52YXIgaGFzRGlmZmVyZW50U2l6ZXMgPSBmdW5jdGlvbiAoc2l6ZXMpIHtcbiAgICB2YXIgbnVtYmVyT2ZJdGVtcyA9IHNpemVzLmxlbmd0aDtcbiAgICBpZiAobnVtYmVyT2ZJdGVtcyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgICAgIGlmIChzaXplc1tpXS5oZWlnaHQgIT09IHNpemVzWzBdLmhlaWdodCB8fCBzaXplc1tpXS53aWR0aCAhPT0gc2l6ZXNbMF0ud2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG52YXIgZ2V0TWluV2lkdGhPZkNvdmVyID0gZnVuY3Rpb24gKHNpemVzLCB2aWV3TW9kZSkge1xuICAgIGlmICh2aWV3TW9kZSAhPT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3Zlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKCFoYXNEaWZmZXJlbnRTaXplcyhzaXplcykpIHtcbiAgICAgICAgcmV0dXJuIDIgKiBzaXplc1swXS53aWR0aDtcbiAgICB9XG4gICAgdmFyIGNodW5rV2lkdGhzID0gY2h1bmsoc2l6ZXMuc2xpY2UoMSksIDIpLm1hcChmdW5jdGlvbiAoZWFjaENodW5rKSB7XG4gICAgICAgIHJldHVybiBlYWNoQ2h1bmsubGVuZ3RoID09PSAyID8gZWFjaENodW5rWzBdLndpZHRoICsgZWFjaENodW5rWzFdLndpZHRoIDogZWFjaENodW5rWzBdLndpZHRoO1xuICAgIH0pO1xuICAgIHZhciB3aWR0aHMgPSBbc2l6ZXNbMF0ud2lkdGhdLmNvbmNhdChjaHVua1dpZHRocyk7XG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHdpZHRocyk7XG59O1xudmFyIGJ1aWxkSXRlbVN0eWxlcyA9IGZ1bmN0aW9uIChpdGVtLCBpc1J0bCwgc2l6ZXMsIHZpZXdNb2RlLCBzY3JvbGxNb2RlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIHZhciBzaWRlUHJvcGVydHkgPSBpc1J0bCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgdmFyIGZhY3RvciA9IGlzUnRsID8gLTEgOiAxO1xuICAgIHZhciBudW1iZXJPZkl0ZW1zID0gc2l6ZXMubGVuZ3RoO1xuICAgIHZhciBsZWZ0ID0gaXRlbS5zdGFydC5sZWZ0ICogZmFjdG9yO1xuICAgIHZhciBfaCA9IGl0ZW0uc2l6ZSwgaGVpZ2h0ID0gX2guaGVpZ2h0LCB3aWR0aCA9IF9oLndpZHRoO1xuICAgIGlmICh2aWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3Zlcikge1xuICAgICAgICB2YXIgdHJhbnNmb3JtVG9wID0gc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UgPyAwIDogaXRlbS5zdGFydC50b3A7XG4gICAgICAgIGlmIChpdGVtLmluZGV4ID09PSAwIHx8IChudW1iZXJPZkl0ZW1zICUgMiA9PT0gMCAmJiBpdGVtLmluZGV4ID09PSBudW1iZXJPZkl0ZW1zIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfYSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBcIlwiLmNvbmNhdChnZXRNaW5XaWR0aE9mQ292ZXIoc2l6ZXMsIHZpZXdNb2RlKSwgXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Fbc2lkZVByb3BlcnR5XSA9IDAsXG4gICAgICAgICAgICAgICAgX2EucG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIF9hLnRvcCA9IDAsXG4gICAgICAgICAgICAgICAgX2EudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGxlZnQsIFwicHgsIFwiKS5jb25jYXQodHJhbnNmb3JtVG9wLCBcInB4KVwiKSxcbiAgICAgICAgICAgICAgICBfYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2IgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Jbc2lkZVByb3BlcnR5XSA9IDAsXG4gICAgICAgICAgICBfYi5wb3NpdGlvbiA9ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBfYi50b3AgPSAwLFxuICAgICAgICAgICAgX2IudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGxlZnQsIFwicHgsIFwiKS5jb25jYXQodHJhbnNmb3JtVG9wLCBcInB4KVwiKSxcbiAgICAgICAgICAgIF9iO1xuICAgIH1cbiAgICBpZiAodmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9jID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jW3NpZGVQcm9wZXJ0eV0gPSAwLFxuICAgICAgICAgICAgX2MucG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgX2MudG9wID0gMCxcbiAgICAgICAgICAgIF9jLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChsZWZ0LCBcInB4LCBcIikuY29uY2F0KHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlID8gMCA6IGl0ZW0uc3RhcnQudG9wLCBcInB4KVwiKSxcbiAgICAgICAgICAgIF9jO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNjcm9sbE1vZGUpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuSG9yaXpvbnRhbDpcbiAgICAgICAgICAgIHJldHVybiBfZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Rbc2lkZVByb3BlcnR5XSA9IDAsXG4gICAgICAgICAgICAgICAgX2QucG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIF9kLnRvcCA9IDAsXG4gICAgICAgICAgICAgICAgX2QudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChsZWZ0LCBcInB4KVwiKSxcbiAgICAgICAgICAgICAgICBfZDtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZTpcbiAgICAgICAgICAgIHJldHVybiBfZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vbc2lkZVByb3BlcnR5XSA9IDAsXG4gICAgICAgICAgICAgICAgX2UucG9zaXRpb24gPSAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIF9lLnRvcCA9IDAsXG4gICAgICAgICAgICAgICAgX2U7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLldyYXBwZWQ6XG4gICAgICAgICAgICByZXR1cm4gX2YgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9mW3NpZGVQcm9wZXJ0eV0gPSAwLFxuICAgICAgICAgICAgICAgIF9mLnBvc2l0aW9uID0gJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBfZi50b3AgPSAwLFxuICAgICAgICAgICAgICAgIF9mLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChsZWZ0LCBcInB4LCBcIikuY29uY2F0KGl0ZW0uc3RhcnQudG9wLCBcInB4KVwiKSxcbiAgICAgICAgICAgICAgICBfZjtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWw6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gX2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZ1tzaWRlUHJvcGVydHldID0gMCxcbiAgICAgICAgICAgICAgICBfZy5wb3NpdGlvbiA9ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgX2cudG9wID0gMCxcbiAgICAgICAgICAgICAgICBfZy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoXCIuY29uY2F0KGl0ZW0uc3RhcnQudG9wLCBcInB4KVwiKSxcbiAgICAgICAgICAgICAgICBfZztcbiAgICB9XG59O1xuXG52YXIgZmluZE5lYXJlc3QgPSBmdW5jdGlvbiAobG93LCBoaWdoLCB2YWx1ZSwgZ2V0SXRlbVZhbHVlKSB7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgIHZhciBtaWRkbGUgPSAoKGxvdyArIGhpZ2gpIC8gMikgfCAwO1xuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0SXRlbVZhbHVlKG1pZGRsZSk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiB2YWx1ZSkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3cgPiAwID8gbG93IC0gMSA6IDA7XG59O1xuXG52YXIgY2FsY3VsYXRlUmFuZ2UgPSBmdW5jdGlvbiAoc2Nyb2xsRGlyZWN0aW9uLCBtZWFzdXJlbWVudHMsIG91dGVyU2l6ZSwgc2Nyb2xsT2Zmc2V0KSB7XG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSAwO1xuICAgIHN3aXRjaCAoc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkhvcml6b250YWw6XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY3JvbGxEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBnZXRPZmZzZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChzY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQubGVmdDtcbiAgICAgICAgICAgIGNhc2UgU2Nyb2xsRGlyZWN0aW9uLkJvdGg6XG4gICAgICAgICAgICBjYXNlIFNjcm9sbERpcmVjdGlvbi5WZXJ0aWNhbDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQudG9wO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RhcnQgPSBmaW5kTmVhcmVzdCgwLCBzaXplLCBjdXJyZW50T2Zmc2V0LCBnZXRPZmZzZXQpO1xuICAgIGlmIChzY3JvbGxEaXJlY3Rpb24gPT09IFNjcm9sbERpcmVjdGlvbi5Cb3RoKSB7XG4gICAgICAgIHZhciBzdGFydFRvcCA9IG1lYXN1cmVtZW50c1tzdGFydF0uc3RhcnQudG9wO1xuICAgICAgICB3aGlsZSAoc3RhcnQgLSAxID49IDAgJiZcbiAgICAgICAgICAgIG1lYXN1cmVtZW50c1tzdGFydCAtIDFdLnN0YXJ0LnRvcCA9PT0gc3RhcnRUb3AgJiZcbiAgICAgICAgICAgIG1lYXN1cmVtZW50c1tzdGFydCAtIDFdLnN0YXJ0LmxlZnQgPj0gc2Nyb2xsT2Zmc2V0LmxlZnQpIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGVuZCA9IHN0YXJ0O1xuICAgIHdoaWxlIChlbmQgPD0gc2l6ZSkge1xuICAgICAgICB2YXIgdG9wTGVmdENvcm5lciA9IHtcbiAgICAgICAgICAgIHRvcDogbWVhc3VyZW1lbnRzW2VuZF0uc3RhcnQudG9wIC0gc2Nyb2xsT2Zmc2V0LnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IG1lYXN1cmVtZW50c1tlbmRdLnN0YXJ0LmxlZnQgLSBzY3JvbGxPZmZzZXQubGVmdCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZpc2libGVTaXplID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiBvdXRlclNpemUuaGVpZ2h0IC0gdG9wTGVmdENvcm5lci50b3AsXG4gICAgICAgICAgICB3aWR0aDogb3V0ZXJTaXplLndpZHRoIC0gdG9wTGVmdENvcm5lci5sZWZ0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uSG9yaXpvbnRhbCAmJiB2aXNpYmxlU2l6ZS53aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxEaXJlY3Rpb24gPT09IFNjcm9sbERpcmVjdGlvbi5WZXJ0aWNhbCAmJiB2aXNpYmxlU2l6ZS5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxEaXJlY3Rpb24uQm90aCAmJiAodmlzaWJsZVNpemUud2lkdGggPCAwIHx8IHZpc2libGVTaXplLmhlaWdodCA8IDApKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbmQrKztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICB9O1xufTtcblxudmFyIFpFUk9fT0ZGU0VUJDUgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIG1lYXN1cmUgPSBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcywgcGFyZW50UmVjdCwgc2l6ZXMsIHNjcm9sbE1vZGUpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnRzID0gW107XG4gICAgdmFyIHRvdGFsV2lkdGggPSAwO1xuICAgIHZhciBmaXJzdE9mUm93ID0ge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgfTtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcbiAgICB2YXIgc3RhcnQgPSBaRVJPX09GRlNFVCQ1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgICAgIHZhciBzaXplID0gc2l6ZXNbaV07XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0b3RhbFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGZpcnN0T2ZSb3cgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNjcm9sbE1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5XcmFwcGVkOlxuICAgICAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IHNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoIDwgcGFyZW50UmVjdC53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWVhc3VyZW1lbnRzW2kgLSAxXS5lbmQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGZpcnN0T2ZSb3cudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmaXJzdE9mUm93LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBmaXJzdE9mUm93LnRvcCArIG1heEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE9mUm93ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHN0YXJ0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBzdGFydC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuSG9yaXpvbnRhbDpcbiAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1lYXN1cmVtZW50c1tpIC0gMV0uZW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0ge1xuICAgICAgICAgICAgbGVmdDogc3RhcnQubGVmdCArIHNpemUud2lkdGgsXG4gICAgICAgICAgICB0b3A6IHN0YXJ0LnRvcCArIHNpemUuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBtZWFzdXJlbWVudHNbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IC0xLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xufTtcblxudmFyIFpFUk9fT0ZGU0VUJDQgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG59O1xudmFyIG1lYXN1cmVEdWFsUGFnZSA9IGZ1bmN0aW9uIChudW1iZXJPZkl0ZW1zLCBwYXJlbnRSZWN0LCBzaXplcywgc2Nyb2xsTW9kZSkge1xuICAgIHZhciBtZWFzdXJlbWVudHMgPSBbXTtcbiAgICB2YXIgdG9wID0gMDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcbiAgICB2YXIgc3RhcnQgPSBaRVJPX09GRlNFVCQ0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgICAgIHZhciBzaXplID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSA/IE1hdGgubWF4KHBhcmVudFJlY3QuaGVpZ2h0LCBzaXplc1tpXS5oZWlnaHQpIDogc2l6ZXNbaV0uaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHBhcmVudFJlY3Qud2lkdGggLyAyLCBzaXplc1tpXS53aWR0aCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSkge1xuICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogaSAlIDIgPT09IDAgPyAwIDogc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IoaSAvIDIpICogc2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gdG9wICsgbWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGkgPT09IG51bWJlck9mSXRlbXMgLSAxID8gc2l6ZXNbaV0uaGVpZ2h0IDogTWF0aC5tYXgoc2l6ZXNbaV0uaGVpZ2h0LCBzaXplc1tpICsgMV0uaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtZWFzdXJlbWVudHNbaSAtIDFdLmVuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlbmQgPSB7XG4gICAgICAgICAgICBsZWZ0OiBzdGFydC5sZWZ0ICsgc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHRvcDogc3RhcnQudG9wICsgc2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogLTEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG59O1xuXG52YXIgWkVST19PRkZTRVQkMyA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbn07XG52YXIgbWVhc3VyZUR1YWxQYWdlV2l0aENvdmVyID0gZnVuY3Rpb24gKG51bWJlck9mSXRlbXMsIHBhcmVudFJlY3QsIHNpemVzLCBzY3JvbGxNb2RlKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IFtdO1xuICAgIHZhciB0b3AgPSAwO1xuICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuICAgIHZhciBzdGFydCA9IFpFUk9fT0ZGU0VUJDM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkl0ZW1zOyBpKyspIHtcbiAgICAgICAgdmFyIHNpemUgPSBpID09PSAwXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgocGFyZW50UmVjdC5oZWlnaHQsIHNpemVzW2ldLmhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgOiBzaXplc1tpXS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlID8gTWF0aC5tYXgocGFyZW50UmVjdC53aWR0aCwgc2l6ZXNbaV0ud2lkdGgpIDogc2l6ZXNbaV0ud2lkdGgsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgocGFyZW50UmVjdC5oZWlnaHQsIHNpemVzW2ldLmhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgOiBzaXplc1tpXS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KHBhcmVudFJlY3Qud2lkdGggLyAyLCBzaXplc1tpXS53aWR0aCksXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAoc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UpIHtcbiAgICAgICAgICAgIHN0YXJ0ID1cbiAgICAgICAgICAgICAgICBpID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gWkVST19PRkZTRVQkM1xuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGkgJSAyID09PSAwID8gc2l6ZS53aWR0aCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IoKGkgLSAxKSAvIDIpICogc2l6ZS5oZWlnaHQgKyBtZWFzdXJlbWVudHNbMF0uZW5kLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBaRVJPX09GRlNFVCQzO1xuICAgICAgICAgICAgICAgIHRvcCA9IHNpemVzWzBdLmhlaWdodDtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0b3AgKyBtYXhIZWlnaHQ7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gaSA9PT0gbnVtYmVyT2ZJdGVtcyAtIDEgPyBzaXplc1tpXS5oZWlnaHQgOiBNYXRoLm1heChzaXplc1tpXS5oZWlnaHQsIHNpemVzW2kgKyAxXS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1lYXN1cmVtZW50c1tpIC0gMV0uZW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHN0YXJ0LmxlZnQgKyBzaXplLndpZHRoLFxuICAgICAgICAgICAgdG9wOiBzdGFydC50b3AgKyBzaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiAtMSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbn07XG5cbnZhciBaRVJPX09GRlNFVCQyID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxufTtcbnZhciBtZWFzdXJlU2luZ2xlUGFnZSA9IGZ1bmN0aW9uIChudW1iZXJPZkl0ZW1zLCBwYXJlbnRSZWN0LCBzaXplcykge1xuICAgIHZhciBtZWFzdXJlbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSXRlbXM7IGkrKykge1xuICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgocGFyZW50UmVjdC5oZWlnaHQsIHNpemVzW2ldLmhlaWdodCksXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgocGFyZW50UmVjdC53aWR0aCwgc2l6ZXNbaV0ud2lkdGgpLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RhcnQgPSBpID09PSAwID8gWkVST19PRkZTRVQkMiA6IG1lYXN1cmVtZW50c1tpIC0gMV0uZW5kO1xuICAgICAgICB2YXIgZW5kID0ge1xuICAgICAgICAgICAgbGVmdDogc3RhcnQubGVmdCArIHNpemUud2lkdGgsXG4gICAgICAgICAgICB0b3A6IHN0YXJ0LnRvcCArIHNpemUuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBtZWFzdXJlbWVudHNbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IC0xLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbWVhc3VyZW1lbnRzO1xufTtcblxudmFyIFpFUk9fUkVDVCQyID0ge1xuICAgIGhlaWdodDogMCxcbiAgICB3aWR0aDogMCxcbn07XG52YXIgWkVST19PRkZTRVQkMSA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbn07XG52YXIgQ09NUEFSRV9FUFNJTE9OID0gMC4wMDAwMDAwMDAwMDE7XG52YXIgVklSVFVBTF9JTkRFWF9BVFRSID0gJ2RhdGEtdmlydHVhbC1pbmRleCc7XG52YXIgSU9fVEhSRVNIT0xEID0gWzAsIDAuMSwgMC4yLCAwLjMsIDAuNCwgMC41LCAwLjYsIDAuNywgMC44LCAwLjksIDFdO1xudmFyIHVzZVZpcnR1YWwgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZW5hYmxlU21vb3RoU2Nyb2xsID0gX2EuZW5hYmxlU21vb3RoU2Nyb2xsLCBpc1J0bCA9IF9hLmlzUnRsLCBudW1iZXJPZkl0ZW1zID0gX2EubnVtYmVyT2ZJdGVtcywgcGFyZW50UmVmID0gX2EucGFyZW50UmVmLCBzZXRSZW5kZXJSYW5nZSA9IF9hLnNldFJlbmRlclJhbmdlLCBzaXplcyA9IF9hLnNpemVzLCBzY3JvbGxNb2RlID0gX2Euc2Nyb2xsTW9kZSwgdmlld01vZGUgPSBfYS52aWV3TW9kZTtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKSwgaXNTbW9vdGhTY3JvbGxpbmcgPSBfYlswXSwgc2V0U21vb3RoU2Nyb2xsaW5nID0gX2JbMV07XG4gICAgdmFyIG9uU21vb3RoU2Nyb2xsID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoaXNTbW9vdGhTY3JvbGxpbmcpIHsgcmV0dXJuIHNldFNtb290aFNjcm9sbGluZyhpc1Ntb290aFNjcm9sbGluZyk7IH0sIFtdKTtcbiAgICB2YXIgc2Nyb2xsTW9kZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHNjcm9sbE1vZGUpO1xuICAgIHNjcm9sbE1vZGVSZWYuY3VycmVudCA9IHNjcm9sbE1vZGU7XG4gICAgdmFyIHZpZXdNb2RlUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYodmlld01vZGUpO1xuICAgIHZpZXdNb2RlUmVmLmN1cnJlbnQgPSB2aWV3TW9kZTtcbiAgICB2YXIgc2Nyb2xsRGlyZWN0aW9uID0gc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLldyYXBwZWQgfHwgdmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIgfHwgdmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VcbiAgICAgICAgPyBTY3JvbGxEaXJlY3Rpb24uQm90aFxuICAgICAgICA6IHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5Ib3Jpem9udGFsXG4gICAgICAgICAgICA/IFNjcm9sbERpcmVjdGlvbi5Ib3Jpem9udGFsXG4gICAgICAgICAgICA6IFNjcm9sbERpcmVjdGlvbi5WZXJ0aWNhbDtcbiAgICB2YXIgX2MgPSB1c2VTY3JvbGwoe1xuICAgICAgICBlbGVtZW50UmVmOiBwYXJlbnRSZWYsXG4gICAgICAgIGVuYWJsZVNtb290aFNjcm9sbDogZW5hYmxlU21vb3RoU2Nyb2xsLFxuICAgICAgICBpc1J0bDogaXNSdGwsXG4gICAgICAgIHNjcm9sbERpcmVjdGlvbjogc2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICBvblNtb290aFNjcm9sbDogb25TbW9vdGhTY3JvbGwsXG4gICAgfSksIHNjcm9sbE9mZnNldCA9IF9jLnNjcm9sbE9mZnNldCwgc2Nyb2xsVG8gPSBfYy5zY3JvbGxUbztcbiAgICB2YXIgcGFyZW50UmVjdCA9IHVzZU1lYXN1cmVSZWN0KHtcbiAgICAgICAgZWxlbWVudFJlZjogcGFyZW50UmVmLFxuICAgIH0pO1xuICAgIHZhciBsYXRlc3RSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZih7XG4gICAgICAgIHNjcm9sbE9mZnNldDogWkVST19PRkZTRVQkMSxcbiAgICAgICAgbWVhc3VyZW1lbnRzOiBbXSxcbiAgICB9KTtcbiAgICBsYXRlc3RSZWYuY3VycmVudC5zY3JvbGxPZmZzZXQgPSBzY3JvbGxPZmZzZXQ7XG4gICAgdmFyIGRlZmF1bHRWaXNpYmlsaXRpZXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkobnVtYmVyT2ZJdGVtcykuZmlsbCgtMSk7IH0sIFtdKTtcbiAgICB2YXIgX2QgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGRlZmF1bHRWaXNpYmlsaXRpZXMpLCB2aXNpYmlsaXRpZXMgPSBfZFswXSwgc2V0VmlzaWJpbGl0aWVzID0gX2RbMV07XG4gICAgdmFyIGludGVyc2VjdGlvblRyYWNrZXIgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBlbnRyeS5pc0ludGVyc2VjdGluZyA/IGVudHJ5LmludGVyc2VjdGlvblJhdGlvIDogLTE7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGVudHJ5LnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBdHRyaWJ1dGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFZJUlRVQUxfSU5ERVhfQVRUUik7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGluZGV4QXR0cmlidXRlLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gaW5kZXggJiYgaW5kZXggPCBudW1iZXJPZkl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFZpc2liaWxpdGllcyhmdW5jdGlvbiAob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRbaW5kZXhdID0gcmF0aW87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShbXSwgb2xkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRocmVzaG9sZDogSU9fVEhSRVNIT0xELFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlvO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgbWVhc3VyZW1lbnRzID0gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlICYmIHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLlNpbmdsZVBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWFzdXJlU2luZ2xlUGFnZShudW1iZXJPZkl0ZW1zLCBwYXJlbnRSZWN0LCBzaXplcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVhc3VyZUR1YWxQYWdlV2l0aENvdmVyKG51bWJlck9mSXRlbXMsIHBhcmVudFJlY3QsIHNpemVzLCBzY3JvbGxNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtZWFzdXJlRHVhbFBhZ2UobnVtYmVyT2ZJdGVtcywgcGFyZW50UmVjdCwgc2l6ZXMsIHNjcm9sbE1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWFzdXJlKG51bWJlck9mSXRlbXMsIHBhcmVudFJlY3QsIHNpemVzLCBzY3JvbGxNb2RlKTtcbiAgICB9LCBbc2Nyb2xsTW9kZSwgc2l6ZXMsIHZpZXdNb2RlLCBwYXJlbnRSZWN0XSk7XG4gICAgdmFyIHRvdGFsU2l6ZSA9IG1lYXN1cmVtZW50c1tudW1iZXJPZkl0ZW1zIC0gMV1cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBoZWlnaHQ6IG1lYXN1cmVtZW50c1tudW1iZXJPZkl0ZW1zIC0gMV0uZW5kLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBtZWFzdXJlbWVudHNbbnVtYmVyT2ZJdGVtcyAtIDFdLmVuZC5sZWZ0LFxuICAgICAgICB9XG4gICAgICAgIDogWkVST19SRUNUJDI7XG4gICAgbGF0ZXN0UmVmLmN1cnJlbnQubWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzO1xuICAgIHZhciBfZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IGNhbGN1bGF0ZVJhbmdlKHNjcm9sbERpcmVjdGlvbiwgbWVhc3VyZW1lbnRzLCBwYXJlbnRSZWN0LCBzY3JvbGxPZmZzZXQpLCBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQ7XG4gICAgICAgIHZhciB2aXNpYmxlUGFnZVZpc2liaWxpdGllcyA9IHZpc2liaWxpdGllcy5zbGljZShjbGFtcCgwLCBudW1iZXJPZkl0ZW1zLCBzdGFydCksIGNsYW1wKDAsIG51bWJlck9mSXRlbXMsIGVuZCkpO1xuICAgICAgICB2YXIgbWF4VmlzYmlsaXR5SXRlbSA9IHN0YXJ0ICsgaW5kZXhPZk1heCh2aXNpYmxlUGFnZVZpc2liaWxpdGllcyk7XG4gICAgICAgIG1heFZpc2JpbGl0eUl0ZW0gPSBjbGFtcCgwLCBudW1iZXJPZkl0ZW1zIC0gMSwgbWF4VmlzYmlsaXR5SXRlbSk7XG4gICAgICAgIHZhciBtYXhWaXNiaWxpdHlJbmRleCA9IG1heFZpc2JpbGl0eUl0ZW07XG4gICAgICAgIHZhciBfYiA9IHNldFJlbmRlclJhbmdlKHtcbiAgICAgICAgICAgIGVuZFBhZ2U6IGVuZCxcbiAgICAgICAgICAgIG51bVBhZ2VzOiBudW1iZXJPZkl0ZW1zLFxuICAgICAgICAgICAgc3RhcnRQYWdlOiBzdGFydCxcbiAgICAgICAgfSksIHN0YXJ0UGFnZSA9IF9iLnN0YXJ0UGFnZSwgZW5kUGFnZSA9IF9iLmVuZFBhZ2U7XG4gICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KHN0YXJ0UGFnZSwgMCk7XG4gICAgICAgIGVuZFBhZ2UgPSBNYXRoLm1pbihlbmRQYWdlLCBudW1iZXJPZkl0ZW1zIC0gMSk7XG4gICAgICAgIHN3aXRjaCAodmlld01vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3ZlcjpcbiAgICAgICAgICAgICAgICBpZiAobWF4VmlzYmlsaXR5SXRlbSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmlzYmlsaXR5SW5kZXggPSBtYXhWaXNiaWxpdHlJdGVtICUgMiA9PT0gMSA/IG1heFZpc2JpbGl0eUl0ZW0gOiBtYXhWaXNiaWxpdHlJdGVtIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnRQYWdlID0gc3RhcnRQYWdlID09PSAwID8gMCA6IHN0YXJ0UGFnZSAlIDIgPT09IDEgPyBzdGFydFBhZ2UgOiBzdGFydFBhZ2UgLSAxO1xuICAgICAgICAgICAgICAgIGVuZFBhZ2UgPSBlbmRQYWdlICUgMiA9PT0gMSA/IGVuZFBhZ2UgLSAxIDogZW5kUGFnZTtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyT2ZJdGVtcyAtIGVuZFBhZ2UgPD0gMikge1xuICAgICAgICAgICAgICAgICAgICBlbmRQYWdlID0gbnVtYmVyT2ZJdGVtcyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlOlxuICAgICAgICAgICAgICAgIG1heFZpc2JpbGl0eUluZGV4ID0gbWF4VmlzYmlsaXR5SXRlbSAlIDIgPT09IDAgPyBtYXhWaXNiaWxpdHlJdGVtIDogbWF4VmlzYmlsaXR5SXRlbSAtIDE7XG4gICAgICAgICAgICAgICAgc3RhcnRQYWdlID0gc3RhcnRQYWdlICUgMiA9PT0gMCA/IHN0YXJ0UGFnZSA6IHN0YXJ0UGFnZSAtIDE7XG4gICAgICAgICAgICAgICAgZW5kUGFnZSA9IGVuZFBhZ2UgJSAyID09PSAxID8gZW5kUGFnZSA6IGVuZFBhZ2UgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLlNpbmdsZVBhZ2U6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1heFZpc2JpbGl0eUluZGV4ID0gbWF4VmlzYmlsaXR5SXRlbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRQYWdlOiBzdGFydFBhZ2UsXG4gICAgICAgICAgICBlbmRQYWdlOiBlbmRQYWdlLFxuICAgICAgICAgICAgbWF4VmlzYmlsaXR5SW5kZXg6IG1heFZpc2JpbGl0eUluZGV4LFxuICAgICAgICB9O1xuICAgIH0sIFttZWFzdXJlbWVudHMsIHBhcmVudFJlY3QsIHNjcm9sbE9mZnNldCwgdmlld01vZGUsIHZpc2liaWxpdGllc10pLCBzdGFydFBhZ2UgPSBfZS5zdGFydFBhZ2UsIGVuZFBhZ2UgPSBfZS5lbmRQYWdlLCBtYXhWaXNiaWxpdHlJbmRleCA9IF9lLm1heFZpc2JpbGl0eUluZGV4O1xuICAgIHZhciB2aXJ0dWFsSXRlbXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmlydHVhbEl0ZW1zID0gW107XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHZpcnR1YWxJdGVtID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IHZpc2liaWxpdHk6IHZpc2liaWxpdGllc1tpXSAhPT0gdW5kZWZpbmVkID8gdmlzaWJpbGl0aWVzW2ldIDogLTEsIG1lYXN1cmVSZWY6IGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKFZJUlRVQUxfSU5ERVhfQVRUUiwgXCJcIi5jb25jYXQoaSkpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25UcmFja2VyLm9ic2VydmUoZWxlKTtcbiAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgdmlydHVhbEl0ZW1zLnB1c2godmlydHVhbEl0ZW0pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRQYWdlOyBpIDw9IGVuZFBhZ2U7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICAgIH0sIFtzdGFydFBhZ2UsIGVuZFBhZ2UsIHZpc2liaWxpdGllcywgbWVhc3VyZW1lbnRzXSk7XG4gICAgdmFyIHNjcm9sbFRvSXRlbSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIG1lYXN1cmVtZW50cyA9IGxhdGVzdFJlZi5jdXJyZW50Lm1lYXN1cmVtZW50cztcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbmRleCA9IGNsYW1wKDAsIG51bWJlck9mSXRlbXMgLSAxLCBpbmRleCk7XG4gICAgICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tub3JtYWxpemVkSW5kZXhdO1xuICAgICAgICB2YXIgd2l0aE9mZnNldCA9IHNjcm9sbE1vZGVSZWYuY3VycmVudCA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UgPyBaRVJPX09GRlNFVCQxIDogb2Zmc2V0O1xuICAgICAgICByZXR1cm4gbWVhc3VyZW1lbnRcbiAgICAgICAgICAgID8gc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGxlZnQ6IHdpdGhPZmZzZXQubGVmdCArIG1lYXN1cmVtZW50LnN0YXJ0LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB3aXRoT2Zmc2V0LnRvcCArIG1lYXN1cmVtZW50LnN0YXJ0LnRvcCxcbiAgICAgICAgICAgIH0sIGVuYWJsZVNtb290aFNjcm9sbClcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSwgW3Njcm9sbFRvLCBlbmFibGVTbW9vdGhTY3JvbGxdKTtcbiAgICB2YXIgc2Nyb2xsVG9TbWFsbGVzdEl0ZW1BYm92ZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIG1lYXN1cmVtZW50cyA9IGxhdGVzdFJlZi5jdXJyZW50Lm1lYXN1cmVtZW50cztcbiAgICAgICAgdmFyIHN0YXJ0ID0gbWVhc3VyZW1lbnRzW2luZGV4XS5zdGFydDtcbiAgICAgICAgdmFyIG5leHRJdGVtID0gbWVhc3VyZW1lbnRzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc3RhcnQudG9wIC0gc3RhcnQudG9wID4gQ09NUEFSRV9FUFNJTE9OOyB9KTtcbiAgICAgICAgaWYgKCFuZXh0SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSBuZXh0SXRlbS5pbmRleDtcbiAgICAgICAgc3dpdGNoICh2aWV3TW9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2U6XG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gbmV4dEluZGV4ICUgMiA9PT0gMCA/IG5leHRJbmRleCA6IG5leHRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXI6XG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gbmV4dEluZGV4ICUgMiA9PT0gMSA/IG5leHRJbmRleCA6IG5leHRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjcm9sbFRvSXRlbShuZXh0SW5kZXgsIG9mZnNldCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxUb0JpZ2dlc3RJdGVtQmVsb3cgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBtZWFzdXJlbWVudHMgPSBsYXRlc3RSZWYuY3VycmVudC5tZWFzdXJlbWVudHM7XG4gICAgICAgIHZhciBzdGFydCA9IG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQ7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSBudW1iZXJPZkl0ZW1zIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChzdGFydC50b3AgLSBtZWFzdXJlbWVudHNbaV0uc3RhcnQudG9wID4gQ09NUEFSRV9FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IG1lYXN1cmVtZW50c1tpXS5pbmRleDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2aWV3TW9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2U6XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gcHJldkluZGV4ICUgMiA9PT0gMCA/IHByZXZJbmRleCA6IHByZXZJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXI6XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gcHJldkluZGV4ICUgMiA9PT0gMCA/IHByZXZJbmRleCAtIDEgOiBwcmV2SW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Nyb2xsVG9JdGVtKHByZXZJbmRleCwgb2Zmc2V0KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbFRvTmV4dEl0ZW0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2aWV3TW9kZVJlZi5jdXJyZW50ID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyIHx8IHZpZXdNb2RlUmVmLmN1cnJlbnQgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb1NtYWxsZXN0SXRlbUFib3ZlKGluZGV4LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2Nyb2xsTW9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5XcmFwcGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb1NtYWxsZXN0SXRlbUFib3ZlKGluZGV4LCBvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuSG9yaXpvbnRhbDpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLlZlcnRpY2FsOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9JdGVtKGluZGV4ICsgMSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB2YXIgc2Nyb2xsVG9QcmV2aW91c0l0ZW0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2aWV3TW9kZVJlZi5jdXJyZW50ID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyIHx8IHZpZXdNb2RlUmVmLmN1cnJlbnQgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb0JpZ2dlc3RJdGVtQmVsb3coaW5kZXgsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzY3JvbGxNb2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLldyYXBwZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbFRvQmlnZ2VzdEl0ZW1CZWxvdyhpbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbFRvSXRlbShpbmRleCAtIDEsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIGdldENvbnRhaW5lclN0eWxlcyA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVpbGRDb250YWluZXJTdHlsZXModG90YWxTaXplLCBzY3JvbGxNb2RlUmVmLmN1cnJlbnQpOyB9LCBbdG90YWxTaXplXSk7XG4gICAgdmFyIGdldEl0ZW1Db250YWluZXJTdHlsZXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBidWlsZEl0ZW1Db250YWluZXJTdHlsZXMoaXRlbSwgcGFyZW50UmVjdCwgc2Nyb2xsTW9kZVJlZi5jdXJyZW50KTsgfSwgW3BhcmVudFJlY3RdKTtcbiAgICB2YXIgZ2V0SXRlbVN0eWxlcyA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGJ1aWxkSXRlbVN0eWxlcyhpdGVtLCBpc1J0bCwgc2l6ZXMsIHZpZXdNb2RlUmVmLmN1cnJlbnQsIHNjcm9sbE1vZGVSZWYuY3VycmVudCk7IH0sIFtpc1J0bCwgc2l6ZXNdKTtcbiAgICB2YXIgem9vbSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNjYWxlLCBpbmRleCkge1xuICAgICAgICB2YXIgX2EgPSBsYXRlc3RSZWYuY3VycmVudCwgbWVhc3VyZW1lbnRzID0gX2EubWVhc3VyZW1lbnRzLCBzY3JvbGxPZmZzZXQgPSBfYS5zY3JvbGxPZmZzZXQ7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5kZXggPSBjbGFtcCgwLCBudW1iZXJPZkl0ZW1zIC0gMSwgaW5kZXgpO1xuICAgICAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbbm9ybWFsaXplZEluZGV4XTtcbiAgICAgICAgaWYgKG1lYXN1cmVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlT2Zmc2V0ID0gc2Nyb2xsTW9kZVJlZi5jdXJyZW50ID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtZWFzdXJlbWVudC5zdGFydC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IG1lYXN1cmVtZW50LnN0YXJ0LnRvcCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNjcm9sbE9mZnNldC5sZWZ0ICogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc2Nyb2xsT2Zmc2V0LnRvcCAqIHNjYWxlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG8odXBkYXRlT2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25UcmFja2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm91bmRpbmdDbGllbnRSZWN0OiBwYXJlbnRSZWN0LFxuICAgICAgICBpc1Ntb290aFNjcm9sbGluZzogaXNTbW9vdGhTY3JvbGxpbmcsXG4gICAgICAgIHN0YXJ0UGFnZTogc3RhcnRQYWdlLFxuICAgICAgICBlbmRQYWdlOiBlbmRQYWdlLFxuICAgICAgICBtYXhWaXNiaWxpdHlJbmRleDogbWF4VmlzYmlsaXR5SW5kZXgsXG4gICAgICAgIHZpcnR1YWxJdGVtczogdmlydHVhbEl0ZW1zLFxuICAgICAgICBnZXRDb250YWluZXJTdHlsZXM6IGdldENvbnRhaW5lclN0eWxlcyxcbiAgICAgICAgZ2V0SXRlbUNvbnRhaW5lclN0eWxlczogZ2V0SXRlbUNvbnRhaW5lclN0eWxlcyxcbiAgICAgICAgZ2V0SXRlbVN0eWxlczogZ2V0SXRlbVN0eWxlcyxcbiAgICAgICAgc2Nyb2xsVG9JdGVtOiBzY3JvbGxUb0l0ZW0sXG4gICAgICAgIHNjcm9sbFRvTmV4dEl0ZW06IHNjcm9sbFRvTmV4dEl0ZW0sXG4gICAgICAgIHNjcm9sbFRvUHJldmlvdXNJdGVtOiBzY3JvbGxUb1ByZXZpb3VzSXRlbSxcbiAgICAgICAgem9vbTogem9vbSxcbiAgICB9O1xufTtcblxudmFyIFNDUk9MTF9CQVJfV0lEVEggPSAxNztcbnZhciBQQUdFX1BBRERJTkcgPSA4O1xudmFyIGNhbGN1bGF0ZVNjYWxlID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgcGFnZUhlaWdodCwgcGFnZVdpZHRoLCBzY2FsZSwgdmlld01vZGUsIG51bVBhZ2VzKSB7XG4gICAgdmFyIHcgPSBwYWdlV2lkdGg7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2Ugdmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIgJiYgbnVtUGFnZXMgPj0gMzpcbiAgICAgICAgY2FzZSB2aWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZSAmJiBudW1QYWdlcyA+PSAzOlxuICAgICAgICAgICAgdyA9IDIgKiBwYWdlV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHcgPSBwYWdlV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoIChzY2FsZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5BY3R1YWxTaXplOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TcGVjaWFsWm9vbUxldmVsLlBhZ2VGaXQ6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oKGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIFNDUk9MTF9CQVJfV0lEVEgpIC8gdywgKGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSAyICogUEFHRV9QQURESU5HKSAvIHBhZ2VIZWlnaHQpO1xuICAgICAgICBjYXNlIGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlV2lkdGg6XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIFNDUk9MTF9CQVJfV0lEVEgpIC8gdztcbiAgICB9XG59O1xuXG52YXIgdXNlU3RhY2sgPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgdmFyIHN0YWNrUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoW10pO1xuICAgIHZhciBtYXAgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrUmVmLmN1cnJlbnQubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiB0cmFuc2Zvcm1lcihpdGVtKTsgfSk7XG4gICAgfTtcbiAgICB2YXIgcG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBzdGFja1JlZi5jdXJyZW50O1xuICAgICAgICB2YXIgc2l6ZSA9IHN0YWNrLmxlbmd0aDtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0SXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFja1JlZi5jdXJyZW50ID0gc3RhY2s7XG4gICAgICAgIHJldHVybiBsYXN0SXRlbTtcbiAgICB9O1xuICAgIHZhciBwdXNoID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCArIDEgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChpdGVtKTtcbiAgICAgICAgc3RhY2tSZWYuY3VycmVudCA9IHN0YWNrO1xuICAgIH07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhY2tSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgcG9wOiBwb3AsXG4gICAgfTtcbn07XG5cbnZhciB1c2VRdWV1ZSA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICB2YXIgcXVldWVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihbXSk7XG4gICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHF1ZXVlUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBzaXplID0gcXVldWUubGVuZ3RoO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0SXRlbSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHF1ZXVlUmVmLmN1cnJlbnQgPSBxdWV1ZTtcbiAgICAgICAgcmV0dXJuIGZpcnN0SXRlbSB8fCBudWxsO1xuICAgIH07XG4gICAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgcXVldWUgPSBxdWV1ZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAocXVldWUubGVuZ3RoICsgMSA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgcXVldWUucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVSZWYuY3VycmVudCA9IFtpdGVtXS5jb25jYXQocXVldWUpO1xuICAgIH07XG4gICAgdmFyIG1hcCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gcXVldWVSZWYuY3VycmVudC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHRyYW5zZm9ybWVyKGl0ZW0pOyB9KTtcbiAgICB9O1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHF1ZXVlUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVxdWV1ZTogZGVxdWV1ZSxcbiAgICAgICAgZW5xdWV1ZTogZW5xdWV1ZSxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgfTtcbn07XG5cbnZhciBNQVhfUVVFVUVfTEVOR1RIID0gNTA7XG52YXIgdXNlRGVzdGluYXRpb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZ2V0Q3VycmVudFBhZ2UgPSBfYS5nZXRDdXJyZW50UGFnZTtcbiAgICB2YXIgcHJldmlvdXNEZXN0aW5hdGlvbnMgPSB1c2VTdGFjayhNQVhfUVVFVUVfTEVOR1RIKTtcbiAgICB2YXIgbmV4dERlc3RpbmF0aW9ucyA9IHVzZVF1ZXVlKE1BWF9RVUVVRV9MRU5HVEgpO1xuICAgIHZhciBnZXROZXh0RGVzdGluYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0RGVzdCA9IG5leHREZXN0aW5hdGlvbnMuZGVxdWV1ZSgpO1xuICAgICAgICBpZiAobmV4dERlc3QpIHtcbiAgICAgICAgICAgIHByZXZpb3VzRGVzdGluYXRpb25zLnB1c2gobmV4dERlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0RGVzdCAmJiBuZXh0RGVzdC5wYWdlSW5kZXggPT09IGdldEN1cnJlbnRQYWdlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0RGVzdGluYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dERlc3Q7XG4gICAgfTtcbiAgICB2YXIgZ2V0UHJldmlvdXNEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZEZXN0ID0gcHJldmlvdXNEZXN0aW5hdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChwcmV2RGVzdCkge1xuICAgICAgICAgICAgbmV4dERlc3RpbmF0aW9ucy5lbnF1ZXVlKHByZXZEZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkRlc3QgJiYgcHJldkRlc3QucGFnZUluZGV4ID09PSBnZXRDdXJyZW50UGFnZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJldmlvdXNEZXN0aW5hdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2RGVzdDtcbiAgICB9O1xuICAgIHZhciBtYXJrVmlzaXRlZERlc3RpbmF0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgcHJldmlvdXNEZXN0aW5hdGlvbnMucHVzaChkZXN0aW5hdGlvbik7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldE5leHREZXN0aW5hdGlvbjogZ2V0TmV4dERlc3RpbmF0aW9uLFxuICAgICAgICBnZXRQcmV2aW91c0Rlc3RpbmF0aW9uOiBnZXRQcmV2aW91c0Rlc3RpbmF0aW9uLFxuICAgICAgICBtYXJrVmlzaXRlZERlc3RpbmF0aW9uOiBtYXJrVmlzaXRlZERlc3RpbmF0aW9uLFxuICAgIH07XG59O1xuXG52YXIgZmxhdGVyblNpbmdsZU91dGxpbmUgPSBmdW5jdGlvbiAob3V0bGluZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAob3V0bGluZS5pdGVtcyAmJiBvdXRsaW5lLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChmbGF0ZXJuT3V0bGluZXMob3V0bGluZS5pdGVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBmbGF0ZXJuT3V0bGluZXMgPSBmdW5jdGlvbiAob3V0bGluZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgb3V0bGluZXMubWFwKGZ1bmN0aW9uIChvdXRsaW5lKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQob3V0bGluZSkuY29uY2F0KGZsYXRlcm5TaW5nbGVPdXRsaW5lKG91dGxpbmUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciB1c2VPdXRsaW5lcyA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgdmFyIF9hID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShbXSksIG91dGxpbmVzID0gX2FbMF0sIHNldE91dGxpbmVzID0gX2FbMV07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2MuZ2V0T3V0bGluZSgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50ICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGZsYXRlcm5PdXRsaW5lcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHNldE91dGxpbmVzKGl0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBvdXRsaW5lcztcbn07XG5cbnZhciBSRVNJWkVfRVZFTlRfT1BUSU9OUyA9IHtcbiAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICBwYXNzaXZlOiB0cnVlLFxufTtcbnZhciBaRVJPX1JFQ1QkMSA9IHtcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG59O1xudmFyIHVzZVdpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKFpFUk9fUkVDVCQxKSwgd2luZG93UmVjdCA9IF9hWzBdLCBzZXRXaW5kb3dSZWN0ID0gX2FbMV07XG4gICAgdmFyIGhhbmRsZVJlc2l6ZSA9IHVzZURlYm91bmNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRXaW5kb3dSZWN0KHtcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICB9KTtcbiAgICB9LCAxMDApO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplLCBSRVNJWkVfRVZFTlRfT1BUSU9OUyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplLCBSRVNJWkVfRVZFTlRfT1BUSU9OUyk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB3aW5kb3dSZWN0O1xufTtcblxudmFyIFpFUk9fUkVDVCA9IHtcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG59O1xudmFyIHVzZUZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZ2V0Q3VycmVudFBhZ2UgPSBfYS5nZXRDdXJyZW50UGFnZSwgZ2V0Q3VycmVudFNjcm9sbE1vZGUgPSBfYS5nZXRDdXJyZW50U2Nyb2xsTW9kZSwganVtcFRvUGFnZSA9IF9hLmp1bXBUb1BhZ2UsIHRhcmdldFJlZiA9IF9hLnRhcmdldFJlZjtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuTm9ybWFsKSwgZnVsbFNjcmVlbk1vZGUgPSBfYlswXSwgc2V0RnVsbFNjcmVlbk1vZGUgPSBfYlsxXTtcbiAgICB2YXIgd2luZG93UmVjdCA9IHVzZVdpbmRvd1Jlc2l6ZSgpO1xuICAgIHZhciBfYyA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoWkVST19SRUNUKSwgdGFyZ2V0UmVjdCA9IF9jWzBdLCBzZXRUYXJnZXRSZWN0ID0gX2NbMV07XG4gICAgdmFyIHdpbmRvd1NpemVCZWZvcmVGdWxsU2NyZWVuUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoWkVST19SRUNUKTtcbiAgICB2YXIgdGFyZ2V0UGFnZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGdldEN1cnJlbnRQYWdlKCkpO1xuICAgIHZhciBmdWxsU2NyZWVuU2l6ZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKFpFUk9fUkVDVCk7XG4gICAgdmFyIF9kID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh0YXJnZXRSZWYuY3VycmVudCksIGVsZW1lbnQgPSBfZFswXSwgc2V0RWxlbWVudCA9IF9kWzFdO1xuICAgIHZhciBmdWxsU2NyZWVuRWxlbWVudFJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YXJnZXRSZWYuY3VycmVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgc2V0RWxlbWVudCh0YXJnZXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbyA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGVudHJ5LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICAgICAgICAgIHNldFRhcmdldFJlY3QoeyBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRoIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW8udW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgaW8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgdmFyIGNsb3NlT3RoZXJGdWxsU2NyZWVuID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBjdXJyZW50RnVsbFNjcmVlbkVsZSA9IGdldEZ1bGxTY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbFNjcmVlbkVsZSAmJiBjdXJyZW50RnVsbFNjcmVlbkVsZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLk5vcm1hbCk7XG4gICAgICAgICAgICByZXR1cm4gZXhpdEZ1bGxTY3JlZW4oY3VycmVudEZ1bGxTY3JlZW5FbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGVudGVyRnVsbFNjcmVlbk1vZGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIWlzRnVsbFNjcmVlbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldEVsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgY2xvc2VPdGhlckZ1bGxTY3JlZW4odGFyZ2V0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bGxTY3JlZW5FbGVtZW50UmVmLmN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyaW5nKTtcbiAgICAgICAgICAgIHJlcXVlc3RGdWxsU2NyZWVuKHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgZXhpdEZ1bGxTY3JlZW5Nb2RlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50RnVsbFNjcmVlbkVsZSA9IGdldEZ1bGxTY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbFNjcmVlbkVsZSkge1xuICAgICAgICAgICAgc2V0RnVsbFNjcmVlbk1vZGUoZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FeGl0dGluZyk7XG4gICAgICAgICAgICBleGl0RnVsbFNjcmVlbihkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIGhhbmRsZUZ1bGxTY3JlZW5DaGFuZ2UgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRGdWxsU2NyZWVuRWxlID0gZ2V0RnVsbFNjcmVlbkVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsU2NyZWVuRWxlICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkV4aXR0aW5nKTtcbiAgICAgICAgfVxuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGZ1bGxTY3JlZW5Nb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJpbmc6XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxTY3JlZW5FbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFNjcmVlbkVsZW1lbnRSZWYuY3VycmVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhcigtLXJwdi1jb3JlX19mdWxsLXNjcmVlbi10YXJnZXQtYmFja2dyb3VuZC1jb2xvciknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRQYWdlUmVmLmN1cnJlbnQgPSBnZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICAgICAgICAgIHdpbmRvd1NpemVCZWZvcmVGdWxsU2NyZWVuUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkOlxuICAgICAgICAgICAgICAgIGlmIChnZXRDdXJyZW50U2Nyb2xsTW9kZSgpID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBqdW1wVG9QYWdlKHRhcmdldFBhZ2VSZWYuY3VycmVudCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWRDb21wbGV0ZWx5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWRDb21wbGV0ZWx5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRXhpdHRpbmc6XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxTY3JlZW5FbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFNjcmVlbkVsZW1lbnRSZWYuY3VycmVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZnVsbFNjcmVlbkVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFBhZ2VSZWYuY3VycmVudCA9IGdldEN1cnJlbnRQYWdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRXhpdGVkOlxuICAgICAgICAgICAgICAgIHNldEZ1bGxTY3JlZW5Nb2RlKGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuTm9ybWFsKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q3VycmVudFNjcm9sbE1vZGUoKSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAganVtcFRvUGFnZSh0YXJnZXRQYWdlUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIFtmdWxsU2NyZWVuTW9kZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZ1bGxTY3JlZW5Nb2RlID09PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLk5vcm1hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmluZyAmJlxuICAgICAgICAgICAgd2luZG93UmVjdC5oZWlnaHQgPT09IHRhcmdldFJlY3QuaGVpZ2h0ICYmXG4gICAgICAgICAgICB3aW5kb3dSZWN0LndpZHRoID09PSB0YXJnZXRSZWN0LndpZHRoICYmXG4gICAgICAgICAgICB3aW5kb3dSZWN0LmhlaWdodCA+IDAgJiZcbiAgICAgICAgICAgIHdpbmRvd1JlY3Qud2lkdGggPiAwICYmXG4gICAgICAgICAgICAoZnVsbFNjcmVlblNpemVSZWYuY3VycmVudC5oZWlnaHQgPT09IDAgfHwgd2luZG93UmVjdC5oZWlnaHQgPT0gZnVsbFNjcmVlblNpemVSZWYuY3VycmVudC5oZWlnaHQpKSB7XG4gICAgICAgICAgICBmdWxsU2NyZWVuU2l6ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FeGl0dGluZyAmJlxuICAgICAgICAgICAgd2luZG93U2l6ZUJlZm9yZUZ1bGxTY3JlZW5SZWYuY3VycmVudC5oZWlnaHQgPT09IHdpbmRvd1JlY3QuaGVpZ2h0ICYmXG4gICAgICAgICAgICB3aW5kb3dTaXplQmVmb3JlRnVsbFNjcmVlblJlZi5jdXJyZW50LndpZHRoID09PSB3aW5kb3dSZWN0LndpZHRoICYmXG4gICAgICAgICAgICB3aW5kb3dSZWN0LmhlaWdodCA+IDAgJiZcbiAgICAgICAgICAgIHdpbmRvd1JlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICBzZXRGdWxsU2NyZWVuTW9kZShleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkV4aXRlZCk7XG4gICAgICAgIH1cbiAgICB9LCBbZnVsbFNjcmVlbk1vZGUsIHdpbmRvd1JlY3QsIHRhcmdldFJlY3RdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZEZ1bGxTY3JlZW5DaGFuZ2VMaXN0ZW5lcihoYW5kbGVGdWxsU2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbW92ZUZ1bGxTY3JlZW5DaGFuZ2VMaXN0ZW5lcihoYW5kbGVGdWxsU2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZWxlbWVudF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVudGVyRnVsbFNjcmVlbk1vZGU6IGVudGVyRnVsbFNjcmVlbk1vZGUsXG4gICAgICAgIGV4aXRGdWxsU2NyZWVuTW9kZTogZXhpdEZ1bGxTY3JlZW5Nb2RlLFxuICAgICAgICBmdWxsU2NyZWVuTW9kZTogZnVsbFNjcmVlbk1vZGUsXG4gICAgfTtcbn07XG5cbnZhciBERUZBVUxUX1BBR0VfTEFZT1VUID0ge1xuICAgIGJ1aWxkUGFnZVN0eWxlczogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHt9KTsgfSxcbiAgICB0cmFuc2Zvcm1TaXplOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHNpemUgPSBfYS5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9LFxufTtcbnZhciBaRVJPX09GRlNFVCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbn07XG52YXIgSW5uZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY3VycmVudEZpbGUgPSBfYS5jdXJyZW50RmlsZSwgZGVmYXVsdFNjYWxlID0gX2EuZGVmYXVsdFNjYWxlLCBkb2MgPSBfYS5kb2MsIGVuYWJsZVNtb290aFNjcm9sbCA9IF9hLmVuYWJsZVNtb290aFNjcm9sbCwgaW5pdGlhbFBhZ2UgPSBfYS5pbml0aWFsUGFnZSwgaW5pdGlhbFJvdGF0aW9uID0gX2EuaW5pdGlhbFJvdGF0aW9uLCBpbml0aWFsU2NhbGUgPSBfYS5pbml0aWFsU2NhbGUsIHBhZ2VMYXlvdXQgPSBfYS5wYWdlTGF5b3V0LCBwYWdlU2l6ZXMgPSBfYS5wYWdlU2l6ZXMsIHBsdWdpbnMgPSBfYS5wbHVnaW5zLCByZW5kZXJQYWdlID0gX2EucmVuZGVyUGFnZSwgc2Nyb2xsTW9kZSA9IF9hLnNjcm9sbE1vZGUsIHNldFJlbmRlclJhbmdlID0gX2Euc2V0UmVuZGVyUmFuZ2UsIHZpZXdNb2RlID0gX2Eudmlld01vZGUsIHZpZXdlclN0YXRlID0gX2Eudmlld2VyU3RhdGUsIG9uRG9jdW1lbnRMb2FkID0gX2Eub25Eb2N1bWVudExvYWQsIG9uT3BlbkZpbGUgPSBfYS5vbk9wZW5GaWxlLCBvblBhZ2VDaGFuZ2UgPSBfYS5vblBhZ2VDaGFuZ2UsIG9uUm90YXRlID0gX2Eub25Sb3RhdGUsIG9uUm90YXRlUGFnZSA9IF9hLm9uUm90YXRlUGFnZSwgb25ab29tID0gX2Eub25ab29tO1xuICAgIHZhciBudW1QYWdlcyA9IGRvYy5udW1QYWdlcztcbiAgICB2YXIgZG9jSWQgPSBkb2MubG9hZGluZ1Rhc2suZG9jSWQ7XG4gICAgdmFyIGwxMG4gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoTG9jYWxpemF0aW9uQ29udGV4dCkubDEwbjtcbiAgICB2YXIgdGhlbWVDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG4gICAgdmFyIGlzUnRsID0gdGhlbWVDb250ZXh0LmRpcmVjdGlvbiA9PT0gZXhwb3J0cy5UZXh0RGlyZWN0aW9uLlJpZ2h0VG9MZWZ0O1xuICAgIHZhciBjb250YWluZXJSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBwYWdlc1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShpbml0aWFsUGFnZSksIGN1cnJlbnRQYWdlID0gX2JbMF0sIHNldEN1cnJlbnRQYWdlID0gX2JbMV07XG4gICAgdmFyIG1vc3RSZWNlbnRWaXNpdGVkUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYobnVsbCk7XG4gICAgdmFyIGRlc3RpbmF0aW9uTWFuYWdlciA9IHVzZURlc3RpbmF0aW9uKHtcbiAgICAgICAgZ2V0Q3VycmVudFBhZ2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4OyB9LFxuICAgIH0pO1xuICAgIHZhciBfYyA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoaW5pdGlhbFJvdGF0aW9uKSwgcm90YXRpb24gPSBfY1swXSwgc2V0Um90YXRpb24gPSBfY1sxXTtcbiAgICB2YXIgcHJldmlvdXNSb3RhdGlvbiA9IHVzZVByZXZpb3VzKHJvdGF0aW9uKTtcbiAgICB2YXIgX2QgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKSwgcGFnZXNSb3RhdGlvbkNoYW5nZWQgPSBfZFswXSwgc2V0UGFnZXNSb3RhdGlvbkNoYW5nZWQgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKG5ldyBNYXAoKSksIHBhZ2VzUm90YXRpb24gPSBfZVswXSwgc2V0UGFnZXNSb3RhdGlvbiA9IF9lWzFdO1xuICAgIHZhciBfZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoc2Nyb2xsTW9kZSksIGN1cnJlbnRTY3JvbGxNb2RlID0gX2ZbMF0sIHNldEN1cnJlbnRTY3JvbGxNb2RlID0gX2ZbMV07XG4gICAgdmFyIHByZXZpb3VzU2Nyb2xsTW9kZSA9IHVzZVByZXZpb3VzKGN1cnJlbnRTY3JvbGxNb2RlKTtcbiAgICB2YXIgX2cgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHZpZXdNb2RlKSwgY3VycmVudFZpZXdNb2RlID0gX2dbMF0sIHNldEN1cnJlbnRWaWV3TW9kZSA9IF9nWzFdO1xuICAgIHZhciBwcmV2aW91c1ZpZXdNb2RlID0gdXNlUHJldmlvdXMoY3VycmVudFZpZXdNb2RlKTtcbiAgICB2YXIgb3V0bGluZXMgPSB1c2VPdXRsaW5lcyhkb2MpO1xuICAgIHZhciBfaCA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoaW5pdGlhbFNjYWxlKSwgc2NhbGUgPSBfaFswXSwgc2V0U2NhbGUgPSBfaFsxXTtcbiAgICB2YXIgcHJldmlvdXNTY2FsZSA9IHVzZVByZXZpb3VzKHNjYWxlKTtcbiAgICB2YXIgc3RhdGVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZih2aWV3ZXJTdGF0ZSk7XG4gICAgdmFyIGtlZXBTcGVjaWFsWm9vbUxldmVsUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYodHlwZW9mIGRlZmF1bHRTY2FsZSA9PT0gJ3N0cmluZycgPyBkZWZhdWx0U2NhbGUgOiBudWxsKTtcbiAgICB2YXIgZm9yY2VUYXJnZXRGdWxsU2NyZWVuUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoLTEpO1xuICAgIHZhciBmb3JjZVRhcmdldFpvb21SZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigtMSk7XG4gICAgdmFyIGZvcmNlVGFyZ2V0SW5pdGlhbFBhZ2VSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihpbml0aWFsUGFnZSk7XG4gICAgdmFyIGZ1bGxTY3JlZW4gPSB1c2VGdWxsU2NyZWVuKHtcbiAgICAgICAgZ2V0Q3VycmVudFBhZ2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4OyB9LFxuICAgICAgICBnZXRDdXJyZW50U2Nyb2xsTW9kZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGVSZWYuY3VycmVudC5zY3JvbGxNb2RlOyB9LFxuICAgICAgICBqdW1wVG9QYWdlOiBmdW5jdGlvbiAocGFnZUluZGV4KSB7IHJldHVybiBqdW1wVG9QYWdlKHBhZ2VJbmRleCk7IH0sXG4gICAgICAgIHRhcmdldFJlZjogcGFnZXNSZWYsXG4gICAgfSk7XG4gICAgdmFyIF9qID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgtMSksIHJlbmRlclBhZ2VJbmRleCA9IF9qWzBdLCBzZXRSZW5kZXJQYWdlSW5kZXggPSBfalsxXTtcbiAgICB2YXIgX2sgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKDApLCByZW5kZXJRdWV1ZUtleSA9IF9rWzBdLCBzZXRSZW5kZXJRdWV1ZUtleSA9IF9rWzFdO1xuICAgIHZhciByZW5kZXJRdWV1ZSA9IHVzZVJlbmRlclF1ZXVlKHsgZG9jOiBkb2MgfSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJQYWdlc0NhY2hlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2RvY0lkXSk7XG4gICAgdmFyIGxheW91dEJ1aWxkZXIgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9QQUdFX0xBWU9VVCwgcGFnZUxheW91dCk7IH0sIFtdKTtcbiAgICB2YXIgc2l6ZXMgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkobnVtUGFnZXMpXG4gICAgICAgICAgICAuZmlsbCgwKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoXywgcGFnZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFnZVNpemUgPSBbcGFnZVNpemVzW3BhZ2VJbmRleF0ucGFnZUhlaWdodCwgcGFnZVNpemVzW3BhZ2VJbmRleF0ucGFnZVdpZHRoXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gTWF0aC5hYnMocm90YXRpb24pICUgMTgwID09PSAwXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcGFnZVNpemVbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYWdlU2l6ZVsxXSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcGFnZVNpemVbMV0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYWdlU2l6ZVswXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHBhZ2VSZWN0ID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRCdWlsZGVyLnRyYW5zZm9ybVNpemUoeyBudW1QYWdlczogbnVtUGFnZXMsIHBhZ2VJbmRleDogcGFnZUluZGV4LCBzaXplOiBwYWdlUmVjdCB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3JvdGF0aW9uLCBzY2FsZV0pO1xuICAgIHZhciB2aXJ0dWFsaXplciA9IHVzZVZpcnR1YWwoe1xuICAgICAgICBlbmFibGVTbW9vdGhTY3JvbGw6IGVuYWJsZVNtb290aFNjcm9sbCxcbiAgICAgICAgaXNSdGw6IGlzUnRsLFxuICAgICAgICBudW1iZXJPZkl0ZW1zOiBudW1QYWdlcyxcbiAgICAgICAgcGFyZW50UmVmOiBwYWdlc1JlZixcbiAgICAgICAgc2Nyb2xsTW9kZTogY3VycmVudFNjcm9sbE1vZGUsXG4gICAgICAgIHNldFJlbmRlclJhbmdlOiBzZXRSZW5kZXJSYW5nZSxcbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICB2aWV3TW9kZTogY3VycmVudFZpZXdNb2RlLFxuICAgIH0pO1xuICAgIHZhciBoYW5kbGVQYWdlc1Jlc2l6ZSA9IHVzZURlYm91bmNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWtlZXBTcGVjaWFsWm9vbUxldmVsUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQuZnVsbFNjcmVlbk1vZGUgIT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuTm9ybWFsIHx8XG4gICAgICAgICAgICAoaW5pdGlhbFBhZ2UgPiAwICYmIGZvcmNlVGFyZ2V0SW5pdGlhbFBhZ2VSZWYuY3VycmVudCA9PT0gaW5pdGlhbFBhZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgem9vbShrZWVwU3BlY2lhbFpvb21MZXZlbFJlZi5jdXJyZW50KTtcbiAgICB9LCAyMDApO1xuICAgIHVzZVRyYWNrUmVzaXplKHtcbiAgICAgICAgdGFyZ2V0UmVmOiBwYWdlc1JlZixcbiAgICAgICAgb25SZXNpemU6IGhhbmRsZVBhZ2VzUmVzaXplLFxuICAgIH0pO1xuICAgIHZhciBzZXRWaWV3ZXJTdGF0ZSA9IGZ1bmN0aW9uICh2aWV3ZXJTdGF0ZSkge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB2aWV3ZXJTdGF0ZTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ub25WaWV3ZXJTdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gcGx1Z2luLm9uVmlld2VyU3RhdGVDaGFuZ2UobmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGVSZWYuY3VycmVudCA9IG5ld1N0YXRlO1xuICAgIH07XG4gICAgdmFyIGdldFBhZ2VzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFnZXNSZWYuY3VycmVudDsgfTtcbiAgICB2YXIgZ2V0Vmlld2VyU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZVJlZi5jdXJyZW50OyB9O1xuICAgIHZhciBoYW5kbGVKdW1wRnJvbUxpbmtBbm5vdGF0aW9uID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgZGVzdGluYXRpb25NYW5hZ2VyLm1hcmtWaXNpdGVkRGVzdGluYXRpb24oZGVzdGluYXRpb24pO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgaGFuZGxlSnVtcFRvRGVzdGluYXRpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgICB2YXIgcGFnZUluZGV4ID0gZGVzdGluYXRpb24ucGFnZUluZGV4LCBib3R0b21PZmZzZXQgPSBkZXN0aW5hdGlvbi5ib3R0b21PZmZzZXQsIGxlZnRPZmZzZXQgPSBkZXN0aW5hdGlvbi5sZWZ0T2Zmc2V0LCBzY2FsZVRvID0gZGVzdGluYXRpb24uc2NhbGVUbztcbiAgICAgICAgdmFyIHBhZ2VzQ29udGFpbmVyID0gcGFnZXNSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghcGFnZXNDb250YWluZXIgfHwgIWN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICAgICAgZ2V0UGFnZShkb2MsIHBhZ2VJbmRleCkudGhlbihmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gKHR5cGVvZiBib3R0b21PZmZzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBib3R0b21PZmZzZXQodmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgOiBib3R0b21PZmZzZXQpIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSAodHlwZW9mIGxlZnRPZmZzZXQgPT09ICdmdW5jdGlvbicgPyBsZWZ0T2Zmc2V0KHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpIDogbGVmdE9mZnNldCkgfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlU2NhbGUgPSBjdXJyZW50U3RhdGUuc2NhbGU7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY2FsZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TcGVjaWFsWm9vbUxldmVsLlBhZ2VGaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tKGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlRml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlV2lkdGg6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTY2FsZSA9IGNhbGN1bGF0ZVNjYWxlKHBhZ2VzQ29udGFpbmVyLCBwYWdlU2l6ZXNbcGFnZUluZGV4XS5wYWdlSGVpZ2h0LCBwYWdlU2l6ZXNbcGFnZUluZGV4XS5wYWdlV2lkdGgsIGV4cG9ydHMuU3BlY2lhbFpvb21MZXZlbC5QYWdlV2lkdGgsIHZpZXdNb2RlLCBudW1QYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAodmlld3BvcnQuaGVpZ2h0IC0gYm90dG9tKSAqIHVwZGF0ZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgKiB1cGRhdGVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20odXBkYXRlU2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAodmlld3BvcnQuaGVpZ2h0IC0gYm90dG9tKSAqIHVwZGF0ZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgKiB1cGRhdGVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZS5zY3JvbGxNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsaXplci5zY3JvbGxUb0l0ZW0ocGFnZUluZGV4LCB7IGxlZnQ6IGxlZnQsIHRvcDogMCB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbDpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpcnR1YWxpemVyLnNjcm9sbFRvSXRlbShwYWdlSW5kZXgsIHsgbGVmdDogMCwgdG9wOiB0b3AgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBqdW1wVG9EZXN0aW5hdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uTWFuYWdlci5tYXJrVmlzaXRlZERlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUp1bXBUb0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGp1bXBUb05leHREZXN0aW5hdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dERlc3RpbmF0aW9uID0gZGVzdGluYXRpb25NYW5hZ2VyLmdldE5leHREZXN0aW5hdGlvbigpO1xuICAgICAgICByZXR1cm4gbmV4dERlc3RpbmF0aW9uID8gaGFuZGxlSnVtcFRvRGVzdGluYXRpb24obmV4dERlc3RpbmF0aW9uKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIganVtcFRvUHJldmlvdXNEZXN0aW5hdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdERlc3RpbmF0aW9uID0gZGVzdGluYXRpb25NYW5hZ2VyLmdldFByZXZpb3VzRGVzdGluYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGxhc3REZXN0aW5hdGlvbiA/IGhhbmRsZUp1bXBUb0Rlc3RpbmF0aW9uKGxhc3REZXN0aW5hdGlvbikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGp1bXBUb05leHRQYWdlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7IHJldHVybiB2aXJ0dWFsaXplci5zY3JvbGxUb05leHRJdGVtKHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4LCBaRVJPX09GRlNFVCk7IH0sIFtdKTtcbiAgICB2YXIganVtcFRvUGFnZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgICByZXR1cm4gMCA8PSBwYWdlSW5kZXggJiYgcGFnZUluZGV4IDwgbnVtUGFnZXNcbiAgICAgICAgICAgID8gdmlydHVhbGl6ZXIuc2Nyb2xsVG9JdGVtKHBhZ2VJbmRleCwgWkVST19PRkZTRVQpXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIganVtcFRvUHJldmlvdXNQYWdlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7IHJldHVybiB2aXJ0dWFsaXplci5zY3JvbGxUb1ByZXZpb3VzSXRlbShzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleCwgWkVST19PRkZTRVQpOyB9LCBbXSk7XG4gICAgdmFyIG9wZW5GaWxlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICBpZiAoZ2V0RmlsZUV4dChmaWxlLm5hbWUpLnRvTG93ZXJDYXNlKCkgIT09ICdwZGYnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGJ5dGVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIG9uT3BlbkZpbGUoZmlsZS5uYW1lLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW29uT3BlbkZpbGVdKTtcbiAgICB2YXIgcm90YXRlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBkZWdyZWVzID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlJvdGF0ZURpcmVjdGlvbi5CYWNrd2FyZCA/IC05MCA6IDkwO1xuICAgICAgICB2YXIgY3VycmVudFJvdGF0aW9uID0gc3RhdGVSZWYuY3VycmVudC5yb3RhdGlvbjtcbiAgICAgICAgdmFyIHVwZGF0ZVJvdGF0aW9uID0gY3VycmVudFJvdGF0aW9uID09PSAzNjAgfHwgY3VycmVudFJvdGF0aW9uID09PSAtMzYwID8gZGVncmVlcyA6IGN1cnJlbnRSb3RhdGlvbiArIGRlZ3JlZXM7XG4gICAgICAgIHJlbmRlclF1ZXVlLm1hcmtOb3RSZW5kZXJlZCgpO1xuICAgICAgICBzZXRSb3RhdGlvbih1cGRhdGVSb3RhdGlvbik7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyByb3RhdGlvbjogdXBkYXRlUm90YXRpb24gfSkpO1xuICAgICAgICBvblJvdGF0ZSh7IGRpcmVjdGlvbjogZGlyZWN0aW9uLCBkb2M6IGRvYywgcm90YXRpb246IHVwZGF0ZVJvdGF0aW9uIH0pO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgcm90YXRlUGFnZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhZ2VJbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBkZWdyZWVzID0gZGlyZWN0aW9uID09PSBleHBvcnRzLlJvdGF0ZURpcmVjdGlvbi5CYWNrd2FyZCA/IC05MCA6IDkwO1xuICAgICAgICB2YXIgcm90YXRpb25zID0gc3RhdGVSZWYuY3VycmVudC5wYWdlc1JvdGF0aW9uO1xuICAgICAgICB2YXIgY3VycmVudFBhZ2VSb3RhdGlvbiA9IHJvdGF0aW9ucy5oYXMocGFnZUluZGV4KSA/IHJvdGF0aW9ucy5nZXQocGFnZUluZGV4KSA6IGluaXRpYWxSb3RhdGlvbjtcbiAgICAgICAgdmFyIGZpbmFsUm90YXRpb24gPSBjdXJyZW50UGFnZVJvdGF0aW9uICsgZGVncmVlcztcbiAgICAgICAgdmFyIHVwZGF0ZVJvdGF0aW9ucyA9IHJvdGF0aW9ucy5zZXQocGFnZUluZGV4LCBmaW5hbFJvdGF0aW9uKTtcbiAgICAgICAgc2V0UGFnZXNSb3RhdGlvbih1cGRhdGVSb3RhdGlvbnMpO1xuICAgICAgICBzZXRQYWdlc1JvdGF0aW9uQ2hhbmdlZChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICF2YWx1ZTsgfSk7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyBwYWdlc1JvdGF0aW9uOiB1cGRhdGVSb3RhdGlvbnMsIHJvdGF0ZWRQYWdlOiBwYWdlSW5kZXggfSkpO1xuICAgICAgICBvblJvdGF0ZVBhZ2UoeyBkaXJlY3Rpb246IGRpcmVjdGlvbiwgZG9jOiBkb2MsIHBhZ2VJbmRleDogcGFnZUluZGV4LCByb3RhdGlvbjogZmluYWxSb3RhdGlvbiB9KTtcbiAgICAgICAgcmVuZGVyUXVldWUubWFya1JlbmRlcmluZyhwYWdlSW5kZXgpO1xuICAgICAgICBzZXRSZW5kZXJQYWdlSW5kZXgocGFnZUluZGV4KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHN3aXRjaFNjcm9sbE1vZGUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzY3JvbGxNb2RlKSB7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyBzY3JvbGxNb2RlOiBzY3JvbGxNb2RlIH0pKTtcbiAgICAgICAgc2V0Q3VycmVudFNjcm9sbE1vZGUoc2Nyb2xsTW9kZSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzd2l0Y2hWaWV3TW9kZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZpZXdNb2RlKSB7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyB2aWV3TW9kZTogdmlld01vZGUgfSkpO1xuICAgICAgICBzZXRDdXJyZW50Vmlld01vZGUodmlld01vZGUpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgem9vbSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5ld1NjYWxlKSB7XG4gICAgICAgIHZhciBwYWdlc0VsZSA9IHBhZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4O1xuICAgICAgICBpZiAoY3VycmVudFBhZ2UgPCAwIHx8IGN1cnJlbnRQYWdlID49IG51bVBhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlSGVpZ2h0ID0gcGFnZVNpemVzW2N1cnJlbnRQYWdlXS5wYWdlSGVpZ2h0O1xuICAgICAgICB2YXIgY3VycmVudFBhZ2VXaWR0aCA9IHBhZ2VTaXplc1tjdXJyZW50UGFnZV0ucGFnZVdpZHRoO1xuICAgICAgICB2YXIgdXBkYXRlU2NhbGUgPSBwYWdlc0VsZVxuICAgICAgICAgICAgPyB0eXBlb2YgbmV3U2NhbGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBjYWxjdWxhdGVTY2FsZShwYWdlc0VsZSwgY3VycmVudFBhZ2VIZWlnaHQsIGN1cnJlbnRQYWdlV2lkdGgsIG5ld1NjYWxlLCBzdGF0ZVJlZi5jdXJyZW50LnZpZXdNb2RlLCBudW1QYWdlcylcbiAgICAgICAgICAgICAgICA6IG5ld1NjYWxlXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIGtlZXBTcGVjaWFsWm9vbUxldmVsUmVmLmN1cnJlbnQgPSB0eXBlb2YgbmV3U2NhbGUgPT09ICdzdHJpbmcnID8gbmV3U2NhbGUgOiBudWxsO1xuICAgICAgICBpZiAodXBkYXRlU2NhbGUgPT09IHN0YXRlUmVmLmN1cnJlbnQuc2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSZW5kZXJRdWV1ZUtleShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgKyAxOyB9KTtcbiAgICAgICAgcmVuZGVyUXVldWUubWFya05vdFJlbmRlcmVkKCk7XG4gICAgICAgIHNldFNjYWxlKHVwZGF0ZVNjYWxlKTtcbiAgICAgICAgb25ab29tKHsgZG9jOiBkb2MsIHNjYWxlOiB1cGRhdGVTY2FsZSB9KTtcbiAgICAgICAgc2V0Vmlld2VyU3RhdGUoX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlUmVmLmN1cnJlbnQpLCB7IHNjYWxlOiB1cGRhdGVTY2FsZSB9KSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBlbnRlckZ1bGxTY3JlZW5Nb2RlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGZ1bGxTY3JlZW4uZW50ZXJGdWxsU2NyZWVuTW9kZSh0YXJnZXQpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgZXhpdEZ1bGxTY3JlZW5Nb2RlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bGxTY3JlZW4uZXhpdEZ1bGxTY3JlZW5Nb2RlKCk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0Vmlld2VyU3RhdGUoX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlUmVmLmN1cnJlbnQpLCB7IGZ1bGxTY3JlZW5Nb2RlOiBmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlIH0pKTtcbiAgICB9LCBbZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZV0pO1xuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBsdWdpbk1ldGhvZHMgPSB7XG4gICAgICAgICAgICBlbnRlckZ1bGxTY3JlZW5Nb2RlOiBlbnRlckZ1bGxTY3JlZW5Nb2RlLFxuICAgICAgICAgICAgZXhpdEZ1bGxTY3JlZW5Nb2RlOiBleGl0RnVsbFNjcmVlbk1vZGUsXG4gICAgICAgICAgICBnZXRQYWdlc0NvbnRhaW5lcjogZ2V0UGFnZXNDb250YWluZXIsXG4gICAgICAgICAgICBnZXRWaWV3ZXJTdGF0ZTogZ2V0Vmlld2VyU3RhdGUsXG4gICAgICAgICAgICBqdW1wVG9EZXN0aW5hdGlvbjoganVtcFRvRGVzdGluYXRpb24sXG4gICAgICAgICAgICBqdW1wVG9OZXh0RGVzdGluYXRpb246IGp1bXBUb05leHREZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGp1bXBUb1ByZXZpb3VzRGVzdGluYXRpb246IGp1bXBUb1ByZXZpb3VzRGVzdGluYXRpb24sXG4gICAgICAgICAgICBqdW1wVG9OZXh0UGFnZToganVtcFRvTmV4dFBhZ2UsXG4gICAgICAgICAgICBqdW1wVG9QcmV2aW91c1BhZ2U6IGp1bXBUb1ByZXZpb3VzUGFnZSxcbiAgICAgICAgICAgIGp1bXBUb1BhZ2U6IGp1bXBUb1BhZ2UsXG4gICAgICAgICAgICBvcGVuRmlsZTogb3BlbkZpbGUsXG4gICAgICAgICAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICAgICAgICAgIHJvdGF0ZVBhZ2U6IHJvdGF0ZVBhZ2UsXG4gICAgICAgICAgICBzZXRWaWV3ZXJTdGF0ZTogc2V0Vmlld2VyU3RhdGUsXG4gICAgICAgICAgICBzd2l0Y2hTY3JvbGxNb2RlOiBzd2l0Y2hTY3JvbGxNb2RlLFxuICAgICAgICAgICAgc3dpdGNoVmlld01vZGU6IHN3aXRjaFZpZXdNb2RlLFxuICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgfTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4uaW5zdGFsbCkge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKHBsdWdpbk1ldGhvZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi51bmluc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnVuaW5zdGFsbChwbHVnaW5NZXRob2RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbZG9jSWRdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uRG9jdW1lbnRMb2FkKHsgZG9jOiBkb2MsIGZpbGU6IGN1cnJlbnRGaWxlIH0pO1xuICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luLm9uRG9jdW1lbnRMb2FkICYmIHBsdWdpbi5vbkRvY3VtZW50TG9hZCh7IGRvYzogZG9jLCBmaWxlOiBjdXJyZW50RmlsZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2RvY0lkXSk7XG4gICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IHZpcnR1YWxpemVyLmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICB1c2VSdW5PbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluaXRpYWxQYWdlKSB7XG4gICAgICAgICAgICBqdW1wVG9QYWdlKGluaXRpYWxQYWdlKTtcbiAgICAgICAgfVxuICAgIH0sIGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgPiAwICYmIGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCA+IDApO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGF0ZXN0UGFnZSA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4O1xuICAgICAgICBpZiAobGF0ZXN0UGFnZSA+IC0xICYmIHByZXZpb3VzU2Nyb2xsTW9kZSAhPT0gY3VycmVudFNjcm9sbE1vZGUpIHtcbiAgICAgICAgICAgIHZpcnR1YWxpemVyLnNjcm9sbFRvSXRlbShsYXRlc3RQYWdlLCBaRVJPX09GRlNFVCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJlZENvbXBsZXRlbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmFibGVTbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclF1ZXVlLm1hcmtOb3RSZW5kZXJlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVGFyZ2V0RnVsbFNjcmVlblJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFNjcm9sbE1vZGVdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhdGVzdFBhZ2UgPSBzdGF0ZVJlZi5jdXJyZW50LnBhZ2VJbmRleDtcbiAgICAgICAgaWYgKGxhdGVzdFBhZ2UgPiAtMSAmJiBwcmV2aW91c1JvdGF0aW9uICE9PSByb3RhdGlvbikge1xuICAgICAgICAgICAgdmlydHVhbGl6ZXIuc2Nyb2xsVG9JdGVtKGxhdGVzdFBhZ2UsIFpFUk9fT0ZGU0VUKTtcbiAgICAgICAgfVxuICAgIH0sIFtyb3RhdGlvbl0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJldmlvdXNTY2FsZSAhPSAwICYmIHByZXZpb3VzU2NhbGUgIT0gc3RhdGVSZWYuY3VycmVudC5zY2FsZSkge1xuICAgICAgICAgICAgdmlydHVhbGl6ZXIuem9vbShzdGF0ZVJlZi5jdXJyZW50LnNjYWxlIC8gcHJldmlvdXNTY2FsZSwgc3RhdGVSZWYuY3VycmVudC5wYWdlSW5kZXgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlID09PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyZWRDb21wbGV0ZWx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVGFyZ2V0Wm9vbVJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbc2NhbGVdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzVmlld01vZGUgPT09IHN0YXRlUmVmLmN1cnJlbnQudmlld01vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRQYWdlID0gdmlydHVhbGl6ZXIuc3RhcnRQYWdlLCBlbmRQYWdlID0gdmlydHVhbGl6ZXIuZW5kUGFnZSwgdmlydHVhbEl0ZW1zID0gdmlydHVhbGl6ZXIudmlydHVhbEl0ZW1zO1xuICAgICAgICByZW5kZXJRdWV1ZS5tYXJrTm90UmVuZGVyZWQoKTtcbiAgICAgICAgcmVuZGVyUXVldWUuc2V0UmFuZ2Uoc3RhcnRQYWdlLCBlbmRQYWdlKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB2aXJ0dWFsSXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5pbmRleCA9PT0gaTsgfSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclF1ZXVlLnNldFZpc2liaWxpdHkoaSwgaXRlbS52aXNpYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0UGFnZTsgaSA8PSBlbmRQYWdlOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyTmV4dFBhZ2UoKTtcbiAgICB9LCBbY3VycmVudFZpZXdNb2RlXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXRlc3RQYWdlID0gc3RhdGVSZWYuY3VycmVudC5wYWdlSW5kZXg7XG4gICAgICAgIGlmIChsYXRlc3RQYWdlID4gLTEgJiYgcHJldmlvdXNWaWV3TW9kZSAhPT0gY3VycmVudFZpZXdNb2RlKSB7XG4gICAgICAgICAgICB2aXJ0dWFsaXplci5zY3JvbGxUb0l0ZW0obGF0ZXN0UGFnZSwgWkVST19PRkZTRVQpO1xuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRWaWV3TW9kZV0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGF0ZXN0UGFnZSA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4O1xuICAgICAgICBpZiAobGF0ZXN0UGFnZSA+IDAgJiZcbiAgICAgICAgICAgIGxhdGVzdFBhZ2UgPT09IGluaXRpYWxQYWdlICYmXG4gICAgICAgICAgICBmb3JjZVRhcmdldEluaXRpYWxQYWdlUmVmLmN1cnJlbnQgPT09IGluaXRpYWxQYWdlICYmXG4gICAgICAgICAgICBrZWVwU3BlY2lhbFpvb21MZXZlbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBmb3JjZVRhcmdldEluaXRpYWxQYWdlUmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICAgIHpvb20oa2VlcFNwZWNpYWxab29tTGV2ZWxSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFBhZ2VdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc1Ntb290aFNjcm9sbGluZyA9IHZpcnR1YWxpemVyLmlzU21vb3RoU2Nyb2xsaW5nO1xuICAgICAgICBpZiAoaXNTbW9vdGhTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9zdFJlY2VudFZpc2l0ZWRSZWYuY3VycmVudCA9PT0gbnVsbCB8fCBtb3N0UmVjZW50VmlzaXRlZFJlZi5jdXJyZW50ICE9PSBjdXJyZW50UGFnZSkge1xuICAgICAgICAgICAgbW9zdFJlY2VudFZpc2l0ZWRSZWYuY3VycmVudCA9IGN1cnJlbnRQYWdlO1xuICAgICAgICAgICAgb25QYWdlQ2hhbmdlKHsgY3VycmVudFBhZ2U6IGN1cnJlbnRQYWdlLCBkb2M6IGRvYyB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtjdXJyZW50UGFnZSwgdmlydHVhbGl6ZXIuaXNTbW9vdGhTY3JvbGxpbmddKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlID09PSBleHBvcnRzLkZ1bGxTY3JlZW5Nb2RlLkVudGVyaW5nICYmIHN0YXRlUmVmLmN1cnJlbnQuc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UpIHtcbiAgICAgICAgICAgIGZvcmNlVGFyZ2V0RnVsbFNjcmVlblJlZi5jdXJyZW50ID0gc3RhdGVSZWYuY3VycmVudC5wYWdlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJlZENvbXBsZXRlbHkgJiZcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQuc2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLlBhZ2UgJiZcbiAgICAgICAgICAgIGVuYWJsZVNtb290aFNjcm9sbCkge1xuICAgICAgICAgICAgZm9yY2VUYXJnZXRGdWxsU2NyZWVuUmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkQ29tcGxldGVseSAmJiBrZWVwU3BlY2lhbFpvb21MZXZlbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBmb3JjZVRhcmdldFpvb21SZWYuY3VycmVudCA9IHN0YXRlUmVmLmN1cnJlbnQucGFnZUluZGV4O1xuICAgICAgICAgICAgem9vbShrZWVwU3BlY2lhbFpvb21MZXZlbFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH0sIFtmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmluZyB8fFxuICAgICAgICAgICAgZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FeGl0dGluZyB8fFxuICAgICAgICAgICAgdmlydHVhbGl6ZXIuaXNTbW9vdGhTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRQYWdlID0gdmlydHVhbGl6ZXIuc3RhcnRQYWdlLCBlbmRQYWdlID0gdmlydHVhbGl6ZXIuZW5kUGFnZSwgbWF4VmlzYmlsaXR5SW5kZXggPSB2aXJ0dWFsaXplci5tYXhWaXNiaWxpdHlJbmRleCwgdmlydHVhbEl0ZW1zID0gdmlydHVhbGl6ZXIudmlydHVhbEl0ZW1zO1xuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSBtYXhWaXNiaWxpdHlJbmRleDtcbiAgICAgICAgdmFyIGlzRnVsbFNjcmVlbiA9IGZ1bGxTY3JlZW4uZnVsbFNjcmVlbk1vZGUgPT09IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuRW50ZXJlZCB8fFxuICAgICAgICAgICAgZnVsbFNjcmVlbi5mdWxsU2NyZWVuTW9kZSA9PT0gZXhwb3J0cy5GdWxsU2NyZWVuTW9kZS5FbnRlcmVkQ29tcGxldGVseTtcbiAgICAgICAgaWYgKGlzRnVsbFNjcmVlbiAmJiBjdXJyZW50UGFnZSAhPT0gZm9yY2VUYXJnZXRGdWxsU2NyZWVuUmVmLmN1cnJlbnQgJiYgZm9yY2VUYXJnZXRGdWxsU2NyZWVuUmVmLmN1cnJlbnQgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bGxTY3JlZW4gJiYgY3VycmVudFBhZ2UgIT09IGZvcmNlVGFyZ2V0Wm9vbVJlZi5jdXJyZW50ICYmIGZvcmNlVGFyZ2V0Wm9vbVJlZi5jdXJyZW50ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRDdXJyZW50UGFnZShjdXJyZW50UGFnZSk7XG4gICAgICAgIHNldFZpZXdlclN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZVJlZi5jdXJyZW50KSwgeyBwYWdlSW5kZXg6IGN1cnJlbnRQYWdlIH0pKTtcbiAgICAgICAgcmVuZGVyUXVldWUuc2V0UmFuZ2Uoc3RhcnRQYWdlLCBlbmRQYWdlKTtcbiAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB2aXJ0dWFsSXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5pbmRleCA9PT0gaTsgfSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclF1ZXVlLnNldFZpc2liaWxpdHkoaSwgaXRlbS52aXNpYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0UGFnZTsgaSA8PSBlbmRQYWdlOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyTmV4dFBhZ2UoKTtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyLnN0YXJ0UGFnZSxcbiAgICAgICAgdmlydHVhbGl6ZXIuZW5kUGFnZSxcbiAgICAgICAgdmlydHVhbGl6ZXIuaXNTbW9vdGhTY3JvbGxpbmcsXG4gICAgICAgIHZpcnR1YWxpemVyLm1heFZpc2JpbGl0eUluZGV4LFxuICAgICAgICBmdWxsU2NyZWVuLmZ1bGxTY3JlZW5Nb2RlLFxuICAgICAgICBwYWdlc1JvdGF0aW9uQ2hhbmdlZCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHNjYWxlLFxuICAgIF0pO1xuICAgIHZhciBoYW5kbGVQYWdlUmVuZGVyQ29tcGxldGVkID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICAgIHJlbmRlclF1ZXVlLm1hcmtSZW5kZXJlZChwYWdlSW5kZXgpO1xuICAgICAgICByZW5kZXJOZXh0UGFnZSgpO1xuICAgIH0sIFtyZW5kZXJRdWV1ZUtleV0pO1xuICAgIHZhciByZW5kZXJOZXh0UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRQYWdlID0gcmVuZGVyUXVldWUuZ2V0SGlnaGVzdFByaW9yaXR5UGFnZSgpO1xuICAgICAgICBpZiAobmV4dFBhZ2UgPiAtMSAmJiByZW5kZXJRdWV1ZS5pc0luUmFuZ2UobmV4dFBhZ2UpKSB7XG4gICAgICAgICAgICByZW5kZXJRdWV1ZS5tYXJrUmVuZGVyaW5nKG5leHRQYWdlKTtcbiAgICAgICAgICAgIHNldFJlbmRlclBhZ2VJbmRleChuZXh0UGFnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBleGVjdXRlTmFtZWRBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1BhZ2UgPSBjdXJyZW50UGFnZSAtIDE7XG4gICAgICAgIHZhciBuZXh0UGFnZSA9IGN1cnJlbnRQYWdlICsgMTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ0ZpcnN0UGFnZSc6XG4gICAgICAgICAgICAgICAganVtcFRvUGFnZSgwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xhc3RQYWdlJzpcbiAgICAgICAgICAgICAgICBqdW1wVG9QYWdlKG51bVBhZ2VzIC0gMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdOZXh0UGFnZSc6XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPCBudW1QYWdlcyAmJiBqdW1wVG9QYWdlKG5leHRQYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1ByZXZQYWdlJzpcbiAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2UgPj0gMCAmJiBqdW1wVG9QYWdlKHByZXZpb3VzUGFnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZW5kZXJWaWV3ZXIgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpcnR1YWxJdGVtcyA9IHZpcnR1YWxpemVyLnZpcnR1YWxJdGVtcztcbiAgICAgICAgdmFyIGNodW5rcyA9IFtdO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRWaWV3TW9kZSkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlOlxuICAgICAgICAgICAgICAgIGNodW5rcyA9IGNodW5rKHZpcnR1YWxJdGVtcywgMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXI6XG4gICAgICAgICAgICAgICAgaWYgKHZpcnR1YWxJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpcnR1YWxJdGVtc1swXS5pbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW1t2aXJ0dWFsSXRlbXNbMF1dXS5jb25jYXQoY2h1bmsodmlydHVhbEl0ZW1zLnNsaWNlKDEpLCAyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNodW5rKHZpcnR1YWxJdGVtcywgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlZpZXdNb2RlLlNpbmdsZVBhZ2U6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNodW5rcyA9IGNodW5rKHZpcnR1YWxJdGVtcywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZ2VMYWJlbCA9IGwxMG4gJiYgbDEwbi5jb3JlID8gbDEwbi5jb3JlLnBhZ2VMYWJlbCA6ICdQYWdlIHt7cGFnZUluZGV4fX0nO1xuICAgICAgICB2YXIgc2xvdCA9IHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncnB2LWNvcmVfX2lubmVyLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgJ2RhdGEtdGVzdGlkJzogJ2NvcmVfX2lubmVyLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwpLFxuICAgICAgICAgICAgc3ViU2xvdDoge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdkYXRhLXRlc3RpZCc6ICdjb3JlX19pbm5lci1wYWdlcycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2VzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZXMtLWhvcml6b250YWwnOiBjdXJyZW50U2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2VzLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZXMtLXNpbmdsZSc6IGN1cnJlbnRTY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZXMtLXZlcnRpY2FsJzogY3VycmVudFNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5WZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZXMtLXdyYXBwZWQnOiBjdXJyZW50U2Nyb2xsTW9kZSA9PT0gZXhwb3J0cy5TY3JvbGxNb2RlLldyYXBwZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHBhZ2VzUmVmLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcImNvcmVfX2lubmVyLWN1cnJlbnQtcGFnZS1cIi5jb25jYXQoY3VycmVudFBhZ2UpLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAnLS1zY2FsZS1mYWN0b3InOiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgdmlydHVhbGl6ZXIuZ2V0Q29udGFpbmVyU3R5bGVzKCkpIH0sIGNodW5rcy5tYXAoZnVuY3Rpb24gKGl0ZW1zKSB7IHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZS1jb250YWluZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlLWNvbnRhaW5lci0tc2luZ2xlJzogY3VycmVudFNjcm9sbE1vZGUgPT09IGV4cG9ydHMuU2Nyb2xsTW9kZS5QYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KSwgc3R5bGU6IHZpcnR1YWxpemVyLmdldEl0ZW1Db250YWluZXJTdHlsZXMoaXRlbXNbMF0pLCBrZXk6IFwiXCIuY29uY2F0KGl0ZW1zWzBdLmluZGV4LCBcIi1cIikuY29uY2F0KGN1cnJlbnRWaWV3TW9kZSkgfSwgaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0NvdmVyID0gY3VycmVudFZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlV2l0aENvdmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbS5pbmRleCA9PT0gMCB8fCAobnVtUGFnZXMgJSAyID09PSAwICYmIGl0ZW0uaW5kZXggPT09IG51bVBhZ2VzIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbFwiOiBwYWdlTGFiZWwucmVwbGFjZSgne3twYWdlSW5kZXh9fScsIFwiXCIuY29uY2F0KGl0ZW0uaW5kZXggKyAxKSksIGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2UtLWR1YWwtZXZlbic6IGN1cnJlbnRWaWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZSAmJiBpdGVtLmluZGV4ICUgMiA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2UtLWR1YWwtb2RkJzogY3VycmVudFZpZXdNb2RlID09PSBleHBvcnRzLlZpZXdNb2RlLkR1YWxQYWdlICYmIGl0ZW0uaW5kZXggJSAyID09PSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdycHYtY29yZV9faW5uZXItcGFnZS0tZHVhbC1jb3Zlcic6IGlzQ292ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlLS1kdWFsLWNvdmVyLWV2ZW4nOiBjdXJyZW50Vmlld01vZGUgPT09IGV4cG9ydHMuVmlld01vZGUuRHVhbFBhZ2VXaXRoQ292ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ292ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5pbmRleCAlIDIgPT09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19pbm5lci1wYWdlLS1kdWFsLWNvdmVyLW9kZCc6IGN1cnJlbnRWaWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5EdWFsUGFnZVdpdGhDb3ZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNDb3ZlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmluZGV4ICUgMiA9PT0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2lubmVyLXBhZ2UtLXNpbmdsZSc6IGN1cnJlbnRWaWV3TW9kZSA9PT0gZXhwb3J0cy5WaWV3TW9kZS5TaW5nbGVQYWdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY3JvbGxNb2RlID09PSBleHBvcnRzLlNjcm9sbE1vZGUuUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCByb2xlOiBcInJlZ2lvblwiLCBrZXk6IFwiXCIuY29uY2F0KGl0ZW0uaW5kZXgsIFwiLVwiKS5jb25jYXQoY3VycmVudFZpZXdNb2RlKSwgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHZpcnR1YWxpemVyLmdldEl0ZW1TdHlsZXMoaXRlbSksIGxheW91dEJ1aWxkZXIuYnVpbGRQYWdlU3R5bGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1QYWdlczogbnVtUGFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4OiBpdGVtLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbE1vZGU6IGN1cnJlbnRTY3JvbGxNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdNb2RlOiBjdXJyZW50Vmlld01vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQYWdlTGF5ZXIsIHsgZG9jOiBkb2MsIG1lYXN1cmVSZWY6IGl0ZW0ubWVhc3VyZVJlZiwgb3V0bGluZXM6IG91dGxpbmVzLCBwYWdlSW5kZXg6IGl0ZW0uaW5kZXgsIHBhZ2VSb3RhdGlvbjogcGFnZXNSb3RhdGlvbi5oYXMoaXRlbS5pbmRleCkgPyBwYWdlc1JvdGF0aW9uLmdldChpdGVtLmluZGV4KSA6IDAsIHBhZ2VTaXplOiBwYWdlU2l6ZXNbaXRlbS5pbmRleF0sIHBsdWdpbnM6IHBsdWdpbnMsIHJlbmRlclBhZ2U6IHJlbmRlclBhZ2UsIHJlbmRlclF1ZXVlS2V5OiByZW5kZXJRdWV1ZUtleSwgcm90YXRpb246IHJvdGF0aW9uLCBzY2FsZTogc2NhbGUsIHNob3VsZFJlbmRlcjogcmVuZGVyUGFnZUluZGV4ID09PSBpdGVtLmluZGV4LCB2aWV3TW9kZTogY3VycmVudFZpZXdNb2RlLCBvbkV4ZWN1dGVOYW1lZEFjdGlvbjogZXhlY3V0ZU5hbWVkQWN0aW9uLCBvbkp1bXBGcm9tTGlua0Fubm90YXRpb246IGhhbmRsZUp1bXBGcm9tTGlua0Fubm90YXRpb24sIG9uSnVtcFRvRGVzdDoganVtcFRvRGVzdGluYXRpb24sIG9uUmVuZGVyQ29tcGxldGVkOiBoYW5kbGVQYWdlUmVuZGVyQ29tcGxldGVkLCBvblJvdGF0ZVBhZ2U6IHJvdGF0ZVBhZ2UgfSkpKTtcbiAgICAgICAgICAgICAgICB9KSkpOyB9KSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ucmVuZGVyVmlld2VyKSB7XG4gICAgICAgICAgICAgICAgc2xvdCA9IHBsdWdpbi5yZW5kZXJWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJSZWY6IGNvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VzQ29udGFpbmVyUmVmOiBwYWdlc1JlZixcbiAgICAgICAgICAgICAgICAgICAgcGFnZXNSb3RhdGlvbjogcGFnZXNSb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemVzOiBwYWdlU2l6ZXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2xvdDogc2xvdCxcbiAgICAgICAgICAgICAgICAgICAgdGhlbWVDb250ZXh0OiB0aGVtZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGp1bXBUb1BhZ2U6IGp1bXBUb1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZW5GaWxlOiBvcGVuRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlOiByb3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZVBhZ2U6IHJvdGF0ZVBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFNjcm9sbE1vZGU6IHN3aXRjaFNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFZpZXdNb2RlOiBzd2l0Y2hWaWV3TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzbG90O1xuICAgIH0sIFtwbHVnaW5zLCB2aXJ0dWFsaXplcl0pO1xuICAgIHZhciByZW5kZXJTbG90ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjayhmdW5jdGlvbiAoc2xvdCkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgc2xvdC5hdHRycywgeyBzdHlsZTogc2xvdC5hdHRycyAmJiBzbG90LmF0dHJzLnN0eWxlID8gc2xvdC5hdHRycy5zdHlsZSA6IHt9IH0pLFxuICAgICAgICBzbG90LmNoaWxkcmVuLFxuICAgICAgICBzbG90LnN1YlNsb3QgJiYgcmVuZGVyU2xvdChzbG90LnN1YlNsb3QpKSk7IH0sIFtdKTtcbiAgICByZXR1cm4gcmVuZGVyU2xvdChyZW5kZXJWaWV3ZXIoKSk7XG59O1xuXG52YXIgTEVWRUxTID0gW1xuICAgIDAuMSwgMC4yLCAwLjMsIDAuNCwgMC41LCAwLjYsIDAuNywgMC44LCAwLjksIDEsIDEuMSwgMS4zLCAxLjUsIDEuNywgMS45LCAyLjEsIDIuNCwgMi43LCAzLjAsIDMuMywgMy43LCA0LjEsIDQuNixcbiAgICA1LjEsIDUuNywgNi4zLCA3LjAsIDcuNywgOC41LCA5LjQsIDEwLFxuXTtcbnZhciBkZWNyZWFzZSA9IGZ1bmN0aW9uIChjdXJyZW50TGV2ZWwpIHtcbiAgICB2YXIgZm91bmQgPSBMRVZFTFMuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtID49IGN1cnJlbnRMZXZlbDsgfSk7XG4gICAgcmV0dXJuIGZvdW5kID09PSAtMSB8fCBmb3VuZCA9PT0gMCA/IGN1cnJlbnRMZXZlbCA6IExFVkVMU1tmb3VuZCAtIDFdO1xufTtcblxudmFyIFJFU0VSVkVfSEVJR0hUID0gNDU7XG52YXIgUkVTRVJWRV9XSURUSCA9IDQ1O1xudmFyIFBhZ2VTaXplQ2FsY3VsYXRvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkZWZhdWx0U2NhbGUgPSBfYS5kZWZhdWx0U2NhbGUsIGRvYyA9IF9hLmRvYywgcmVuZGVyID0gX2EucmVuZGVyLCBzY3JvbGxNb2RlID0gX2Euc2Nyb2xsTW9kZSwgdmlld01vZGUgPSBfYS52aWV3TW9kZTtcbiAgICB2YXIgcGFnZXNSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xuICAgIHZhciBfYiA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xuICAgICAgICBwYWdlU2l6ZXM6IFtdLFxuICAgICAgICBzY2FsZTogMCxcbiAgICB9KSwgc3RhdGUgPSBfYlswXSwgc2V0U3RhdGUgPSBfYlsxXTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeVBhZ2VTaXplcyA9IEFycmF5KGRvYy5udW1QYWdlcylcbiAgICAgICAgICAgIC5maWxsKDApXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIF8pIHtcbiAgICAgICAgICAgICAgICBnZXRQYWdlKGRvYywgaSkudGhlbihmdW5jdGlvbiAocGRmUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnQgPSBwZGZQYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFByb21pc2UuYWxsKHF1ZXJ5UGFnZVNpemVzKS50aGVuKGZ1bmN0aW9uIChwYWdlU2l6ZXMpIHtcbiAgICAgICAgICAgIHZhciBwYWdlc0VsZSA9IHBhZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhZ2VzRWxlIHx8IHBhZ2VTaXplcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdyA9IHBhZ2VTaXplc1swXS5wYWdlV2lkdGg7XG4gICAgICAgICAgICB2YXIgaCA9IHBhZ2VTaXplc1swXS5wYWdlSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHBhcmVudEVsZSA9IHBhZ2VzRWxlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgc2NhbGVXaWR0aCA9IChwYXJlbnRFbGUuY2xpZW50V2lkdGggLSBSRVNFUlZFX1dJRFRIKSAvIHc7XG4gICAgICAgICAgICB2YXIgc2NhbGVIZWlnaHQgPSAocGFyZW50RWxlLmNsaWVudEhlaWdodCAtIFJFU0VSVkVfSEVJR0hUKSAvIGg7XG4gICAgICAgICAgICB2YXIgc2NhbGVkID0gc2NhbGVXaWR0aDtcbiAgICAgICAgICAgIHN3aXRjaCAoc2Nyb2xsTW9kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5TY3JvbGxNb2RlLkhvcml6b250YWw6XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZCA9IE1hdGgubWluKHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlNjcm9sbE1vZGUuVmVydGljYWw6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVkID0gc2NhbGVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBkZWZhdWx0U2NhbGVcbiAgICAgICAgICAgICAgICA/IHR5cGVvZiBkZWZhdWx0U2NhbGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gY2FsY3VsYXRlU2NhbGUocGFyZW50RWxlLCBoLCB3LCBkZWZhdWx0U2NhbGUsIHZpZXdNb2RlLCBkb2MubnVtUGFnZXMpXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFNjYWxlXG4gICAgICAgICAgICAgICAgOiBkZWNyZWFzZShzY2FsZWQpO1xuICAgICAgICAgICAgc2V0U3RhdGUoeyBwYWdlU2l6ZXM6IHBhZ2VTaXplcywgc2NhbGU6IHNjYWxlIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbZG9jLmxvYWRpbmdUYXNrLmRvY0lkXSk7XG4gICAgcmV0dXJuIHN0YXRlLnBhZ2VTaXplcy5sZW5ndGggPT09IDAgfHwgc3RhdGUuc2NhbGUgPT09IDAgPyAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19wYWdlLXNpemUtY2FsY3VsYXRvclwiLCBcImRhdGEtdGVzdGlkXCI6IFwiY29yZV9fcGFnZS1zaXplLWNhbGN1bGF0aW5nXCIsIHJlZjogcGFnZXNSZWYgfSxcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFNwaW5uZXIsIG51bGwpKSkgOiAocmVuZGVyKHN0YXRlLnBhZ2VTaXplcywgc3RhdGUuc2NhbGUpKTtcbn07XG5cbnZhciBMb2FkaW5nU3RhdHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2FkaW5nU3RhdHVzKCkge1xuICAgIH1cbiAgICByZXR1cm4gTG9hZGluZ1N0YXR1cztcbn0oKSk7XG5cbnZhciBBc2tGb3JQYXNzd29yZFN0YXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNrRm9yUGFzc3dvcmRTdGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc2tGb3JQYXNzd29yZFN0YXRlKHZlcmlmeVBhc3N3b3JkLCBwYXNzd29yZFN0YXR1cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52ZXJpZnlQYXNzd29yZCA9IHZlcmlmeVBhc3N3b3JkO1xuICAgICAgICBfdGhpcy5wYXNzd29yZFN0YXR1cyA9IHBhc3N3b3JkU3RhdHVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBc2tGb3JQYXNzd29yZFN0YXRlO1xufShMb2FkaW5nU3RhdHVzKSk7XG5cbnZhciBBc2tpbmdQYXNzd29yZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwYXNzd29yZFN0YXR1cyA9IF9hLnBhc3N3b3JkU3RhdHVzLCByZW5kZXJQcm90ZWN0ZWRWaWV3ID0gX2EucmVuZGVyUHJvdGVjdGVkVmlldywgdmVyaWZ5UGFzc3dvcmQgPSBfYS52ZXJpZnlQYXNzd29yZCwgb25Eb2N1bWVudEFza1Bhc3N3b3JkID0gX2Eub25Eb2N1bWVudEFza1Bhc3N3b3JkO1xuICAgIHZhciBsMTBuID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KExvY2FsaXphdGlvbkNvbnRleHQpLmwxMG47XG4gICAgdmFyIF9iID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgnJyksIHBhc3N3b3JkID0gX2JbMF0sIHNldFBhc3N3b3JkID0gX2JbMV07XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgc3VibWl0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpOyB9O1xuICAgIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBzdWJtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob25Eb2N1bWVudEFza1Bhc3N3b3JkKSB7XG4gICAgICAgICAgICBvbkRvY3VtZW50QXNrUGFzc3dvcmQoe1xuICAgICAgICAgICAgICAgIHZlcmlmeVBhc3N3b3JkOiB2ZXJpZnlQYXNzd29yZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGlmIChyZW5kZXJQcm90ZWN0ZWRWaWV3KSB7XG4gICAgICAgIHJldHVybiByZW5kZXJQcm90ZWN0ZWRWaWV3KHtcbiAgICAgICAgICAgIHBhc3N3b3JkU3RhdHVzOiBwYXNzd29yZFN0YXR1cyxcbiAgICAgICAgICAgIHZlcmlmeVBhc3N3b3JkOiB2ZXJpZnlQYXNzd29yZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJwdi1jb3JlX19hc2tpbmctcGFzc3dvcmQtd3JhcHBlclwiIH0sXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hc2tpbmctcGFzc3dvcmQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdycHYtY29yZV9fYXNraW5nLXBhc3N3b3JkLS1ydGwnOiBpc1J0bCxcbiAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnB2LWNvcmVfX2Fza2luZy1wYXNzd29yZC1tZXNzYWdlXCIgfSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZFN0YXR1cyA9PT0gZXhwb3J0cy5QYXNzd29yZFN0YXR1cy5SZXF1aXJlZFBhc3N3b3JkICYmXG4gICAgICAgICAgICAgICAgICAgIGwxMG4uY29yZS5hc2tpbmdQYXNzd29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcXVpcmVQYXNzd29yZFRvT3BlbixcbiAgICAgICAgICAgICAgICBwYXNzd29yZFN0YXR1cyA9PT0gZXhwb3J0cy5QYXNzd29yZFN0YXR1cy5Xcm9uZ1Bhc3N3b3JkICYmXG4gICAgICAgICAgICAgICAgICAgIGwxMG4uY29yZS53cm9uZ1Bhc3N3b3JkLnRyeUFnYWluKSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fYXNraW5nLXBhc3N3b3JkLWJvZHlcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fza2luZy1wYXNzd29yZC1pbnB1dCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2Fza2luZy1wYXNzd29yZC1pbnB1dC0tbHRyJzogIWlzUnRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19hc2tpbmctcGFzc3dvcmQtaW5wdXQtLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoVGV4dEJveCwgeyB0ZXN0SWQ6IFwiY29yZV9fYXNraW5nLXBhc3N3b3JkLWlucHV0XCIsIHR5cGU6IFwicGFzc3dvcmRcIiwgdmFsdWU6IHBhc3N3b3JkLCBvbkNoYW5nZTogc2V0UGFzc3dvcmQsIG9uS2V5RG93bjogaGFuZGxlS2V5RG93biB9KSksXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFByaW1hcnlCdXR0b24sIHsgb25DbGljazogc3VibWl0IH0sIGwxMG4uY29yZS5hc2tpbmdQYXNzd29yZC5zdWJtaXQpKSkpKTtcbn07XG5cbnZhciBDb21wbGV0ZWRTdGF0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBsZXRlZFN0YXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBsZXRlZFN0YXRlKGRvYykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBsZXRlZFN0YXRlO1xufShMb2FkaW5nU3RhdHVzKSk7XG5cbnZhciBGYWlsdXJlU3RhdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGYWlsdXJlU3RhdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmFpbHVyZVN0YXRlKGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZhaWx1cmVTdGF0ZTtcbn0oTG9hZGluZ1N0YXR1cykpO1xuXG52YXIgTG9hZGluZ1N0YXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9hZGluZ1N0YXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvYWRpbmdTdGF0ZShwZXJjZW50YWdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wZXJjZW50YWdlcyA9IHBlcmNlbnRhZ2VzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMb2FkaW5nU3RhdGU7XG59KExvYWRpbmdTdGF0dXMpKTtcblxudmFyIERvY3VtZW50TG9hZGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoYXJhY3Rlck1hcCA9IF9hLmNoYXJhY3Rlck1hcCwgZmlsZSA9IF9hLmZpbGUsIGh0dHBIZWFkZXJzID0gX2EuaHR0cEhlYWRlcnMsIHJlbmRlciA9IF9hLnJlbmRlciwgcmVuZGVyRXJyb3IgPSBfYS5yZW5kZXJFcnJvciwgcmVuZGVyTG9hZGVyID0gX2EucmVuZGVyTG9hZGVyLCByZW5kZXJQcm90ZWN0ZWRWaWV3ID0gX2EucmVuZGVyUHJvdGVjdGVkVmlldywgdHJhbnNmb3JtR2V0RG9jdW1lbnRQYXJhbXMgPSBfYS50cmFuc2Zvcm1HZXREb2N1bWVudFBhcmFtcywgd2l0aENyZWRlbnRpYWxzID0gX2Eud2l0aENyZWRlbnRpYWxzLCBvbkRvY3VtZW50QXNrUGFzc3dvcmQgPSBfYS5vbkRvY3VtZW50QXNrUGFzc3dvcmQ7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChUaGVtZUNvbnRleHQpLmRpcmVjdGlvbjtcbiAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09IGV4cG9ydHMuVGV4dERpcmVjdGlvbi5SaWdodFRvTGVmdDtcbiAgICB2YXIgX2IgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKG5ldyBMb2FkaW5nU3RhdGUoMCkpLCBzdGF0dXMgPSBfYlswXSwgc2V0U3RhdHVzID0gX2JbMV07XG4gICAgdmFyIGRvY1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCcnKTtcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2NSZWYuY3VycmVudCA9ICcnO1xuICAgICAgICBzZXRTdGF0dXMobmV3IExvYWRpbmdTdGF0ZSgwKSk7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgUGRmSnNBcGlfX25hbWVzcGFjZS5QREZXb3JrZXIoeyBuYW1lOiBcIlBERldvcmtlcl9cIi5jb25jYXQoRGF0ZS5ub3coKSkgfSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGh0dHBIZWFkZXJzOiBodHRwSGVhZGVycyxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgd29ya2VyOiB3b3JrZXIsXG4gICAgICAgIH0sICdzdHJpbmcnID09PSB0eXBlb2YgZmlsZSA/IHsgdXJsOiBmaWxlIH0gOiB7IGRhdGE6IGZpbGUgfSwgY2hhcmFjdGVyTWFwXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjTWFwVXJsOiBjaGFyYWN0ZXJNYXAudXJsLFxuICAgICAgICAgICAgICAgIGNNYXBQYWNrZWQ6IGNoYXJhY3Rlck1hcC5pc0NvbXByZXNzZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVBhcmFtcyA9IHRyYW5zZm9ybUdldERvY3VtZW50UGFyYW1zID8gdHJhbnNmb3JtR2V0RG9jdW1lbnRQYXJhbXMocGFyYW1zKSA6IHBhcmFtcztcbiAgICAgICAgdmFyIGxvYWRpbmdUYXNrID0gUGRmSnNBcGlfX25hbWVzcGFjZS5nZXREb2N1bWVudCh0cmFuc2Zvcm1QYXJhbXMpO1xuICAgICAgICBsb2FkaW5nVGFzay5vblBhc3N3b3JkID0gZnVuY3Rpb24gKHZlcmlmeVBhc3N3b3JkLCByZWFzb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBQZGZKc0FwaV9fbmFtZXNwYWNlLlBhc3N3b3JkUmVzcG9uc2VzLk5FRURfUEFTU1dPUkQ6XG4gICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMobmV3IEFza0ZvclBhc3N3b3JkU3RhdGUodmVyaWZ5UGFzc3dvcmQsIGV4cG9ydHMuUGFzc3dvcmRTdGF0dXMuUmVxdWlyZWRQYXNzd29yZCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBkZkpzQXBpX19uYW1lc3BhY2UuUGFzc3dvcmRSZXNwb25zZXMuSU5DT1JSRUNUX1BBU1NXT1JEOlxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKG5ldyBBc2tGb3JQYXNzd29yZFN0YXRlKHZlcmlmeVBhc3N3b3JkLCBleHBvcnRzLlBhc3N3b3JkU3RhdHVzLldyb25nUGFzc3dvcmQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSBwcm9ncmVzcy50b3RhbCA+IDBcbiAgICAgICAgICAgICAgICA/XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDEwMCwgKDEwMCAqIHByb2dyZXNzLmxvYWRlZCkgLyBwcm9ncmVzcy50b3RhbClcbiAgICAgICAgICAgICAgICA6IDEwMDtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCAmJiBkb2NSZWYuY3VycmVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMobmV3IExvYWRpbmdTdGF0ZShsb2FkZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGluZ1Rhc2sucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgICAgIGRvY1JlZi5jdXJyZW50ID0gZG9jLmxvYWRpbmdUYXNrLmRvY0lkO1xuICAgICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgJiYgc2V0U3RhdHVzKG5ldyBDb21wbGV0ZWRTdGF0ZShkb2MpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGlzTW91bnRlZC5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgIXdvcmtlci5kZXN0cm95ZWQgJiZcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMobmV3IEZhaWx1cmVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlIHx8ICdDYW5ub3QgbG9hZCBkb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGVyci5uYW1lLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gICAgICAgICAgICB3b3JrZXIuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtmaWxlXSk7XG4gICAgaWYgKHN0YXR1cyBpbnN0YW5jZW9mIEFza0ZvclBhc3N3b3JkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXNraW5nUGFzc3dvcmQsIHsgcGFzc3dvcmRTdGF0dXM6IHN0YXR1cy5wYXNzd29yZFN0YXR1cywgcmVuZGVyUHJvdGVjdGVkVmlldzogcmVuZGVyUHJvdGVjdGVkVmlldywgdmVyaWZ5UGFzc3dvcmQ6IHN0YXR1cy52ZXJpZnlQYXNzd29yZCwgb25Eb2N1bWVudEFza1Bhc3N3b3JkOiBvbkRvY3VtZW50QXNrUGFzc3dvcmQgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzIGluc3RhbmNlb2YgQ29tcGxldGVkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcihzdGF0dXMuZG9jKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyBpbnN0YW5jZW9mIEZhaWx1cmVTdGF0ZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyRXJyb3IgPyAocmVuZGVyRXJyb3Ioc3RhdHVzLmVycm9yKSkgOiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAncnB2LWNvcmVfX2RvYy1lcnJvcic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Jwdi1jb3JlX19kb2MtZXJyb3ItLXJ0bCc6IGlzUnRsLFxuICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJycHYtY29yZV9fZG9jLWVycm9yLXRleHRcIiB9LCBzdGF0dXMuZXJyb3IubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IFwiY29yZV9fZG9jLWxvYWRpbmdcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICdycHYtY29yZV9fZG9jLWxvYWRpbmcnOiB0cnVlLFxuICAgICAgICAgICAgJ3Jwdi1jb3JlX19kb2MtbG9hZGluZy0tcnRsJzogaXNSdGwsXG4gICAgICAgIH0pIH0sIHJlbmRlckxvYWRlciA/IHJlbmRlckxvYWRlcihzdGF0dXMucGVyY2VudGFnZXMpIDogUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFNwaW5uZXIsIG51bGwpKSk7XG59O1xuXG52YXIgaXNEYXJrTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzO1xufTtcblxudmFyIHdpdGhUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSwgb25Td2l0Y2hUaGVtZSkge1xuICAgIHZhciBpbml0aWFsVGhlbWUgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoZW1lID09PSAnYXV0bycgPyAoaXNEYXJrTW9kZSgpID8gJ2RhcmsnIDogJ2xpZ2h0JykgOiB0aGVtZSk7IH0sIFtdKTtcbiAgICB2YXIgX2EgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGluaXRpYWxUaGVtZSksIGN1cnJlbnRUaGVtZSA9IF9hWzBdLCBzZXRDdXJyZW50VGhlbWUgPSBfYVsxXTtcbiAgICB2YXIgcHJldlRoZW1lID0gdXNlUHJldmlvdXMoY3VycmVudFRoZW1lKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGVtZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFRoZW1lKGUubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCcpO1xuICAgICAgICB9O1xuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpOyB9O1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjdXJyZW50VGhlbWUgIT09IHByZXZUaGVtZSAmJiBvblN3aXRjaFRoZW1lKSB7XG4gICAgICAgICAgICBvblN3aXRjaFRoZW1lKGN1cnJlbnRUaGVtZSk7XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFRoZW1lXSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhlbWUgIT09IGN1cnJlbnRUaGVtZSkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFRoZW1lKHRoZW1lKTtcbiAgICAgICAgfVxuICAgIH0sIFt0aGVtZV0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnRUaGVtZTogY3VycmVudFRoZW1lLFxuICAgICAgICBzZXRDdXJyZW50VGhlbWU6IHNldEN1cnJlbnRUaGVtZSxcbiAgICB9O1xufTtcblxudmFyIGlzU2FtZVVybCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHR5cGVBID0gdHlwZW9mIGE7XG4gICAgdmFyIHR5cGVCID0gdHlwZW9mIGI7XG4gICAgaWYgKHR5cGVBID09PSAnc3RyaW5nJyAmJiB0eXBlQiA9PT0gJ3N0cmluZycgJiYgYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVBID09PSAnb2JqZWN0JyAmJiB0eXBlQiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2ID09PSBiW2ldOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIE5VTV9PVkVSU0NBTl9QQUdFUyA9IDM7XG52YXIgREVGQVVMVF9SRU5ERVJfUkFOR0UgPSBmdW5jdGlvbiAodmlzaWJsZVBhZ2VzUmFuZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFBhZ2U6IHZpc2libGVQYWdlc1JhbmdlLnN0YXJ0UGFnZSAtIE5VTV9PVkVSU0NBTl9QQUdFUyxcbiAgICAgICAgZW5kUGFnZTogdmlzaWJsZVBhZ2VzUmFuZ2UuZW5kUGFnZSArIE5VTV9PVkVSU0NBTl9QQUdFUyxcbiAgICB9O1xufTtcbnZhciBWaWV3ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hhcmFjdGVyTWFwID0gX2EuY2hhcmFjdGVyTWFwLCBkZWZhdWx0U2NhbGUgPSBfYS5kZWZhdWx0U2NhbGUsIF9iID0gX2EuZW5hYmxlU21vb3RoU2Nyb2xsLCBlbmFibGVTbW9vdGhTY3JvbGwgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBmaWxlVXJsID0gX2EuZmlsZVVybCwgX2MgPSBfYS5odHRwSGVhZGVycywgaHR0cEhlYWRlcnMgPSBfYyA9PT0gdm9pZCAwID8ge30gOiBfYywgX2QgPSBfYS5pbml0aWFsUGFnZSwgaW5pdGlhbFBhZ2UgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBwYWdlTGF5b3V0ID0gX2EucGFnZUxheW91dCwgX2UgPSBfYS5pbml0aWFsUm90YXRpb24sIGluaXRpYWxSb3RhdGlvbiA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIGxvY2FsaXphdGlvbiA9IF9hLmxvY2FsaXphdGlvbiwgX2YgPSBfYS5wbHVnaW5zLCBwbHVnaW5zID0gX2YgPT09IHZvaWQgMCA/IFtdIDogX2YsIHJlbmRlckVycm9yID0gX2EucmVuZGVyRXJyb3IsIHJlbmRlckxvYWRlciA9IF9hLnJlbmRlckxvYWRlciwgcmVuZGVyUGFnZSA9IF9hLnJlbmRlclBhZ2UsIHJlbmRlclByb3RlY3RlZFZpZXcgPSBfYS5yZW5kZXJQcm90ZWN0ZWRWaWV3LCBfZyA9IF9hLnNjcm9sbE1vZGUsIHNjcm9sbE1vZGUgPSBfZyA9PT0gdm9pZCAwID8gZXhwb3J0cy5TY3JvbGxNb2RlLlZlcnRpY2FsIDogX2csIF9oID0gX2Euc2V0UmVuZGVyUmFuZ2UsIHNldFJlbmRlclJhbmdlID0gX2ggPT09IHZvaWQgMCA/IERFRkFVTFRfUkVOREVSX1JBTkdFIDogX2gsIHRyYW5zZm9ybUdldERvY3VtZW50UGFyYW1zID0gX2EudHJhbnNmb3JtR2V0RG9jdW1lbnRQYXJhbXMsIF9qID0gX2EudGhlbWUsIHRoZW1lID0gX2ogPT09IHZvaWQgMCA/IHtcbiAgICAgICAgZGlyZWN0aW9uOiBleHBvcnRzLlRleHREaXJlY3Rpb24uTGVmdFRvUmlnaHQsXG4gICAgICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgIH0gOiBfaiwgX2sgPSBfYS52aWV3TW9kZSwgdmlld01vZGUgPSBfayA9PT0gdm9pZCAwID8gZXhwb3J0cy5WaWV3TW9kZS5TaW5nbGVQYWdlIDogX2ssIF9sID0gX2Eud2l0aENyZWRlbnRpYWxzLCB3aXRoQ3JlZGVudGlhbHMgPSBfbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfbCwgb25Eb2N1bWVudEFza1Bhc3N3b3JkID0gX2Eub25Eb2N1bWVudEFza1Bhc3N3b3JkLCBfbSA9IF9hLm9uRG9jdW1lbnRMb2FkLCBvbkRvY3VtZW50TG9hZCA9IF9tID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7XG4gICAgfSA6IF9tLCBfbyA9IF9hLm9uUGFnZUNoYW5nZSwgb25QYWdlQ2hhbmdlID0gX28gPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICB9IDogX28sIF9wID0gX2Eub25Sb3RhdGUsIG9uUm90YXRlID0gX3AgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICB9IDogX3AsIF9xID0gX2Eub25Sb3RhdGVQYWdlLCBvblJvdGF0ZVBhZ2UgPSBfcSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge1xuICAgIH0gOiBfcSwgX3IgPSBfYS5vblN3aXRjaFRoZW1lLCBvblN3aXRjaFRoZW1lID0gX3IgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICB9IDogX3IsIF9zID0gX2Eub25ab29tLCBvblpvb20gPSBfcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge1xuICAgIH0gOiBfcztcbiAgICB2YXIgX3QgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHtcbiAgICAgICAgZGF0YTogZmlsZVVybCxcbiAgICAgICAgbmFtZTogdHlwZW9mIGZpbGVVcmwgPT09ICdzdHJpbmcnID8gZmlsZVVybCA6ICcnLFxuICAgICAgICBzaG91bGRMb2FkOiBmYWxzZSxcbiAgICB9KSwgZmlsZSA9IF90WzBdLCBzZXRGaWxlID0gX3RbMV07XG4gICAgdmFyIG9wZW5GaWxlID0gZnVuY3Rpb24gKGZpbGVOYW1lLCBkYXRhKSB7XG4gICAgICAgIHNldEZpbGUoe1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgc2hvdWxkTG9hZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgX3UgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKSwgdmlzaWJsZSA9IF91WzBdLCBzZXRWaXNpYmxlID0gX3VbMV07XG4gICAgdmFyIHByZXZGaWxlID0gdXNlUHJldmlvdXMoZmlsZSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzU2FtZVVybChwcmV2RmlsZS5kYXRhLCBmaWxlVXJsKSkge1xuICAgICAgICAgICAgc2V0RmlsZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogZmlsZVVybCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0eXBlb2YgZmlsZVVybCA9PT0gJ3N0cmluZycgPyBmaWxlVXJsIDogJycsXG4gICAgICAgICAgICAgICAgc2hvdWxkTG9hZDogdmlzaWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2ZpbGVVcmwsIHZpc2libGVdKTtcbiAgICB2YXIgdmlzaWJpbGl0eUNoYW5nZWQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHNldFZpc2libGUocGFyYW1zLmlzVmlzaWJsZSk7XG4gICAgICAgIGlmIChwYXJhbXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBzZXRGaWxlKGZ1bmN0aW9uIChjdXJyZW50RmlsZSkgeyByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudEZpbGUsIHsgc2hvdWxkTG9hZDogdHJ1ZSB9KTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb250YWluZXJSZWYgPSB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcih7XG4gICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZWQ6IHZpc2liaWxpdHlDaGFuZ2VkLFxuICAgIH0pO1xuICAgIHZhciB0aGVtZVByb3BzID0gdHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJyA/IHsgZGlyZWN0aW9uOiBleHBvcnRzLlRleHREaXJlY3Rpb24uTGVmdFRvUmlnaHQsIHRoZW1lOiB0aGVtZSB9IDogdGhlbWU7XG4gICAgdmFyIF92ID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShsb2NhbGl6YXRpb24gfHwgRGVmYXVsdExvY2FsaXphdGlvbiksIGwxMG4gPSBfdlswXSwgc2V0TDEwbiA9IF92WzFdO1xuICAgIHZhciBsb2NhbGl6YXRpb25Db250ZXh0ID0geyBsMTBuOiBsMTBuLCBzZXRMMTBuOiBzZXRMMTBuIH07XG4gICAgdmFyIHRoZW1lQ29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHsgZGlyZWN0aW9uOiB0aGVtZVByb3BzLmRpcmVjdGlvbiB9LCB3aXRoVGhlbWUodGhlbWVQcm9wcy50aGVtZSB8fCAnbGlnaHQnLCBvblN3aXRjaFRoZW1lKSk7XG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICBzZXRMMTBuKGxvY2FsaXphdGlvbik7XG4gICAgICAgIH1cbiAgICB9LCBbbG9jYWxpemF0aW9uXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTG9jYWxpemF0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbG9jYWxpemF0aW9uQ29udGV4dCB9LFxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoVGhlbWVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGVtZUNvbnRleHQgfSxcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyUmVmLCBjbGFzc05hbWU6IFwicnB2LWNvcmVfX3ZpZXdlciBycHYtY29yZV9fdmlld2VyLS1cIi5jb25jYXQodGhlbWVDb250ZXh0LmN1cnJlbnRUaGVtZSksIFwiZGF0YS10ZXN0aWRcIjogXCJjb3JlX192aWV3ZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgfSB9LCBmaWxlLnNob3VsZExvYWQgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChEb2N1bWVudExvYWRlciwgeyBjaGFyYWN0ZXJNYXA6IGNoYXJhY3Rlck1hcCwgZmlsZTogZmlsZS5kYXRhLCBodHRwSGVhZGVyczogaHR0cEhlYWRlcnMsIHJlbmRlcjogZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQYWdlU2l6ZUNhbGN1bGF0b3IsIHsgZGVmYXVsdFNjYWxlOiBkZWZhdWx0U2NhbGUsIGRvYzogZG9jLCByZW5kZXI6IGZ1bmN0aW9uIChwYWdlU2l6ZXMsIGluaXRpYWxTY2FsZSkgeyByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJbm5lciwgeyBjdXJyZW50RmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpbGUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBkZWZhdWx0U2NhbGU6IGRlZmF1bHRTY2FsZSwgZG9jOiBkb2MsIGVuYWJsZVNtb290aFNjcm9sbDogZW5hYmxlU21vb3RoU2Nyb2xsLCBpbml0aWFsUGFnZTogaW5pdGlhbFBhZ2UsIGluaXRpYWxSb3RhdGlvbjogaW5pdGlhbFJvdGF0aW9uLCBpbml0aWFsU2NhbGU6IGluaXRpYWxTY2FsZSwgcGFnZUxheW91dDogcGFnZUxheW91dCwgcGFnZVNpemVzOiBwYWdlU2l6ZXMsIHBsdWdpbnM6IHBsdWdpbnMsIHJlbmRlclBhZ2U6IHJlbmRlclBhZ2UsIHNjcm9sbE1vZGU6IHNjcm9sbE1vZGUsIHNldFJlbmRlclJhbmdlOiBzZXRSZW5kZXJSYW5nZSwgdmlld01vZGU6IHZpZXdNb2RlLCB2aWV3ZXJTdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFNjcmVlbk1vZGU6IGV4cG9ydHMuRnVsbFNjcmVlbk1vZGUuTm9ybWFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUhlaWdodDogcGFnZVNpemVzWzBdLnBhZ2VIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVdpZHRoOiBwYWdlU2l6ZXNbMF0ucGFnZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzUm90YXRpb246IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogaW5pdGlhbFJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBpbml0aWFsU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTW9kZTogc2Nyb2xsTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZTogdmlld01vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvbkRvY3VtZW50TG9hZDogb25Eb2N1bWVudExvYWQsIG9uT3BlbkZpbGU6IG9wZW5GaWxlLCBvblBhZ2VDaGFuZ2U6IG9uUGFnZUNoYW5nZSwgb25Sb3RhdGU6IG9uUm90YXRlLCBvblJvdGF0ZVBhZ2U6IG9uUm90YXRlUGFnZSwgb25ab29tOiBvblpvb20gfSkpOyB9LCBzY3JvbGxNb2RlOiBzY3JvbGxNb2RlLCB2aWV3TW9kZTogdmlld01vZGUgfSkpOyB9LCByZW5kZXJFcnJvcjogcmVuZGVyRXJyb3IsIHJlbmRlckxvYWRlcjogcmVuZGVyTG9hZGVyLCByZW5kZXJQcm90ZWN0ZWRWaWV3OiByZW5kZXJQcm90ZWN0ZWRWaWV3LCB0cmFuc2Zvcm1HZXREb2N1bWVudFBhcmFtczogdHJhbnNmb3JtR2V0RG9jdW1lbnRQYXJhbXMsIHdpdGhDcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzLCBvbkRvY3VtZW50QXNrUGFzc3dvcmQ6IG9uRG9jdW1lbnRBc2tQYXNzd29yZCB9KSkpKSkpO1xufTtcblxudmFyIFdvcmtlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCB3b3JrZXJVcmwgPSBfYS53b3JrZXJVcmw7XG4gICAgUGRmSnNBcGlfX25hbWVzcGFjZS5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IHdvcmtlclVybDtcbiAgICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xuZXhwb3J0cy5JY29uID0gSWNvbjtcbmV4cG9ydHMuTGF6eVJlbmRlciA9IExhenlSZW5kZXI7XG5leHBvcnRzLkxvY2FsaXphdGlvbkNvbnRleHQgPSBMb2NhbGl6YXRpb25Db250ZXh0O1xuZXhwb3J0cy5NZW51ID0gTWVudTtcbmV4cG9ydHMuTWVudURpdmlkZXIgPSBNZW51RGl2aWRlcjtcbmV4cG9ydHMuTWVudUl0ZW0gPSBNZW51SXRlbTtcbmV4cG9ydHMuTWluaW1hbEJ1dHRvbiA9IE1pbmltYWxCdXR0b247XG5leHBvcnRzLk1vZGFsID0gTW9kYWw7XG5leHBvcnRzLlBvcG92ZXIgPSBQb3BvdmVyO1xuZXhwb3J0cy5QcmltYXJ5QnV0dG9uID0gUHJpbWFyeUJ1dHRvbjtcbmV4cG9ydHMuUHJvZ3Jlc3NCYXIgPSBQcm9ncmVzc0JhcjtcbmV4cG9ydHMuU2VwYXJhdG9yID0gU2VwYXJhdG9yO1xuZXhwb3J0cy5TcGlubmVyID0gU3Bpbm5lcjtcbmV4cG9ydHMuU3BsaXR0ZXIgPSBTcGxpdHRlcjtcbmV4cG9ydHMuVGV4dEJveCA9IFRleHRCb3g7XG5leHBvcnRzLlRoZW1lQ29udGV4dCA9IFRoZW1lQ29udGV4dDtcbmV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG5leHBvcnRzLlZpZXdlciA9IFZpZXdlcjtcbmV4cG9ydHMuV29ya2VyID0gV29ya2VyO1xuZXhwb3J0cy5jaHVuayA9IGNodW5rO1xuZXhwb3J0cy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBjcmVhdGVTdG9yZTtcbmV4cG9ydHMuZ2V0RGVzdGluYXRpb24gPSBnZXREZXN0aW5hdGlvbjtcbmV4cG9ydHMuZ2V0UGFnZSA9IGdldFBhZ2U7XG5leHBvcnRzLmlzRnVsbFNjcmVlbkVuYWJsZWQgPSBpc0Z1bGxTY3JlZW5FbmFibGVkO1xuZXhwb3J0cy5pc01hYyA9IGlzTWFjO1xuZXhwb3J0cy51c2VEZWJvdW5jZUNhbGxiYWNrID0gdXNlRGVib3VuY2VDYWxsYmFjaztcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbmV4cG9ydHMudXNlSXNNb3VudGVkID0gdXNlSXNNb3VudGVkO1xuZXhwb3J0cy51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlUHJldmlvdXMgPSB1c2VQcmV2aW91cztcbmV4cG9ydHMudXNlUmVuZGVyUXVldWUgPSB1c2VSZW5kZXJRdWV1ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/cjs/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/index.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/index.js ***!
  \**************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A React component to view a PDF document\n *\n * @see https://react-pdf-viewer.dev\n * @license https://react-pdf-viewer.dev/license\n * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/core.js */ \"(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/cjs/core.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZi12aWV3ZXIrY29yZUAzLjEyLjBfcGRmanMtZGlzdEAzLjQuMTIwX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYtdmlld2VyL2NvcmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsSUFBSSx3T0FBeUM7QUFDN0MiLCJzb3VyY2VzIjpbIi9ob21lL25vZS1jYW1wby9kZWxvcy9wcm9qZXQvbGFiLWtzL2tzLWxhYi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZi12aWV3ZXIrY29yZUAzLjEyLjBfcGRmanMtZGlzdEAzLjQuMTIwX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYtdmlld2VyL2NvcmUvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdG8gdmlldyBhIFBERiBkb2N1bWVudFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdC1wZGYtdmlld2VyLmRldlxuICogQGxpY2Vuc2UgaHR0cHM6Ly9yZWFjdC1wZGYtdmlld2VyLmRldi9saWNlbnNlXG4gKiBAY29weXJpZ2h0IDIwMTktMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9jb3JlLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2NvcmUuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/styles/index.css":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/styles/index.css ***!
  \**********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e66f4f3c22e4\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZi12aWV3ZXIrY29yZUAzLjEyLjBfcGRmanMtZGlzdEAzLjQuMTIwX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYtdmlld2VyL2NvcmUvbGliL3N0eWxlcy9pbmRleC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIi9ob21lL25vZS1jYW1wby9kZWxvcy9wcm9qZXQvbGFiLWtzL2tzLWxhYi9ub2RlX21vZHVsZXMvLnBucG0vQHJlYWN0LXBkZi12aWV3ZXIrY29yZUAzLjEyLjBfcGRmanMtZGlzdEAzLjQuMTIwX3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0ByZWFjdC1wZGYtdmlld2VyL2NvcmUvbGliL3N0eWxlcy9pbmRleC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJlNjZmNGYzYzIyZTRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@react-pdf-viewer+core@3.12.0_pdfjs-dist@3.4.120_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@react-pdf-viewer/core/lib/styles/index.css\n");

/***/ })

};
;